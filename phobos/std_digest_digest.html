<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.digest.digest - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="/js/codemirror.js"></script>
<script src="/js/d.js"></script>
<script src="/js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){return lastName(a) > lastName(b)});

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="/images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="/images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="/images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos </a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>

    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>

</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std\digest\digest.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>

    <h1>std.digest.digest</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std\digest\digest.d -->
<script type="text/javascript">inhibitQuickIndex = 1</script>
<p></p>
<table cellspacing=0 cellpadding=5 class=book><caption></caption><tr><th>Category</th> <th>Functions</th>
</tr>
<tr><td valign=top class="donthyphenate">Template API</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#isDigest">isDigest</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#DigestType">DigestType</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#hasPeek">hasPeek</a>&nbsp;</font>
  <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#ExampleDigest">ExampleDigest</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#digest">digest</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#hexDigest">hexDigest</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#makeDigest">makeDigest</a>&nbsp;</font>
</td>
</tr>
<tr><td valign=top class="donthyphenate">OOP API</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#Digest">Digest</a>&nbsp;</font>
</td>
</tr>
<tr><td valign=top class="donthyphenate">Helper functions</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#toHexString">toHexString</a>&nbsp;</font></td>
</tr>
<tr><td valign=top class="donthyphenate">Implementation helpers</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#digestLength">digestLength</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#WrapperDigest">WrapperDigest</a>&nbsp;</font></td>
</tr>
</table>
<p></p>

 This module describes the <a name="digest"></a><span class="ddoc_psymbol">digest</span> APIs used in Phobos. All digests follow these APIs.
 Additionally, this module contains useful helper methods which can be used with every digest type.

<p></p>
<b>APIs:</b><br>
There are two APIs for digests: The template API and the OOP API. The template API uses structs
 and template helpers like <a href="#isDigest"><span class="d_inlinecode">isDigest</span></a>. The OOP API implements digests as classes inheriting
 the <a href="#Digest"><span class="d_inlinecode">Digest</span></a> interface. All digests are named so that the template API struct is called "<b>x</b>"
 and the OOP API class is called "<b>x</b>Digest". For example we have <span class="d_inlinecode">MD5</span> &lt;--&gt; <span class="d_inlinecode">MD5Digest</span>,
 <span class="d_inlinecode">CRC32</span> &lt;--&gt; <span class="d_inlinecode">CRC32Digest</span>, etc.
<p></p>

 The template API is slightly more efficient. It does not have to allocate memory dynamically,
 all memory is allocated on the stack. The OOP API has to allocate in the finish method if no
 buffer was provided. If you provide a buffer to the OOP APIs finish function, it doesn't allocate,
 but the <a href="#Digest"><span class="d_inlinecode">Digest</span></a> classes still have to be created using <span class="d_inlinecode">new</span> which allocates them using the GC.
<p></p>

 The OOP API is useful to change the digest function and/or digest backend at 'runtime'. The benefit here
 is that switching e.g. Phobos MD5Digest and an OpenSSLMD5Digest implementation is ABI compatible.
<p></p>

 If just one specific digest type and backend is needed, the template API is usually a good fit.
 In this simplest case, the template API can even be used without templates: Just use the "<b>x</b>" structs
 directly.

<p></p>
<b>License:</b><br><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>
<p></p>
<b>Authors:</b><br>Johannes Pfau

<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/digest/digest.d">std/digest/digest.d</a>

<p></p>
<b>CTFE:</b><br>
Digests do not work in CTFE

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">import</span> std.<span class="d_psymbol">digest</span>.crc;

<span class="d_comment">//Simple example
</span><span class="d_keyword">char</span>[8] hexHash = hexDigest!CRC32(<span class="d_string">"The quick brown fox jumps over the lazy dog"</span>);
<span class="d_keyword">assert</span>(hexHash == <span class="d_string">"39A34F41"</span>);

<span class="d_comment">//Simple example, using the API manually
</span>CRC32 context = makeDigest!CRC32();
context.put(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>[])<span class="d_string">"The quick brown fox jumps over the lazy dog"</span>);
<span class="d_keyword">ubyte</span>[4] hash = context.finish();
<span class="d_keyword">assert</span>(toHexString(hash) == <span class="d_string">"39A34F41"</span>);
</pre>
<p></p>

<pre class="d_code"><span class="d_comment">//Generating the hashes of a file, idiomatic D way
</span><span class="d_keyword">import</span> std.<span class="d_psymbol">digest</span>.crc, std.<span class="d_psymbol">digest</span>.sha, std.<span class="d_psymbol">digest</span>.md;
<span class="d_keyword">import</span> std.stdio;

<span class="d_comment">// Digests a file and prints the result.
</span><span class="d_keyword">void</span> digestFile(Hash)(string filename) <span class="d_keyword">if</span>(isDigest!Hash)
{
    <span class="d_keyword">auto</span> file = File(filename);
    <span class="d_keyword">auto</span> result = <span class="d_psymbol">digest</span>!Hash(file.byChunk(4096 * 1024));
    writefln(<span class="d_string">"%s (%s) = %s"</span>, Hash.stringof, filename, toHexString(result));
}

<span class="d_keyword">void</span> main(string[] args)
{
    <span class="d_keyword">foreach</span> (name; args[1 .. $])
    {
        digestFile!MD5(name);
        digestFile!SHA1(name);
        digestFile!CRC32(name);
    }
}
</pre>
<p></p>

<pre class="d_code"><span class="d_comment">//Generating the hashes of a file using the template API, old school way
</span><span class="d_keyword">import</span> std.<span class="d_psymbol">digest</span>.crc, std.<span class="d_psymbol">digest</span>.sha, std.<span class="d_psymbol">digest</span>.md;
<span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main(string[] args)
{
    MD5 md5;
    SHA1 sha1;
    CRC32 crc32;

    md5.start();
    sha1.start();
    crc32.start();

    <span class="d_keyword">foreach</span> (arg; args[1 .. $])
    {
        digestFile(md5, arg);
        digestFile(sha1, arg);
        digestFile(crc32, arg);
    }
}

<span class="d_comment">// Digests a file and prints the result.
</span><span class="d_keyword">void</span> digestFile(Hash)(<span class="d_keyword">ref</span> Hash hash, string filename) <span class="d_keyword">if</span>(isDigest!Hash)
{
    File file = File(filename);

    <span class="d_comment">//As digests implement OutputRange, we could use std.algorithm.copy
</span>    <span class="d_comment">//Let's do it manually for now
</span>    <span class="d_keyword">foreach</span> (buffer; file.byChunk(4096 * 1024))
        hash.put(buffer);

    <span class="d_keyword">auto</span> result = hash.finish();
    writefln(<span class="d_string">"%s (%s) = %s"</span>, hash.stringof, filename, toHexString(result));
}
</pre>
<p></p>

<pre class="d_code"><span class="d_comment">//The same using the OOP API
</span><span class="d_keyword">import</span> std.<span class="d_psymbol">digest</span>.crc, std.<span class="d_psymbol">digest</span>.sha, std.<span class="d_psymbol">digest</span>.md;
<span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main(string[] args)
{
    <span class="d_keyword">auto</span> md5 = <span class="d_keyword">new</span> MD5Digest();
    <span class="d_keyword">auto</span> sha1 = <span class="d_keyword">new</span> SHA1Digest();
    <span class="d_keyword">auto</span> crc32 = <span class="d_keyword">new</span> CRC32Digest();

    <span class="d_keyword">foreach</span> (arg; args[1 .. $])
    {
        digestFile(md5, arg);
        digestFile(sha1, arg);
        digestFile(crc32, arg);
    }
}

<span class="d_comment">// Digests a file and prints the result.
</span><span class="d_keyword">void</span> digestFile(Digest hash, string filename)
{
    File file = File(filename);

    <span class="d_comment">//As digests implement OutputRange, we could use std.algorithm.copy
</span>    <span class="d_comment">//Let's do it manually for now
</span>    <span class="d_keyword">foreach</span> (buffer; file.byChunk(4096 * 1024))
        hash.put(buffer);

    <span class="d_keyword">ubyte</span>[] result = hash.finish();
    writefln(<span class="d_string">"%s (%s) = %s"</span>, <span class="d_keyword">typeid</span>(hash).toString(), filename, toHexString(result));
}
</pre>

<p></p>
<b>TODO:</b><br>
Digesting single bits (as opposed to bytes) is not implemented. This will be done as another
 template constraint helper (hasBitDigesting!T) and an additional interface (BitDigest)<p></p>

<dl><dt class="d_decl"><a name=".ExampleDigest"></a>struct <a name="ExampleDigest"></a><span class="ddoc_psymbol">ExampleDigest</span>;
</dt>
<dd>This documents the general structure of a Digest in the template API.
 All digest implementations should implement the following members and therefore pass
 the <a href="#isDigest"><span class="d_inlinecode">isDigest</span></a> test.
<p></p>
<b>Note:</b><br>
<ul><li>A digest must be a struct (value type) to pass the <a href="#isDigest"><span class="d_inlinecode">isDigest</span></a> test.</li>
 <li>A digest passing the <a href="#isDigest"><span class="d_inlinecode">isDigest</span></a> test is always an <span class="d_inlinecode">OutputRange</span></li>
 </ul>

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_comment">//Using the OutputRange feature
</span><span class="d_keyword">import</span> std.algorithm : copy;
<span class="d_keyword">import</span> std.range : repeat;
<span class="d_keyword">import</span> std.digest.md;

<span class="d_keyword">auto</span> oneMillionRange = repeat!<span class="d_keyword">ubyte</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)'a', 1000000);
<span class="d_keyword">auto</span> ctx = makeDigest!MD5();
copy(oneMillionRange, &amp;ctx); <span class="d_comment">//Note: You must pass a pointer to copy!
</span><span class="d_keyword">assert</span>(ctx.finish().toHexString() == <span class="d_string">"7707D6AE4E027C70EEA2A935C2296F21"</span>);
</pre>
<p></p>

<dl><dt class="d_decl"><a name=".ExampleDigest.put"></a>@trusted void <a name="put"></a><span class="ddoc_psymbol">put</span>(scope const(ubyte)[] <i>data</i>...);
</dt>
<dd>Use this to feed the digest with <i>data</i>.
 Also implements the <a href="std_range.html#OutputRange"><span class="d_inlinecode">std.range.OutputRange</span></a> interface for <span class="d_inlinecode">ubyte</span> and
 <span class="d_inlinecode">const(ubyte)[]</span>.
 The following usages of <span class="d_inlinecode"><a name="put"></a><span class="ddoc_psymbol">put</span></span> must work for any type which passes <a href="#isDigest"><span class="d_inlinecode">isDigest</span></a>:
<p></p>
<b>Examples:</b><br><pre class="d_code">ExampleDigest dig;
dig.<span class="d_psymbol">put</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)0); <span class="d_comment">//single ubyte
</span>dig.<span class="d_psymbol">put</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)0, <span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)0); <span class="d_comment">//variadic
</span><span class="d_keyword">ubyte</span>[10] buf;
dig.<span class="d_psymbol">put</span>(buf); <span class="d_comment">//buffer
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".ExampleDigest.start"></a>@trusted void <a name="start"></a><span class="ddoc_psymbol">start</span>();
</dt>
<dd>This function is used to (re)initialize the digest.
 It must be called before using the digest and it also works as a 'reset' function
 if the digest has already processed data.<p></p>

</dd>
<dt class="d_decl"><a name=".ExampleDigest.finish"></a>@trusted ubyte[16] <a name="finish"></a><span class="ddoc_psymbol">finish</span>();
</dt>
<dd>The <a name="finish"></a><span class="ddoc_psymbol">finish</span> function returns the final hash sum and resets the Digest.
<p></p>
<b>Note:</b><br>
The actual type returned by <a name="finish"></a><span class="ddoc_psymbol">finish</span> depends on the digest implementation.
 <span class="d_inlinecode">ubyte[16]</span> is just used as an example. It is guaranteed that the type is a
 static array of ubytes.
<p></p>

 <ul><li>Use <a href="#DigestType"><span class="d_inlinecode">DigestType</span></a> to obtain the actual return type.</li>
 <li>Use <a href="#digestLength"><span class="d_inlinecode">digestLength</span></a> to obtain the length of the ubyte array.</li>
 </ul><p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".isDigest"></a>template <a name="isDigest"></a><span class="ddoc_psymbol">isDigest</span>(T)</dt>
<dd>Use this to check if a type is a digest. See <a href="#ExampleDigest"><span class="d_inlinecode">ExampleDigest</span></a> to see what
 a type must provide to pass this check.
<p></p>
<b>Note:</b><br>
This is very useful as a template constraint (see examples)

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">import</span> std.digest.crc;
<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_psymbol">isDigest</span>!CRC32);
</pre>
<p></p>

<pre class="d_code"><span class="d_keyword">void</span> myFunction(T)() <span class="d_keyword">if</span>(<span class="d_psymbol">isDigest</span>!T)
{
    T dig;
    dig.start();
    <span class="d_keyword">auto</span> result = dig.finish();
}
</pre>

<p></p>
<span style="color:red">BUGS:</span><br><ul><li>Does not yet verify that put takes scope parameters.</li>
 <li>Should check that finish() returns a ubyte[num] array</li>
 </ul><p></p>

</dd>
<dt class="d_decl"><a name=".DigestType"></a>template <a name="DigestType"></a><span class="ddoc_psymbol">DigestType</span>(T)</dt>
<dd>Use this template to get the type which is returned by a digest's <a href="#finish"><span class="d_inlinecode">finish</span></a> method.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">import</span> std.digest.crc;
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_psymbol">DigestType</span>!(CRC32) == <span class="d_keyword">ubyte</span>[4]));
</pre>
<p></p>

<pre class="d_code"><span class="d_keyword">import</span> std.digest.crc;
CRC32 dig;
dig.start();
<span class="d_psymbol">DigestType</span>!CRC32 result = dig.finish();
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".hasPeek"></a>template <a name="hasPeek"></a><span class="ddoc_psymbol">hasPeek</span>(T)</dt>
<dd>Used to check if a digest supports the <span class="d_inlinecode">peek</span> method.
 Peek has exactly the same function signatures as finish, but it doesn't reset
 the digest's internal state.
<p></p>
<b>Note:</b><br>
<ul><li>This is very useful as a template constraint (see examples)</li>
 <li>This also checks if T passes <a href="#isDigest"><span class="d_inlinecode">isDigest</span></a></li>
 </ul>

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">import</span> std.digest.crc, std.digest.md;
<span class="d_keyword">assert</span>(!<span class="d_psymbol">hasPeek</span>!(MD5));
<span class="d_keyword">assert</span>(<span class="d_psymbol">hasPeek</span>!CRC32);
</pre>
<p></p>

<pre class="d_code"><span class="d_keyword">void</span> myFunction(T)() <span class="d_keyword">if</span>(<span class="d_psymbol">hasPeek</span>!T)
{
    T dig;
    dig.start();
    <span class="d_keyword">auto</span> result = dig.peek();
}
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".digest"></a>DigestType!Hash <a name="digest"></a><span class="ddoc_psymbol">digest</span>(Hash, Range)(auto ref Range <i>range</i>) if (!isArray!Range &amp;&amp; isDigestibleRange!Range);
</dt>
<dd>This is a convenience function to calculate a hash using the template API.
 Every <a name="digest"></a><span class="ddoc_psymbol">digest</span> passing the <a href="#isDigest"><span class="d_inlinecode">isDigest</span></a> test can be used with this function.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Range range</td>
<td valign=top>an <span class="d_inlinecode">InputRange</span> with <span class="d_inlinecode">ElementType</span> <span class="d_inlinecode">ubyte</span>, <span class="d_inlinecode">ubyte[]</span> or <span class="d_inlinecode">ubyte[num]</span></td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">import</span> std.<span class="d_psymbol">digest</span>.md;
<span class="d_keyword">auto</span> testRange = repeat!<span class="d_keyword">ubyte</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)'a', 100);
<span class="d_keyword">auto</span> md5 = <span class="d_psymbol">digest</span>!MD5(testRange);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".digest"></a>DigestType!Hash <a name="digest"></a><span class="ddoc_psymbol">digest</span>(Hash, T...)(scope const T <i>data</i>) if (allSatisfy!(isArray, typeof(<i>data</i>)));
</dt>
<dd>This overload of the <a name="digest"></a><span class="ddoc_psymbol">digest</span> function handles arrays.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>T data</td>
<td valign=top>one or more arrays of any type</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">import</span> std.<span class="d_psymbol">digest</span>.md, std.<span class="d_psymbol">digest</span>.sha, std.<span class="d_psymbol">digest</span>.crc;
<span class="d_keyword">auto</span> md5   = <span class="d_psymbol">digest</span>!MD5(  <span class="d_string">"The quick brown fox jumps over the lazy dog"</span>);
<span class="d_keyword">auto</span> sha1  = <span class="d_psymbol">digest</span>!SHA1( <span class="d_string">"The quick brown fox jumps over the lazy dog"</span>);
<span class="d_keyword">auto</span> crc32 = <span class="d_psymbol">digest</span>!CRC32(<span class="d_string">"The quick brown fox jumps over the lazy dog"</span>);
<span class="d_keyword">assert</span>(toHexString(crc32) == <span class="d_string">"39A34F41"</span>);
</pre>
<p></p>

<pre class="d_code"><span class="d_comment">//It's also possible to pass multiple values to this function:
</span><span class="d_keyword">import</span> std.<span class="d_psymbol">digest</span>.crc;
<span class="d_keyword">auto</span> crc32 = <span class="d_psymbol">digest</span>!CRC32(<span class="d_string">"The quick "</span>, <span class="d_string">"brown "</span>, <span class="d_string">"fox jumps over the lazy dog"</span>);
<span class="d_keyword">assert</span>(toHexString(crc32) == <span class="d_string">"39A34F41"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".hexDigest"></a>char[digestLength!Hash * 2] <a name="hexDigest"></a><span class="ddoc_psymbol">hexDigest</span>(Hash, Order order = Order.increasing, Range)(ref Range <i>range</i>) if (!isArray!Range &amp;&amp; isDigestibleRange!Range);
</dt>
<dd>This is a convenience function similar to <a href="#digest"><span class="d_inlinecode">digest</span></a>, but it returns the string
 representation of the hash. Every digest passing the <a href="#isDigest"><span class="d_inlinecode">isDigest</span></a> test can be used with this
 function.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>order</td>
<td valign=top>the order in which the bytes are processed (see <a href="#toHexString"><span class="d_inlinecode">toHexString</span></a>)</td></tr>
<tr><td valign=top>Range range</td>
<td valign=top>an <span class="d_inlinecode">InputRange</span> with <span class="d_inlinecode">ElementType</span> <span class="d_inlinecode">ubyte</span>, <span class="d_inlinecode">ubyte[]</span> or <span class="d_inlinecode">ubyte[num]</span></td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">import</span> std.digest.md;
<span class="d_keyword">auto</span> testRange = repeat!<span class="d_keyword">ubyte</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)'a', 100);
<span class="d_keyword">assert</span>(<span class="d_psymbol">hexDigest</span>!MD5(testRange) == <span class="d_string">"36A92CC94A9E0FA21F625F8BFB007ADF"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".hexDigest"></a>char[digestLength!Hash * 2] <a name="hexDigest"></a><span class="ddoc_psymbol">hexDigest</span>(Hash, Order order = Order.increasing, T...)(scope const T <i>data</i>) if (allSatisfy!(isArray, typeof(<i>data</i>)));
</dt>
<dd>This overload of the <a name="hexDigest"></a><span class="ddoc_psymbol">hexDigest</span> function handles arrays.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>order</td>
<td valign=top>the order in which the bytes are processed (see <a href="#toHexString"><span class="d_inlinecode">toHexString</span></a>)</td></tr>
<tr><td valign=top>T data</td>
<td valign=top>one or more arrays of any type</td></tr>
</table><p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">import</span> std.digest.crc;
<span class="d_keyword">assert</span>(<span class="d_psymbol">hexDigest</span>!(CRC32, Order.decreasing)(<span class="d_string">"The quick brown fox jumps over the lazy dog"</span>) == <span class="d_string">"414FA339"</span>);
</pre>
<p></p>

<pre class="d_code"><span class="d_comment">//It's also possible to pass multiple values to this function:
</span><span class="d_keyword">import</span> std.digest.crc;
<span class="d_keyword">assert</span>(<span class="d_psymbol">hexDigest</span>!(CRC32, Order.decreasing)(<span class="d_string">"The quick "</span>, <span class="d_string">"brown "</span>, <span class="d_string">"fox jumps over the lazy dog"</span>) == <span class="d_string">"414FA339"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".makeDigest"></a>Hash <a name="makeDigest"></a><span class="ddoc_psymbol">makeDigest</span>(Hash)();
</dt>
<dd>This is a convenience function which returns an initialized digest, so it's not necessary to call
 start manually.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">import</span> std.digest.md;
<span class="d_keyword">auto</span> md5 = <span class="d_psymbol">makeDigest</span>!MD5();
md5.put(<span class="d_string">"Hello"</span>);
<span class="d_keyword">assert</span>(toHexString(md5.finish()) == <span class="d_string">"93B885ADFE0DA089CDF634904FD59F71"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".Digest"></a>interface <a name="Digest"></a><span class="ddoc_psymbol">Digest</span>;
</dt>
<dd>This describes the OOP API. To understand when to use the template API and when to use the OOP API,
 see the module documentation at the top of this page.
<p></p>
The <a name="Digest"></a><span class="ddoc_psymbol">Digest</span> interface is the base interface which is implemented by all digests.

<p></p>
<b>Note:</b><br>
A <a name="Digest"></a><span class="ddoc_psymbol">Digest</span> implementation is always an <span class="d_inlinecode">OutputRange</span>

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_comment">//Using the OutputRange feature
</span><span class="d_keyword">import</span> std.algorithm : copy;
<span class="d_keyword">import</span> std.range : repeat;
<span class="d_keyword">import</span> std.digest.md;

<span class="d_keyword">auto</span> oneMillionRange = repeat!<span class="d_keyword">ubyte</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)'a', 1000000);
<span class="d_keyword">auto</span> ctx = <span class="d_keyword">new</span> MD5Digest();
copy(oneMillionRange, ctx);
<span class="d_keyword">assert</span>(ctx.finish().toHexString() == <span class="d_string">"7707D6AE4E027C70EEA2A935C2296F21"</span>);
</pre>
<p></p>

<dl><dt class="d_decl"><a name=".Digest.put"></a>abstract nothrow @trusted void <a name="put"></a><span class="ddoc_psymbol">put</span>(scope const(ubyte)[] <i>data</i>...);
</dt>
<dd>Use this to feed the digest with <i>data</i>.
 Also implements the <a href="std_range.html#OutputRange"><span class="d_inlinecode">std.range.OutputRange</span></a> interface for <span class="d_inlinecode">ubyte</span> and
 <span class="d_inlinecode">const(ubyte)[]</span>.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">void</span> test(Digest dig)
{
    dig.<span class="d_psymbol">put</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)0); <span class="d_comment">//single ubyte
</span>    dig.<span class="d_psymbol">put</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)0, <span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)0); <span class="d_comment">//variadic
</span>    <span class="d_keyword">ubyte</span>[10] buf;
    dig.<span class="d_psymbol">put</span>(buf); <span class="d_comment">//buffer
</span>}
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".Digest.reset"></a>abstract nothrow @trusted void <a name="reset"></a><span class="ddoc_psymbol">reset</span>();
</dt>
<dd>Resets the internal state of the digest.
<p></p>
<b>Note:</b><br>
<a href="#finish"><span class="d_inlinecode">finish</span></a> calls this internally, so it's not necessary to call
 <span class="d_inlinecode"><a name="reset"></a><span class="ddoc_psymbol">reset</span></span> manually after a call to <a href="#finish"><span class="d_inlinecode">finish</span></a>.<p></p>

</dd>
<dt class="d_decl"><a name=".Digest.length"></a>abstract const nothrow @property @trusted size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd>This is the <a name="length"></a><span class="ddoc_psymbol">length</span> in bytes of the hash value which is returned by <a href="#finish"><span class="d_inlinecode">finish</span></a>.
 It's also the required size of a buffer passed to <a href="#finish"><span class="d_inlinecode">finish</span></a>.<p></p>

</dd>
<dt class="d_decl"><a name=".Digest.finish"></a>abstract nothrow @trusted ubyte[] <a name="finish"></a><span class="ddoc_psymbol">finish</span>();
<br><a name=".Digest.finish"></a>abstract nothrow ubyte[] <a name="finish"></a><span class="ddoc_psymbol">finish</span>(scope ubyte[] <i>buf</i>);
</dt>
<dd>The <a name="finish"></a><span class="ddoc_psymbol">finish</span> function returns the hash value. It takes an optional buffer to copy the data
 into. If a buffer is passed, it must be at least <a href="#length"><span class="d_inlinecode">length</span></a> bytes big.<p></p>

</dd>
<dt class="d_decl"><a name=".Digest.digest"></a>final nothrow @trusted ubyte[] <a name="digest"></a><span class="ddoc_psymbol">digest</span>(scope const(void[])[] <i>data</i>...);
</dt>
<dd>This is a convenience function to calculate the hash of a value using the OOP API.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">import</span> std.<span class="d_psymbol">digest</span>.md, std.<span class="d_psymbol">digest</span>.sha, std.<span class="d_psymbol">digest</span>.crc;
<span class="d_keyword">ubyte</span>[] md5   = (<span class="d_keyword">new</span> MD5Digest()).<span class="d_psymbol">digest</span>(<span class="d_string">"The quick brown fox jumps over the lazy dog"</span>);
<span class="d_keyword">ubyte</span>[] sha1  = (<span class="d_keyword">new</span> SHA1Digest()).<span class="d_psymbol">digest</span>(<span class="d_string">"The quick brown fox jumps over the lazy dog"</span>);
<span class="d_keyword">ubyte</span>[] crc32 = (<span class="d_keyword">new</span> CRC32Digest()).<span class="d_psymbol">digest</span>(<span class="d_string">"The quick brown fox jumps over the lazy dog"</span>);
<span class="d_keyword">assert</span>(crcHexString(crc32) == <span class="d_string">"414FA339"</span>);
</pre>
<p></p>

<pre class="d_code"><span class="d_comment">//It's also possible to pass multiple values to this function:
</span><span class="d_keyword">import</span> std.<span class="d_psymbol">digest</span>.crc;
<span class="d_keyword">ubyte</span>[] crc32 = (<span class="d_keyword">new</span> CRC32Digest()).<span class="d_psymbol">digest</span>(<span class="d_string">"The quick "</span>, <span class="d_string">"brown "</span>, <span class="d_string">"fox jumps over the lazy dog"</span>);
<span class="d_keyword">assert</span>(crcHexString(crc32) == <span class="d_string">"414FA339"</span>);
</pre>
<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Order"></a>enum <a name="Order"></a><span class="ddoc_psymbol">Order</span>: bool;
</dt>
<dd>See <a href="#toHexString"><span class="d_inlinecode">toHexString</span></a><p></p>

<dl><dt class="d_decl"><a name=".Order.increasing"></a><a name="increasing"></a><span class="ddoc_psymbol">increasing</span></dt>
<dd><p></p>
</dd>
<dt class="d_decl"><a name=".Order.decreasing"></a><a name="decreasing"></a><span class="ddoc_psymbol">decreasing</span></dt>
<dd><p></p>
</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".toHexString"></a>char[num * 2] <a name="toHexString"></a><span class="ddoc_psymbol">toHexString</span>(Order order = Order.increasing, size_t num, LetterCase letterCase = LetterCase.upper)(in ubyte[num] <i>digest</i>);
<br><a name=".toHexString"></a>auto <a name="toHexString"></a><span class="ddoc_psymbol">toHexString</span>(LetterCase letterCase, Order order = Order.increasing, size_t num)(in ubyte[num] <i>digest</i>);
<br><a name=".toHexString"></a>string <a name="toHexString"></a><span class="ddoc_psymbol">toHexString</span>(Order order = Order.increasing, LetterCase letterCase = LetterCase.upper)(in ubyte[] <i>digest</i>);
<br><a name=".toHexString"></a>auto <a name="toHexString"></a><span class="ddoc_psymbol">toHexString</span>(LetterCase letterCase, Order order = Order.increasing)(in ubyte[] <i>digest</i>);
</dt>
<dd>Used to convert a hash value (a static or dynamic array of ubytes) to a string.
 Can be used with the OOP and with the template API.
<p></p>
The additional order parameter can be used to specify the order of the input data.
 By default the data is processed in increasing order, starting at index 0. To process it in the
 opposite order, pass Order.decreasing as a parameter.
<p></p>

 The additional letterCase parameter can be used to specify the case of the output data.
 By default the output is in upper case. To change it to the lower case
 pass LetterCase.lower as a parameter.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_comment">//With template API:
</span><span class="d_keyword">auto</span> crc32 = digest!CRC32(<span class="d_string">"The quick "</span>, <span class="d_string">"brown "</span>, <span class="d_string">"fox jumps over the lazy dog"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">toHexString</span>(crc32) == <span class="d_string">"39A34F41"</span>);
</pre>
<p></p>

<pre class="d_code"><span class="d_comment">//Lower case variant:
</span><span class="d_keyword">auto</span> crc32 = digest!CRC32(<span class="d_string">"The quick "</span>, <span class="d_string">"brown "</span>, <span class="d_string">"fox jumps over the lazy dog"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">toHexString</span>!(LetterCase.lower)(crc32) == <span class="d_string">"39a34f41"</span>);
</pre>
<p></p>

<pre class="d_code"><span class="d_comment">//Usually CRCs are printed in this order, though:
</span><span class="d_keyword">auto</span> crc32 = digest!CRC32(<span class="d_string">"The quick "</span>, <span class="d_string">"brown "</span>, <span class="d_string">"fox jumps over the lazy dog"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">toHexString</span>!(Order.decreasing)(crc32) == <span class="d_string">"414FA339"</span>);
</pre>
<p></p>

<pre class="d_code"><span class="d_comment">//With OOP API:
</span><span class="d_keyword">auto</span> crc32 = (<span class="d_keyword">new</span> CRC32Digest()).digest(<span class="d_string">"The quick "</span>, <span class="d_string">"brown "</span>, <span class="d_string">"fox jumps over the lazy dog"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">toHexString</span>(crc32) == <span class="d_string">"39A34F41"</span>);
</pre>
<p></p>

<pre class="d_code"><span class="d_comment">//Usually CRCs are printed in this order, though:
</span><span class="d_keyword">auto</span> crc32 = (<span class="d_keyword">new</span> CRC32Digest()).digest(<span class="d_string">"The quick "</span>, <span class="d_string">"brown "</span>, <span class="d_string">"fox jumps over the lazy dog"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">toHexString</span>!(Order.decreasing)(crc32) == <span class="d_string">"414FA339"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".digestLength"></a>template <a name="digestLength"></a><span class="ddoc_psymbol">digestLength</span>(T) if (isDigest!T)</dt>
<dd>This helper is used internally in the WrapperDigest template, but it might be
 useful for other purposes as well. It returns the length (in bytes) of the hash value
 produced by T.<p></p>

</dd>
<dt class="d_decl"><a name=".WrapperDigest"></a>class <a name="WrapperDigest"></a><span class="ddoc_psymbol">WrapperDigest</span>(T) if (isDigest!T): Digest;
</dt>
<dd>Wraps a template API hash struct into a Digest interface.
 Modules providing digest implementations will usually provide
 an alias for this template (e.g. MD5Digest, SHA1Digest, ...).<p></p>

<dl><dt class="d_decl"><a name=".this"></a> this();
</dt>
<dd>Initializes the digest.<p></p>

</dd>
<dt class="d_decl"><a name=".put"></a>void <a name="put"></a><span class="ddoc_psymbol">put</span>(scope const(ubyte)[] <i>data</i>...);
</dt>
<dd>Use this to feed the digest with <i>data</i>.
 Also implements the <a href="std_range.html#OutputRange"><span class="d_inlinecode">std.range.OutputRange</span></a> interface for <span class="d_inlinecode">ubyte</span> and
 <span class="d_inlinecode">const(ubyte)[]</span>.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">void</span> test(Digest dig)
{
    dig.<span class="d_psymbol">put</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)0); <span class="d_comment">//single ubyte
</span>    dig.<span class="d_psymbol">put</span>(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)0, <span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)0); <span class="d_comment">//variadic
</span>    <span class="d_keyword">ubyte</span>[10] buf;
    dig.<span class="d_psymbol">put</span>(buf); <span class="d_comment">//buffer
</span>}
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".reset"></a>void <a name="reset"></a><span class="ddoc_psymbol">reset</span>();
</dt>
<dd>Resets the internal state of the digest.
<p></p>
<b>Note:</b><br>
<a href="#finish"><span class="d_inlinecode">finish</span></a> calls this internally, so it's not necessary to call
 <span class="d_inlinecode"><a name="reset"></a><span class="ddoc_psymbol">reset</span></span> manually after a call to <a href="#finish"><span class="d_inlinecode">finish</span></a>.<p></p>

</dd>
<dt class="d_decl"><a name=".length"></a>const pure size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd>This is the <a name="length"></a><span class="ddoc_psymbol">length</span> in bytes of the hash value which is returned by <a href="#finish"><span class="d_inlinecode">finish</span></a>.
 It's also the required size of a buffer passed to <a href="#finish"><span class="d_inlinecode">finish</span></a>.<p></p>

</dd>
<dt class="d_decl"><a name=".finish"></a>ubyte[] <a name="finish"></a><span class="ddoc_psymbol">finish</span>(scope ubyte[] <i>buf</i>);
<br><a name=".finish"></a>ubyte[] <a name="finish"></a><span class="ddoc_psymbol">finish</span>();
</dt>
<dd>The <a name="finish"></a><span class="ddoc_psymbol">finish</span> function returns the hash value. It takes an optional buffer to copy the data
 into. If a buffer is passed, it must have a length at least <a href="#length"><span class="d_inlinecode">length</span></a> bytes.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_comment">//Simple example
</span><span class="d_keyword">import</span> std.digest.md;
<span class="d_keyword">auto</span> hash = <span class="d_keyword">new</span> WrapperDigest!MD5();
hash.put(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)0);
<span class="d_keyword">auto</span> result = hash.<span class="d_psymbol">finish</span>();
</pre>
<p></p>

<pre class="d_code"><span class="d_comment">//using a supplied buffer
</span><span class="d_keyword">import</span> std.digest.md;
<span class="d_keyword">ubyte</span>[16] <span class="d_param">buf</span>;
<span class="d_keyword">auto</span> hash = <span class="d_keyword">new</span> WrapperDigest!MD5();
hash.put(<span class="d_keyword">cast</span>(<span class="d_keyword">ubyte</span>)0);
<span class="d_keyword">auto</span> result = hash.<span class="d_psymbol">finish</span>(<span class="d_param">buf</span>[]);
<span class="d_comment">//The result is now in result (and in buf). If you pass a buffer which is bigger than
</span><span class="d_comment">//necessary, result will have the correct length, but buf will still have it's original
</span><span class="d_comment">//length
</span></pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".peek"></a>const ubyte[] <a name="peek"></a><span class="ddoc_psymbol">peek</span>(scope ubyte[] <i>buf</i>);
<br><a name=".peek"></a>const ubyte[] <a name="peek"></a><span class="ddoc_psymbol">peek</span>();
</dt>
<dd>Works like <span class="d_inlinecode">finish</span> but does not reset the internal state, so it's possible
 to continue putting data into this WrapperDigest after a call to <a name="peek"></a><span class="ddoc_psymbol">peek</span>.
<p></p>
These functions are only available if <span class="d_inlinecode">hasPeek!T</span> is <b>true</b>.<p></p>

</dd>
</dl>
</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div><!--/content-->


<div id="copyright">
Copyright &copy; 1999-2013 by Digital Mars, All Rights Reserved
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

