
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
	Copyright (c) 1999-2013 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Programming in D for C++ Programmers - D Programming Language</title>
<link rel="stylesheet" href="css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="css/style.css" />
<link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="/js/codemirror.js"></script>
<script src="/js/run-main-website.js" type="text/javascript"></script>
<script src="/js/d.js"></script>
<script src="/js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function bodyLoad()
{
	var links = document.getElementById("navigation").getElementsByTagName("a");
	for (var i = 0; i < links.length; i++)
	{
		var url = "/" + links[i].getAttribute("href");
		if (window.location.href.match(url + "\x24") == url)
		{
			var cls = links[i].getAttribute("class");
			links[i].setAttribute("class", cls ? cls + " active" : "active");
			break;
		}
	}
}
</script>
</head>

<body onLoad='bodyLoad()'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="/images/search-left.gif" width="11" height="22" /><input id="q" name="q" /><input type="image" id="search-submit" name="submit" src="/images/search-button.gif" />
			<input type="hidden" id="domains" name="domains" value="dlang.org" />
			<input type="hidden" id="sourceid" name="sourceid" value="google-search" />
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a id="d-language" href="/">
		<img id="logo" width="125" height="95" border="0" alt="D Logo" src="/images/dlogo.png">
		D Programming Language</a>
	</div>
</div>

<!--Generated by Ddoc from cpptod.dd-->



<div id="navigation">
  

<div class="navblock">
<h2><a href="index.html" title="D Programming Language">D </a></h2>
<ul>	<li><a href="overview.html" title="D language overview">Overview</a>

    <div class="navblock">
<ul>	<li><a href="wc.html" title="wc - the wordcount program">Example: wc</a></li>
	<li><a href="warnings.html" title="Explanation of D compiler generated warning messages">Warnings</a></li>
	<li><a href="builtin.html">   Rationale for Builtins</a></li>
	<li><a href="ctod.html">      Converting C to D</a></li>
	<li><a href="cpptod.html">    Converting C++ to D</a></li>
	<li><a href="pretod.html">The C Preprocessor vs D</a></li>
	
	
	
	
</ul>
</div>
</li>

	<li><a href="comparison.html" title="D feature list">Features</a></li>

	<li><a href="download.html" title="Download a D compiler">Downloads &amp; Tools</a></li>

	<li><a href="changelog.html" title="History of changes to D">Change Log</a></li>
	<li><a href="bugstats.php" title="D issue and bug tracking system">Bug Tracker</a></li>
	<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>

	<li><a href="appendices.html">Appendices</a></li>
	<li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgments</a></li>
	<li><a href="sitemap.html" title="Documents on this site, indexed alphabetically">Sitemap</a></li>
	<li><a href="http://digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
</ul>
    </div>


<div class="navblock">
<h2>Documentation</h2>
<ul>    <li><a href="http://www.amazon.com/exec/obidos/ASIN/0321635361/classicempire">Book</a>
</li>
	<li><a href="http://www.informit.com/articles/article.aspx?p=1381876">&nbsp;<font size=-1><span style="visibility: hidden">3</span>1.&nbsp;Tutorial</font></a></li>
	<li><a href="http://www.informit.com/articles/article.aspx?p=1609144">&nbsp;<font size=-1>13.&nbsp;Concurrency</font></a></li>

	<li><a href="language-reference.html">Language Reference</a></li>
	<li><a href="phobos/index.html">Library Reference</a></li>
	<li><a href="howtos.html" title="Helps for using D">How-tos</a></li>

	<li><a href="articles.html">Articles</a></li>
</ul>
    </div>


<div class="navblock">
<h2><a href="http://rainers.github.io/visuald/visuald/StartPage.html
">Visual D</a></h2>
<ul></ul>
    </div>


<div class="navblock">
<h2>Community</h2>
<ul>	<li><a href="http://forum.dlang.org/" title="User forums">Forums</a></li>
	<li><a href="http://github.com/D-Programming-Language" title="D on github">GitHub</a></li>
	<li><a href="http://wiki.dlang.org" title="Wiki for the D Programming Language">Wiki</a></li>
	<li><a href="http://wiki.dlang.org/Review_Queue" title="Queue of current and upcoming standard library additions">Review Queue</a></li>
	<li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
	<li><a href="http://digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
	
</ul>
    </div>


  
<div id="translate" class="tool">Translate this page:
	<div id="google_translate_element"></div><script type="text/javascript">
	function googleTranslateElementInit() {
	  new google.translate.TranslateElement({
	    pageLanguage: 'en',
	    autoDisplay: false,
	    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
	  }, 'google_translate_element');
	}
	</script>
<script type="text/javascript" src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</div>

</div><!--/navigation-->
<div id="content" class='hyphenate'>
  
<div id="tools">
	<!--span id="lastupdate">Last update Sun Sep 22 15:36:56 2013

</span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/dlang.org/edit/master/cpptod.dd" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/CPPtoD" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>

  <h1>Programming in D for C++ Programmers</h1>
  
<!--img src="images/cpp1.gif" border=0 align=right alt="C++"-->

<p>Every experienced C++ programmer accumulates a series of idioms and techniques
which become second nature. Sometimes, when learning a new language, those
idioms can be so comfortable it's hard to see how to do the equivalent in the
new language. So here's a collection of common C++ techniques, and how to do the
corresponding task in D.</p>

See also: <a href="ctod.html">Programming in D for C Programmers</a>

<ul>	<li><a href="#constructors">Defining Constructors</a></li>
	<li><a href="#baseclass">Base class initialization</a></li>
	<li><a href="#structcmp">Comparing structs</a></li>
	<li><a href="#typedefs">Creating a new typedef'd type</a></li>
	<li><a href="#friends">Friends</a></li>
	<li><a href="#operatoroverloading">Operator overloading</a></li>
	<li><a href="#usingdeclaration">Namespace using declarations</a></li>
	<li><a href="#raii">RAII (Resource Acquisition Is Initialization)</a></li>
	<li><a href="#properties">Properties</a></li>
	<li><a href="#recursivetemplates">Recursive Templates</a></li>
	<li><a href="#metatemplates">Meta Templates</a></li>
	<li><a href="#typetraits">Type Traits</a></li>
</ul>


<hr><!-- -------------------------------------------- -->

<h3><a name="constructors">Defining constructors</a></h3>

<h4>The C++ Way</h4>

	Constructors have the same name as the class:

<pre class="cppcode"><span class="notranslate">class Foo
{
	Foo(int x);
};
</span></pre>

<h4>The D Way</h4>

	Constructors are defined with the this keyword:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Foo
{
	<span class="d_keyword">this</span>(<span class="d_keyword">int</span> x) { }
}
</span></pre>

	which reflects how they are used in D.

<hr><!-- -------------------------------------------- -->
<h3><a name="baseclass">Base class initialization</a></h3>

<h4>The C++ Way</h4>

	Base constructors are called using the base initializer syntax.

<pre class="cppcode"><span class="notranslate">class A { A() {... } };
class B : A
{
     B(int x)
	: A()		// call base constructor
     {	...
     }
};</span></pre>

<h4>The D Way</h4>

	The base class constructor is called with the super syntax:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A { <span class="d_keyword">this</span>() { ... } }
<span class="d_keyword">class</span> B : A
{
     <span class="d_keyword">this</span>(<span class="d_keyword">int</span> x)
     {	...
	<span class="d_keyword">super</span>();	<span class="d_comment">// call base constructor
</span>	...
     }
}
</span></pre>

	It's superior to C++ in that the base constructor call can be flexibly placed anywhere in the derived
	constructor. D can also have one constructor call another one:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A
{	<span class="d_keyword">int</span> a;
	<span class="d_keyword">int</span> b;
	<span class="d_keyword">this</span>() { a = 7; b = foo(); }
	<span class="d_keyword">this</span>(<span class="d_keyword">int</span> x)
	{
	    <span class="d_keyword">this</span>();
	    a = x;
	}
}
</span></pre>

	Members can also be initialized to constants before the constructor is ever called, so the above example is
	equivalently written as:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A
{	<span class="d_keyword">int</span> a = 7;
	<span class="d_keyword">int</span> b;
	<span class="d_keyword">this</span>() { b = foo(); }
	<span class="d_keyword">this</span>(<span class="d_keyword">int</span> x)
	{
	    <span class="d_keyword">this</span>();
	    a = x;
	}
}
</span></pre>

<hr><!-- -------------------------------------------- -->
<h3><a name="structcmp">Comparing structs</a></h3>

<h4>The C++ Way</h4>

	While C++ defines struct assignment in a simple, convenient manner:

<pre class="cppcode"><span class="notranslate">struct A x, y;
...
x = y;
</span></pre>

	it does not for struct comparisons. Hence, to compare two struct
	instances for equality:

<pre class="cppcode"><span class="notranslate">#include &lt;string.h&gt;

struct A x, y;

inline bool operator==(const A&amp; x, const A&amp; y)
{
    return (memcmp(&amp;x, &amp;y, sizeof(struct A)) == 0);
}
...
if (x == y)
    ...
</span></pre>

	<p>Note that the operator overload must be done for every struct
	needing to be compared, and the implementation of that overloaded
	operator is free of any language help with type checking.
	The C++ way has an additional problem in that just inspecting the
	(x == y) does not give a clue what is actually happening, you have
	to go and find the particular overloaded operator==() that applies
	to verify what it really does.</p>

	<p>There's a nasty bug lurking in the memcmp() implementation of operator==().
	The layout of a struct, due to alignment, can have &lsquo;holes&rsquo; in it.
	C++ does not guarantee those holes are assigned any values, and so
	two different struct instances can have the same value for each member,
	but compare different because the holes contain different garbage.</p>

	<p>To address this, the operator==() can be implemented to do a memberwise
	compare. Unfortunately, this is unreliable because (1) if a member is added
	to the struct definition one may forget to add it to operator==(), and
	(2) floating point nan values compare unequal even if their bit patterns
	match.</p>

	There just is no robust solution in C++.

<h4>The D Way</h4>

	D does it the obvious, straightforward way:

<pre class="d_code"><span class="notranslate">A x, y;
...
<span class="d_keyword">if</span> (x == y)
    ...
</span></pre>

<hr><!-- -------------------------------------------- -->
<h3><a name="typedefs">Creating a new typedef'd type</a></h3>

<h4>The C++ Way</h4>

	Typedef's in C++ are weak, that is, they really do not introduce
	a new type. The compiler doesn't distinguish between a typedef
	and its underlying type.

<pre class="cppcode"><span class="notranslate">#define HANDLE_INIT	((Handle)(-1))
typedef void *Handle;
void foo(void *);
void bar(Handle);

Handle h = HANDLE_INIT;
foo(h);			// coding bug not caught
bar(h);			// ok
</span></pre>

	The C++ solution is to create a dummy struct whose sole
	purpose is to get type checking and overloading on the new type.

<pre class="cppcode"><span class="notranslate">#define HANDLE_INIT	((void *)(-1))
struct Handle
{   void *ptr;

    // default initializer
    Handle() { ptr = HANDLE_INIT; }

    Handle(int i) { ptr = (void *)i; }

    // conversion to underlying type
    operator void*() { return ptr; }
};
void bar(Handle);

Handle h;
bar(h);
h = func();
if (h != HANDLE_INIT)
    ...
</span></pre>

<h4>The D Way</h4>

	No need for idiomatic constructions like the above. Just write:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">typedef</span> <span class="d_keyword">void</span>* Handle = <span class="d_keyword">cast</span>(<span class="d_keyword">void</span>*)-1;
<span class="d_keyword">void</span> bar(Handle);

Handle h;
bar(h);
h = func();
<span class="d_keyword">if</span> (h != Handle.init)
    ...
</span></pre>

	Note how a default initializer can be supplied for the typedef as
	a value of the underlying type.

<hr><!-- -------------------------------------------- -->
<h3><a name="friends">Friends</a></h3>

<h4>The C++ Way</h4>

	Sometimes two classes are tightly related but not by inheritance,
	but need to access each other's private members. This is done
	using <span class="notranslate"><span class="d_inlinecode donthyphenate">friend</span></span> declarations:

<pre class="cppcode"><span class="notranslate">class A
{
    private:
	int a;

    public:
	int foo(B *j);
	friend class B;
	friend int abc(A *);
};

class B
{
    private:
	int b;

    public:
	int bar(A *j);
	friend class A;
};

int A::foo(B *j) { return j-&gt;b; }
int B::bar(A *j) { return j-&gt;a; }

int abc(A *p) { return p-&gt;a; }
</span></pre>

<h4>The D Way</h4>

	In D, friend access is implicit in being a member of the same
	module. It makes sense that tightly related classes should be
	in the same module, so implicitly granting friend access to
	other module members solves the problem neatly:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">module</span> X;

<span class="d_keyword">class</span> A
{
    <span class="d_keyword">private</span>:
	<span class="d_keyword">static</span> <span class="d_keyword">int</span> a;

    <span class="d_keyword">public</span>:
	<span class="d_keyword">int</span> foo(B j) { <span class="d_keyword">return</span> j.b; }
}

<span class="d_keyword">class</span> B
{
    <span class="d_keyword">private</span>:
	<span class="d_keyword">static</span> <span class="d_keyword">int</span> b;

    <span class="d_keyword">public</span>:
	<span class="d_keyword">int</span> bar(A j) { <span class="d_keyword">return</span> j.a; }
}

<span class="d_keyword">int</span> abc(A p) { <span class="d_keyword">return</span> p.a; }
</span></pre>

	The <span class="notranslate"><span class="d_inlinecode donthyphenate">private</span></span> attribute prevents other modules from
	accessing the members.

<hr><!-- -------------------------------------------- -->
<h3><a name="operatoroverloading">Operator overloading</a></h3>

<h4>The C++ Way</h4>

	Given a struct that creates a new arithmetic data type,
	it's convenient to overload the comparison operators so
	it can be compared against integers:

<pre class="cppcode"><span class="notranslate">struct A
{
	int operator &lt;  (int i);
	int operator &lt;= (int i);
	int operator &gt;  (int i);
	int operator &gt;= (int i);
};

int operator &lt;  (int i, A &a) { return a &gt;  i; }
int operator &lt;= (int i, A &a) { return a &gt;= i; }
int operator &gt;  (int i, A &a) { return a &lt;  i; }
int operator &gt;= (int i, A &a) { return a &lt;= i; }
</span></pre>

	A total of 8 functions are necessary.

<h4>The D Way</h4>

	D recognizes that the comparison operators are all fundamentally
	related to each other. So only one function is necessary:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> A
{
	<span class="d_keyword">int</span> opCmp(<span class="d_keyword">int</span> i);
}
</span></pre>

	<p>The compiler automatically interprets all the
	&lt;, &lt;=, &gt; and &gt;=
	operators in terms of the <span class="notranslate"><span class="d_inlinecode donthyphenate">cmp</span></span> function, as well
	as handling the cases where the left operand is not an
	object reference.</p>

	<p>Similar sensible rules hold for other operator overloads,
	making using operator overloading in D much less tedious and less
	error prone. Far less code needs to be written to accomplish
	the same effect.</p>

<hr><!-- -------------------------------------------- -->
<h3><a name="usingdeclaration">Namespace using declarations</a></h3>

<h4>The C++ Way</h4>

	A <i>using-declaration</i> in C++ is used to bring a name from
	a namespace scope into the current scope:

<pre class="cppcode"><span class="notranslate">namespace foo
{
    int x;
}
using foo::x;
</span></pre>

<h4>The D Way</h4>

	D uses modules instead of namespaces and #include files, and
	alias declarations take the place of using declarations:

<pre class="d_code"><span class="notranslate"><span class="d_comment">/** Module foo.d **/</span>
<span class="d_keyword">module</span> foo;
<span class="d_keyword">int</span> x;

<span class="d_comment">/** Another module **/</span>
<span class="d_keyword">import</span> foo;
<span class="d_keyword">alias</span> foo.x x;
</span></pre>

	Alias is a much more flexible than the single purpose using
	declaration. Alias can be used to rename symbols, refer to
	template members, refer to nested class types, etc.

<hr><!-- -------------------------------------------- -->
<h3><a name="raii">RAII (Resource Acquisition Is Initialization)</a></h3>

<h4>The C++ Way</h4>

	In C++, resources like memory, etc., all need to be handled
	explicitly. Since destructors automatically get called when
	leaving a scope, RAII is implemented by putting the resource
	release code into the destructor:

<pre class="cppcode"><span class="notranslate">class File
{   Handle *h;

    ~File()
    {
	h-&gt;release();
    }
};
</span></pre>

<h4>The D Way</h4>

	<p>The bulk of resource release problems are simply keeping track
	of and freeing memory. This is handled automatically in D by
	the garbage collector. The second common resources used are semaphores
	and locks, handled automatically with D's <span class="notranslate"><span class="d_inlinecode donthyphenate">synchronized</span></span>
	declarations and statements.</p>

	<p>The few RAII issues left are handled by <i>scope</i> classes.
	Scope classes get their destructors run when they go out of scope.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">scope</span> <span class="d_keyword">class</span> File
{   Handle h;

    ~<span class="d_keyword">this</span>()
    {
	h.release();
    }
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">if</span> (...)
    {   <span class="d_keyword">scope</span> f = <span class="d_keyword">new</span> File();
	...
    } <span class="d_comment">// f.~this() gets run at closing brace, even if
</span>      <span class="d_comment">// scope was exited via a thrown exception
</span>}
</span></pre>

<hr><!-- -------------------------------------------- -->
<h3><a name="properties">Properties</a></h3>

<h4>The C++ Way</h4>

	It is common practice to define a field,
	along with object-oriented
	get and set functions for it:

<pre class="cppcode"><span class="notranslate">class Abc
{
  public:
    void setProperty(int newproperty) { property = newproperty; }
    int getProperty() { return property; }

  private:
    int property;
};

Abc a;
a.setProperty(3);
int x = a.getProperty();
</span></pre>

	All this is quite a bit of typing, and it tends to make
	code unreadable by filling
	it with getProperty() and setProperty() calls.

<h4>The D Way</h4>

	Properties can be get and set using the normal field syntax,
	yet the get and set will invoke methods instead.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> Abc
{
    <span class="d_comment">// set
</span>    @property <span class="d_keyword">void</span> property(<span class="d_keyword">int</span> newproperty) { myprop = newproperty; }

    <span class="d_comment">// get
</span>    @property <span class="d_keyword">int</span> property() { <span class="d_keyword">return</span> myprop; }

  <span class="d_keyword">private</span>:
    <span class="d_keyword">int</span> myprop;
}
</span></pre>

	which is used as:

<pre class="d_code"><span class="notranslate">Abc a = <span class="d_keyword">new</span> Abc;
a.property = 3;
<span class="d_keyword">int</span> x = a.property;
</span></pre>

	Thus, in D a property is treated like it was a simple field name.
	A property can start out actually being a simple field name,
	but if later it becomes
	necessary to make getting and setting it function calls,
	no code needs to be modified other
	than the class definition.
	It obviates the wordy practice of defining get and set properties
	&lsquo;just in case&rsquo; a derived class should need to override them.
	It's also a way to have interface classes, which do not have
	data fields, behave syntactically as if they did.

<hr><!-- -------------------------------------------- -->
<h3><a name="recursivetemplates">Recursive Templates</a></h3>

<h4>The C++ Way</h4>

	An advanced use of templates is to recursively expand
	them, relying on specialization to end it. A template
	to compute a factorial would be:

<pre class="cppcode"><span class="notranslate">template&lt;int n&gt; class factorial
{
    public:
	enum { result = n * factorial&lt;n - 1&gt;::result };
};

template&lt;&gt; class factorial&lt;1&gt;
{
    public:
	enum { result = 1 };
};

void test()
{
    printf("%d\n", factorial&lt;4&gt;::result); // prints 24
}
</span></pre>

<h4>The D Way</h4>

	The D version is analogous, though a little simpler, taking
	advantage of promotion of single template members to the
	enclosing name space:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> factorial(<span class="d_keyword">int</span> n)
{
    <span class="d_keyword">enum</span> { factorial = n * .factorial!(n-1) }
}

<span class="d_keyword">template</span> factorial(<span class="d_keyword">int</span> n : 1)
{
    <span class="d_keyword">enum</span> { factorial = 1 }
}

<span class="d_keyword">void</span> test()
{
    writefln(<span class="d_string">"%d"</span>, factorial!(4));	<span class="d_comment">// prints 24
</span>}
</span></pre>

<hr><!-- -------------------------------------------- -->

<h3><a name="metatemplates">Meta Templates</a></h3>

	The problem: create a typedef for a signed integral type that is at
	least <i>nbits</i> in size.

<h4>The C++ Way</h4>

	<p>This example is simplified and adapted from one written by
	Dr. Carlo Pescio in
	<a href="http://www.eptacom.net/pubblicazioni/pub_eng/paramint.html">
	Template Metaprogramming: Make parameterized integers portable with this novel technique</a>.</p>

	<p>There is no way in C++ to do conditional compilation based
	on the result of an expression based on template parameters, so
	all control flow follows from pattern matching of the template
	argument against various explicit template specializations.
	Even worse, there is no way to do template specializations based
	on relationships like "less than or equal to", so the example
	uses a clever technique where the template is recursively expanded,
	incrementing the template value argument by one each time, until
	a specialization matches.
	If there is no match, the result is an unhelpful recursive compiler
	stack overflow or internal error, or at best a strange syntax
	error.</p>

	A preprocessor macro is also needed to make up for the lack
	of template typedefs.

<pre class="cppcode"><span class="notranslate">#include &lt;limits.h&gt;

template&lt; int nbits &gt; struct Integer
{
    typedef Integer&lt; nbits + 1 &gt; :: int_type int_type ;
} ;

struct Integer&lt; 8 &gt;
{
    typedef signed char int_type ;
} ;

struct Integer&lt; 16 &gt;
{
    typedef short int_type ;
} ;

struct Integer&lt; 32 &gt;
{
    typedef int int_type ;
} ;

struct Integer&lt; 64 &gt;
{
    typedef long long int_type ;
} ;

// If the required size is not supported, the metaprogram
// will increase the counter until an internal error is
// signaled, or INT_MAX is reached. The INT_MAX
// specialization does not define a int_type, so a
// compiling error is always generated
struct Integer&lt; INT_MAX &gt;
{
} ;

// A bit of syntactic sugar
#define Integer( nbits ) Integer&lt; nbits &gt; :: int_type

#include &lt;stdio.h&gt;

int main()
{
    Integer( 8 ) i ;
    Integer( 16 ) j ;
    Integer( 29 ) k ;
    Integer( 64 ) l ;
    printf("%d %d %d %d\n",
	sizeof(i), sizeof(j), sizeof(k), sizeof(l));
    return 0 ;
}
</span></pre>

<h4>The C++ Boost Way</h4>

	This version uses the C++ Boost library. It was provided
	by David Abrahams.

<pre class="cppcode"><span class="notranslate">#include &lt;boost/mpl/if.hpp&gt;
#include &lt;boost/mpl/assert.hpp&gt;

template &lt;int nbits&gt; struct Integer
    : mpl::if_c&lt;(nbits &lt;= 8), signed char
    , mpl::if_c&lt;(nbits &lt;= 16), short
    , mpl::if_c&lt;(nbits &lt;= 32), long
    , long long&gt;::type &gt;::type &gt;
{
    BOOST_MPL_ASSERT_RELATION(nbits, &lt;=, 64);
}

#include &lt;stdio.h&gt;

int main()
{
    Integer&lt; 8 &gt; i ;
    Integer&lt; 16 &gt; j ;
    Integer&lt; 29 &gt; k ;
    Integer&lt; 64 &gt; l ;
    printf("%d %d %d %d\n",
	sizeof(i), sizeof(j), sizeof(k), sizeof(l));
    return 0 ;
}
</span></pre>

<h4>The D Way</h4>

	The D version could also be written with recursive templates,
	but there's a better way.
	Unlike the C++ example, this one is fairly easy to
	figure out what is going on.
	It compiles quickly, and gives a sensible compile time message
	if it fails.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">template</span> Integer(<span class="d_keyword">int</span> nbits)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> (nbits &lt;= 8)
	<span class="d_keyword">alias</span> <span class="d_keyword">byte</span> Integer;
    <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (nbits &lt;= 16)
	<span class="d_keyword">alias</span> <span class="d_keyword">short</span> Integer;
    <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (nbits &lt;= 32)
	<span class="d_keyword">alias</span> <span class="d_keyword">int</span> Integer;
    <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (nbits &lt;= 64)
	<span class="d_keyword">alias</span> <span class="d_keyword">long</span> Integer;
    <span class="d_keyword">else</span>
	<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(0);
}

<span class="d_keyword">int</span> main()
{
    Integer!(8) i ;
    Integer!(16) j ;
    Integer!(29) k ;
    Integer!(64) l ;
    writefln(<span class="d_string">"%d %d %d %d"</span>,
	i.sizeof, j.sizeof, k.sizeof, l.sizeof);
    <span class="d_keyword">return</span> 0;
}
</span></pre>

<hr><!-- -------------------------------------------- -->

<h3><a name="typetraits">Type Traits</a></h3>

	Type traits are another term for being able to find out
	properties of a type at compile time.

<h4>The C++ Way</h4>

	The following template comes from
	<a href="http://www.amazon.com/exec/obidos/ASIN/0201734842/ref=ase_classicempire/102-2957199-2585768">
	C++ Templates: The Complete Guide, David Vandevoorde, Nicolai M. Josuttis</a>
	pg. 353 which determines if the template's argument type
	is a function:

<pre class="cppcode"><span class="notranslate">template&lt;typename T&gt; class IsFunctionT
{
    private:
	typedef char One;
	typedef struct { char a[2]; } Two;
	template&lt;typename U&gt; static One test(...);
	template&lt;typename U&gt; static Two test(U (*)[1]);
    public:
	enum { Yes = sizeof(IsFunctionT&lt;T&gt;::test&lt;T&gt;(0)) == 1 };
};

void test()
{
    typedef int (fp)(int);

    assert(IsFunctionT&lt;fp&gt;::Yes == 1);
}
</span></pre>

	This template relies on the <a href="glossary.html#sfinae"><acronym title="Substitution Failure Is Not An Error">SFINAE</acronym> (Substitution Failure Is Not An Error)</a> principle.
	Why it works is a fairly advanced template topic.

<h4>The D Way</h4>

	<acronym title="Substitution Failure Is Not An Error">SFINAE</acronym> (Substitution Failure Is Not An Error)
	can be done in D without resorting to template argument
	pattern matching:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">template</span> IsFunctionT(T)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> ( <span class="d_keyword">is</span>(T[]) )
	<span class="d_keyword">const</span> <span class="d_keyword">int</span> IsFunctionT = 0;
    <span class="d_keyword">else</span>
	<span class="d_keyword">const</span> <span class="d_keyword">int</span> IsFunctionT = 1;
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">typedef</span> <span class="d_keyword">int</span> fp(<span class="d_keyword">int</span>);

    <span class="d_keyword">assert</span>(IsFunctionT!(fp) == 1);
}
</span></pre>

	The task of discovering if a type is a function doesn't need a
	template at all, nor does it need the subterfuge of attempting to
	create the invalid array of functions type.
	The <a href="expression.html#IsExpression"><i>IsExpression</i></a> expression can test it directly:

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">alias</span> <span class="d_keyword">int</span> fp(<span class="d_keyword">int</span>);

    <span class="d_keyword">assert</span>( <span class="d_keyword">is</span>(fp == <span class="d_keyword">function</span>) );
}
</span></pre>



  
<div id="google_ad">
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>

</div><!--/content-->





<div id="footernav">
<a href="http://forum.dlang.org/" title="User Forums">Forums</a> |
<a href="http://wiki.dlang.org/DocComments/CPPtoD" title="Read/write comments and feedback">Comments</a> |
<a href="http://digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="download.html" title="Download D">Downloads</a> |
<a href="/">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2013 by Digital Mars &reg;, All Rights Reserved
 |
Page generated by <a href="ddoc.html">Ddoc</a> on Sun Sep 22 15:36:56 2013


</div>

</body>
</html>

