<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>core.time</title>
        </head><body>
        <h1>core.time</h1>
        <!-- Generated by Ddoc from src\core\time.d -->
Module containing core <u>time</u> functionality, such as Duration (which
    represents a duration of <u>time</u>).
<br><br>
Various functions take a string (or strings) to represent a unit of <u>time</u>
    (e.g. ). The valid strings to use
    with such functions are "years", "months", "weeks", "days", "hours",
    "minutes", "seconds", "msecs" (milliseconds), "usecs" (microseconds),
    "hnsecs" (hecto-nanoseconds - i.e. 100 ns) or some subset thereof. There
    are a few functions that also allow "nsecs", but very little actually
    has precision greater than hnsecs.

<br><br>
<b>License:</b><br>
.
<br><br>
<b>Authors:</b><br>
Jonathan M Davis and Kato Shoichi
<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big><a name="Duration"></a>struct <u>Duration</u>;
</big></dt>
<dd>Represents a duration of time of weeks or less (kept internally as hnsecs).
    (e.g. 22 days or 700 seconds).
<br><br>
It is used when representing a duration of time - such as how long to
    sleep with .
<br><br>

    In std.datetime, it is also used as the result of various arithmetic
    operations on time points.
<br><br>

    Use the  function or on of its non-generic aliases to create
    s.
<br><br>

    It's not possible to create a <u>Duration</u> of months or years, because the
    variable number of days in a month or year makes it impossible to convert
    between months or years and smaller units without a specific date. So,
    nothing uses s when dealing with months or years. Rather,
    functions specific to months and years are defined. For instance,
     has  and  for adding
    years and months rather than creating a <u>Duration</u> of years or months and
    adding that to a . But <u>Duration</u> is used when dealing
    with weeks or smaller.

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"days"</font>(12) == <u>Duration</u>(10_368_000_000_000L));
<font color=blue>assert</font>(dur!<font color=red>"hnsecs"</font>(27) == <u>Duration</u>(27));
<font color=blue>assert</font>(std.datetime.Date(2010, 9, 7) + dur!<font color=red>"days"</font>(5) ==
       std.datetime.Date(2010, 9, 12));

<font color=blue>assert</font>(days(-12) == <u>Duration</u>(-10_368_000_000_000L));
<font color=blue>assert</font>(hnsecs(-27) == <u>Duration</u>(-27));
<font color=blue>assert</font>(std.datetime.Date(2010, 9, 7) - std.datetime.Date(2010, 10, 3) ==
       days(-26));
</pre>
<br><br>

<dl><dt><big><a name="Duration.zero"></a>static pure nothrow @property @safe Duration <u>zero</u>();
</big></dt>
<dd>A  of . It's shorter than doing something like
         and more explicit than .<br><br>

</dd>
<dt><big><a name="Duration.max"></a>static pure nothrow @property @safe Duration <u>max</u>();
</big></dt>
<dd>Largest  possible.<br><br>

</dd>
<dt><big><a name="Duration.min"></a>static pure nothrow @property @safe Duration <u>min</u>();
</big></dt>
<dd>Most negative  possible.<br><br>

</dd>
<dt><big><a name="Duration.opCmp"></a>const pure nothrow @safe int <u>opCmp</u>(Duration <i>rhs</i>);
</big></dt>
<dd>Compares this  with the given .
<br><br>
<b>Returns:</b><br>
<table>           <tr><td>this &lt; <i>rhs</i></td> <td>&lt; 0</td></tr>
            <tr><td>this == <i>rhs</i></td> <td>0</td></tr>
            <tr><td>this &gt; <i>rhs</i></td> <td>&gt; 0</td></tr>
            </table><br><br>

</dd>
<dt><big><a name="Duration.opBinary"></a>const pure nothrow @safe Duration <u>opBinary</u>(string op, D)(D <i>rhs</i>) if ((op == "+" || op == "-") &amp;&amp; (is(_Unqual!D == Duration) || is(_Unqual!D == TickDuration)));
</big></dt>
<dd>Adds or subtracts two durations.
<br><br>
The legal types of arithmetic for  using this operator are
<br><br>

        <table>       <tr><td>Duration</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>Duration</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>Duration</td> <td>+</td> <td>TickDuration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>Duration</td> <td>-</td> <td>TickDuration</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>D rhs</td>
<td>The duration to add to or subtract from this .</td></tr>
</table><br>

</dd>
<dt><big><a name="Duration.opBinaryRight"></a>const pure nothrow @safe Duration <u>opBinaryRight</u>(string op, D)(D <i>lhs</i>) if ((op == "+" || op == "-") &amp;&amp; is(_Unqual!D == TickDuration));
</big></dt>
<dd>Adds or subtracts two durations.
<br><br>
The legal types of arithmetic for  using this operator are
<br><br>

        <table>       <tr><td>TickDuration</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>TickDuration</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>D lhs</td>
<td>The  to add to this  or to
                  subtract this  from.</td></tr>
</table><br>

</dd>
<dt><big><a name="Duration.opOpAssign"></a>pure nothrow @safe Duration <u>opOpAssign</u>(string op, D)(in D <i>rhs</i>) if ((op == "+" || op == "-") &amp;&amp; (is(_Unqual!D == Duration) || is(_Unqual!D == TickDuration)));
</big></dt>
<dd>Adds or subtracts two durations as well as assigning the result to this
        .
<br><br>
The legal types of arithmetic for  using this operator are
<br><br>

        <table>       <tr><td>Duration</td> <td>+</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>Duration</td> <td>-</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>Duration</td> <td>+</td> <td>TickDuration</td> <td>--&gt;</td> <td>Duration</td></tr>
        <tr><td>Duration</td> <td>-</td> <td>TickDuration</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>D rhs</td>
<td>The duration to add to or subtract from this .</td></tr>
</table><br>

</dd>
<dt><big><a name="Duration.opBinary"></a>const pure nothrow @safe Duration <u>opBinary</u>(string op)(long <i>value</i>) if (op == "*");
</big></dt>
<dd>The legal types of arithmetic for  using this operator
        overload are
<br><br>
<table>       <tr><td>Duration</td> <td>*</td> <td>long</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>long value</td>
<td>The value to multiply this  by.</td></tr>
</table><br>

</dd>
<dt><big><a name="Duration.opOpAssign"></a>pure nothrow @safe Duration <u>opOpAssign</u>(string op)(long <i>value</i>) if (op == "*");
</big></dt>
<dd>The legal types of arithmetic for  using this operator
        overload are
<br><br>
<table>       <tr><td>Duration</td> <td>*</td> <td>long</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>long value</td>
<td>The value to multiply this  by.</td></tr>
</table><br>

</dd>
<dt><big><a name="Duration.opBinary"></a>const pure @safe Duration <u>opBinary</u>(string op)(long <i>value</i>) if (op == "/");
</big></dt>
<dd>The legal types of arithmetic for  using this operator
        overload are
<br><br>
<table>       <tr><td>Duration</td> <td>/</td> <td>long</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>long value</td>
<td>The value to divide from this duration.</td></tr>
</table><br>
<b>Throws:</b><br>
 if an attempt to divide by  is made.<br><br>

</dd>
<dt><big><a name="Duration.opOpAssign"></a>pure @safe Duration <u>opOpAssign</u>(string op)(long <i>value</i>) if (op == "/");
</big></dt>
<dd>The legal types of arithmetic for  using this operator
        overload are
<br><br>
<table>       <tr><td>Duration</td> <td>/</td> <td>long</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>long value</td>
<td>The value to divide from this .</td></tr>
</table><br>
<b>Throws:</b><br>
 if an attempt to divide by  is made.<br><br>

</dd>
<dt><big><a name="Duration.opBinaryRight"></a>const pure nothrow @safe Duration <u>opBinaryRight</u>(string op)(long <i>value</i>) if (op == "*");
</big></dt>
<dd>Multiplies an integral value and a .
<br><br>
The legal types of arithmetic for  using this operator
        overload are
<br><br>

        <table>       <tr><td>long</td> <td>*</td> <td>Duration</td> <td>--&gt;</td> <td>Duration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>long value</td>
<td>The number of units to multiply this  by.</td></tr>
</table><br>

</dd>
<dt><big><a name="Duration.opUnary"></a>const pure nothrow @safe Duration <u>opUnary</u>(string op)() if (op == "-");
</big></dt>
<dd>Returns the negation of this .<br><br>

</dd>
<dt><big><a name="Duration.opCast"></a>const pure nothrow @safe TickDuration <u>opCast</u>(T)() if (is(_Unqual!T == TickDuration));
</big></dt>
<dd>Returns a  with the same number of hnsecs as this
        .<br><br>

</dd>
<dt><big><a name="Duration.get"></a>const pure nothrow @safe long <u>get</u>(string units)() if (units == "weeks" || units == "days" || units == "hours" || units == "minutes" || units == "seconds");
</big></dt>
<dd>Returns the number of the given units in this 
        (minus the larger units).
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"weeks"</font>(12).<u>get</u>!<font color=red>"weeks"</font>() == 12);
<font color=blue>assert</font>(dur!<font color=red>"weeks"</font>(12).<u>get</u>!<font color=red>"days"</font>() == 0);

<font color=blue>assert</font>(dur!<font color=red>"days"</font>(13).<u>get</u>!<font color=red>"weeks"</font>() == 1);
<font color=blue>assert</font>(dur!<font color=red>"days"</font>(13).<u>get</u>!<font color=red>"days"</font>() == 6);

<font color=blue>assert</font>(dur!<font color=red>"hours"</font>(49).<u>get</u>!<font color=red>"days"</font>() == 2);
<font color=blue>assert</font>(dur!<font color=red>"hours"</font>(49).<u>get</u>!<font color=red>"hours"</font>() == 1);
</pre>
<br><br>

</dd>
<dt><big><a name="Duration.weeks"></a>const pure nothrow @property @safe long <u>weeks</u>();
</big></dt>
<dd>Returns the number of <u>weeks</u> in this 
        (minus the larger units).
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"weeks"</font>(12).<u>weeks</u> == 12);
<font color=blue>assert</font>(dur!<font color=red>"days"</font>(13).<u>weeks</u> == 1);
</pre>
<br><br>

</dd>
<dt><big><a name="Duration.days"></a>const pure nothrow @property @safe long <u>days</u>();
</big></dt>
<dd>Returns the number of <u>days</u> in this 
        (minus the larger units).
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"weeks"</font>(12).<u>days</u> == 0);
<font color=blue>assert</font>(dur!<font color=red>"days"</font>(13).<u>days</u> == 6);
<font color=blue>assert</font>(dur!<font color=red>"hours"</font>(49).<u>days</u> == 2);
</pre>
<br><br>

</dd>
<dt><big><a name="Duration.hours"></a>const pure nothrow @property @safe long <u>hours</u>();
</big></dt>
<dd>Returns the number of <u>hours</u> in this 
        (minus the larger units).
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"days"</font>(8).<u>hours</u> == 0);
<font color=blue>assert</font>(dur!<font color=red>"hours"</font>(49).<u>hours</u> == 1);
<font color=blue>assert</font>(dur!<font color=red>"minutes"</font>(121).<u>hours</u> == 2);
</pre>
<br><br>

</dd>
<dt><big><a name="Duration.minutes"></a>const pure nothrow @property @safe long <u>minutes</u>();
</big></dt>
<dd>Returns the number of <u>minutes</u> in this 
        (minus the larger units).
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"hours"</font>(47).<u>minutes</u> == 0);
<font color=blue>assert</font>(dur!<font color=red>"minutes"</font>(127).<u>minutes</u> == 7);
<font color=blue>assert</font>(dur!<font color=red>"seconds"</font>(121).<u>minutes</u> == 2);
</pre>
<br><br>

</dd>
<dt><big><a name="Duration.seconds"></a>const pure nothrow @property @safe long <u>seconds</u>();
</big></dt>
<dd>Returns the number of <u>seconds</u> in this 
        (minus the larger units).
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"minutes"</font>(47).<u>seconds</u> == 0);
<font color=blue>assert</font>(dur!<font color=red>"seconds"</font>(127).<u>seconds</u> == 7);
<font color=blue>assert</font>(dur!<font color=red>"msecs"</font>(1217).<u>seconds</u> == 1);
</pre>
<br><br>

</dd>
<dt><big><a name="Duration.fracSec"></a>const pure nothrow @property @safe FracSec <u>fracSec</u>();
</big></dt>
<dd>Returns the fractional seconds passed the second in this .
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"msecs"</font>(1000).<u>fracSec</u> == FracSec.from!<font color=red>"msecs"</font>(0));
<font color=blue>assert</font>(dur!<font color=red>"msecs"</font>(1217).<u>fracSec</u> == FracSec.from!<font color=red>"msecs"</font>(217));
<font color=blue>assert</font>(dur!<font color=red>"usecs"</font>(43).<u>fracSec</u> == FracSec.from!<font color=red>"usecs"</font>(43));
<font color=blue>assert</font>(dur!<font color=red>"hnsecs"</font>(50_007).<u>fracSec</u> == FracSec.from!<font color=red>"hnsecs"</font>(50_007));
<font color=blue>assert</font>(dur!<font color=red>"nsecs"</font>(62_127).<u>fracSec</u> == FracSec.from!<font color=red>"nsecs"</font>(62_100));

<font color=blue>assert</font>(dur!<font color=red>"msecs"</font>(-1000).<u>fracSec</u> == FracSec.from!<font color=red>"msecs"</font>(-0));
<font color=blue>assert</font>(dur!<font color=red>"msecs"</font>(-1217).<u>fracSec</u> == FracSec.from!<font color=red>"msecs"</font>(-217));
<font color=blue>assert</font>(dur!<font color=red>"usecs"</font>(-43).<u>fracSec</u> == FracSec.from!<font color=red>"usecs"</font>(-43));
<font color=blue>assert</font>(dur!<font color=red>"hnsecs"</font>(-50_007).<u>fracSec</u> == FracSec.from!<font color=red>"hnsecs"</font>(-50_007));
<font color=blue>assert</font>(dur!<font color=red>"nsecs"</font>(-62_127).<u>fracSec</u> == FracSec.from!<font color=red>"nsecs"</font>(-62_100));
</pre>
<br><br>

</dd>
<dt><big><a name="Duration.total"></a>const pure nothrow @safe long <u>total</u>(string units)() if (units == "weeks" || units == "days" || units == "hours" || units == "minutes" || units == "seconds" || units == "msecs" || units == "usecs" || units == "hnsecs" || units == "nsecs");
</big></dt>
<dd>Returns the <u>total</u> number of the given units in this .
        So, unlike , it does not strip out the larger units.
<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(dur!<font color=red>"weeks"</font>(12).<u>total</u>!<font color=red>"weeks"</font> == 12);
<font color=blue>assert</font>(dur!<font color=red>"weeks"</font>(12).<u>total</u>!<font color=red>"days"</font> == 84);

<font color=blue>assert</font>(dur!<font color=red>"days"</font>(13).<u>total</u>!<font color=red>"weeks"</font> == 1);
<font color=blue>assert</font>(dur!<font color=red>"days"</font>(13).<u>total</u>!<font color=red>"days"</font> == 13);

<font color=blue>assert</font>(dur!<font color=red>"hours"</font>(49).<u>total</u>!<font color=red>"days"</font> == 2);
<font color=blue>assert</font>(dur!<font color=red>"hours"</font>(49).<u>total</u>!<font color=red>"hours"</font> == 49);

<font color=blue>assert</font>(dur!<font color=red>"nsecs"</font>(2007).<u>total</u>!<font color=red>"hnsecs"</font> == 20);
<font color=blue>assert</font>(dur!<font color=red>"nsecs"</font>(2007).<u>total</u>!<font color=red>"nsecs"</font> == 2000);
</pre>
<br><br>

</dd>
<dt><big><a name="Duration.toString"></a>const pure nothrow @safe string <u>toString</u>();
</big></dt>
<dd>Converts this  to a .<br><br>

</dd>
<dt><big><a name="Duration.isNegative"></a>const pure nothrow @property @safe bool <u>isNegative</u>();
</big></dt>
<dd>Returns whether this  is negative.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="dur"></a>pure nothrow @safe Duration <u>dur</u>(string units)(long <i>length</i>) if (units == "weeks" || units == "days" || units == "hours" || units == "minutes" || units == "seconds" || units == "msecs" || units == "usecs" || units == "hnsecs" || units == "nsecs");
<br><a name="weeks"></a>alias <u>weeks</u> = dur!"<u>weeks</u>".dur;
<br><a name="days"></a>alias <u>days</u> = dur!"<u>days</u>".dur;
<br><a name="hours"></a>alias <u>hours</u> = dur!"<u>hours</u>".dur;
<br><a name="minutes"></a>alias <u>minutes</u> = dur!"<u>minutes</u>".dur;
<br><a name="seconds"></a>alias <u>seconds</u> = dur!"<u>seconds</u>".dur;
<br><a name="msecs"></a>alias <u>msecs</u> = dur!"<u>msecs</u>".dur;
<br><a name="usecs"></a>alias <u>usecs</u> = dur!"<u>usecs</u>".dur;
<br><a name="hnsecs"></a>alias <u>hnsecs</u> = dur!"<u>hnsecs</u>".dur;
<br><a name="nsecs"></a>alias <u>nsecs</u> = dur!"<u>nsecs</u>".dur;
</big></dt>
<dd>These allow you to construct a  from the given time units
    with the given length.
<br><br>
You can either use the generic function  and give it the units as
    a  or use the named aliases.
<br><br>

    The possible values for units are , , ,
    , ,  (milliseconds), ,
    (microseconds),  (hecto-nanoseconds, i.e. 100 ns), and
    .

<br><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=green>// Generic
</font><font color=blue>assert</font>(<u>dur</u>!<font color=red>"weeks"</font>(142).total!<font color=red>"weeks"</font> == 142);
<font color=blue>assert</font>(<u>dur</u>!<font color=red>"days"</font>(142).total!<font color=red>"days"</font> == 142);
<font color=blue>assert</font>(<u>dur</u>!<font color=red>"hours"</font>(142).total!<font color=red>"hours"</font> == 142);
<font color=blue>assert</font>(<u>dur</u>!<font color=red>"minutes"</font>(142).total!<font color=red>"minutes"</font> == 142);
<font color=blue>assert</font>(<u>dur</u>!<font color=red>"seconds"</font>(142).total!<font color=red>"seconds"</font> == 142);
<font color=blue>assert</font>(<u>dur</u>!<font color=red>"msecs"</font>(142).total!<font color=red>"msecs"</font> == 142);
<font color=blue>assert</font>(<u>dur</u>!<font color=red>"usecs"</font>(142).total!<font color=red>"usecs"</font> == 142);
<font color=blue>assert</font>(<u>dur</u>!<font color=red>"hnsecs"</font>(142).total!<font color=red>"hnsecs"</font> == 142);
<font color=blue>assert</font>(<u>dur</u>!<font color=red>"nsecs"</font>(142).total!<font color=red>"nsecs"</font> == 100);

<font color=green>// Non-generic
</font><font color=blue>assert</font>(weeks(142).total!<font color=red>"weeks"</font> == 142);
<font color=blue>assert</font>(days(142).total!<font color=red>"days"</font> == 142);
<font color=blue>assert</font>(hours(142).total!<font color=red>"hours"</font> == 142);
<font color=blue>assert</font>(minutes(142).total!<font color=red>"minutes"</font> == 142);
<font color=blue>assert</font>(seconds(142).total!<font color=red>"seconds"</font> == 142);
<font color=blue>assert</font>(msecs(142).total!<font color=red>"msecs"</font> == 142);
<font color=blue>assert</font>(usecs(142).total!<font color=red>"usecs"</font> == 142);
<font color=blue>assert</font>(hnsecs(142).total!<font color=red>"hnsecs"</font> == 142);
<font color=blue>assert</font>(nsecs(142).total!<font color=red>"nsecs"</font> == 100);
</pre>

<br><br>
<b>Params:</b><br>
<table><tr><td>units</td>
<td>The time units of the  (e.g. ).</td></tr>
<tr><td>long length</td>
<td>The number of units in the .</td></tr>
</table><br>

</dd>
<dt><big><a name="TickDuration"></a>struct <u>TickDuration</u>;
</big></dt>
<dd>Represents a duration of time in system clock ticks.
<br><br>
The system clock ticks are the ticks of the system clock at the highest
   precision that the system provides.<br><br>

<dl><dt><big><a name="TickDuration.ticksPerSec"></a>static immutable long <u>ticksPerSec</u>;
</big></dt>
<dd>The number of ticks that the system clock has in one second.
<br><br>
If  is , then then  failed to
       get the value of  on the current system, and
        is not going to work. That would be highly abnormal
       though.<br><br>

</dd>
<dt><big><a name="TickDuration.appOrigin"></a>static immutable TickDuration <u>appOrigin</u>;
</big></dt>
<dd>The tick of the system clock (as a ) when the
        application started.<br><br>

</dd>
<dt><big><a name="TickDuration.zero"></a>static pure nothrow @property @safe TickDuration <u>zero</u>();
</big></dt>
<dd>It's the same as , but it's provided to be
        consistent with  and , which provide 
        properties.<br><br>

</dd>
<dt><big><a name="TickDuration.max"></a>static pure nothrow @property @safe TickDuration <u>max</u>();
</big></dt>
<dd>Largest  possible.<br><br>

</dd>
<dt><big><a name="TickDuration.min"></a>static pure nothrow @property @safe TickDuration <u>min</u>();
</big></dt>
<dd>Most negative  possible.<br><br>

</dd>
<dt><big><a name="TickDuration.length"></a>long <u>length</u>;
</big></dt>
<dd>The number of system ticks in this .
<br><br>
You can convert this  into the number of seconds by dividing
       it by  (or using one the appropriate property function
       to do it).<br><br>

</dd>
<dt><big><a name="TickDuration.to"></a>const pure nothrow @safe T <u>to</u>(string units, T)() if ((units == "seconds" || units == "msecs" || units == "usecs" || units == "hnsecs" || units == "nsecs") &amp;&amp; (__traits(isIntegral, T) &amp;&amp; T.sizeof &gt;= 4 || __traits(isFloating, T)));
</big></dt>
<dd>Converts this  <u>to</u> the given units as either an integral
        value or a floating point value.
<br><br>
<b>Params:</b><br>
<table><tr><td>units</td>
<td>The units <u>to</u> convert <u>to</u>. Accepts  and smaller
                    only.</td></tr>
<tr><td>T</td>
<td>The type <u>to</u> convert <u>to</u> (either an integral type or a
                    floating point type).</td></tr>
</table><br>

</dd>
<dt><big><a name="TickDuration.seconds"></a>const pure nothrow @property @safe long <u>seconds</u>();
</big></dt>
<dd>Returns the total number of <u>seconds</u> in this .<br><br>

</dd>
<dt><big><a name="TickDuration.msecs"></a>const pure nothrow @property @safe long <u>msecs</u>();
</big></dt>
<dd>Returns the total number of milliseconds in this .<br><br>

</dd>
<dt><big><a name="TickDuration.usecs"></a>const pure nothrow @property @safe long <u>usecs</u>();
</big></dt>
<dd>Returns the total number of microseconds in this .<br><br>

</dd>
<dt><big><a name="TickDuration.hnsecs"></a>const pure nothrow @property @safe long <u>hnsecs</u>();
</big></dt>
<dd>Returns the total number of hecto-nanoseconds in this .<br><br>

</dd>
<dt><big><a name="TickDuration.nsecs"></a>const pure nothrow @property @safe long <u>nsecs</u>();
</big></dt>
<dd>Returns the total number of nanoseconds in this .<br><br>

</dd>
<dt><big><a name="TickDuration.from"></a>pure nothrow @safe TickDuration <u>from</u>(string units)(long <i>length</i>) if (units == "seconds" || units == "msecs" || units == "usecs" || units == "hnsecs" || units == "nsecs");
</big></dt>
<dd>This allows you to construct a  <u>from</u> the given time
        units with the given length.
<br><br>
<b>Params:</b><br>
<table><tr><td>units</td>
<td>The time units of the  (e.g. ).</td></tr>
<tr><td>long length</td>
<td>The number of units in the .</td></tr>
</table><br>

</dd>
<dt><big><a name="TickDuration.opCast"></a>const pure nothrow @safe Duration <u>opCast</u>(T)() if (is(_Unqual!T == Duration));
</big></dt>
<dd>Returns a  with the same number of hnsecs as this
        .<br><br>

</dd>
<dt><big><a name="TickDuration.opOpAssign"></a>pure nothrow @safe TickDuration <u>opOpAssign</u>(string op)(TickDuration <i>rhs</i>) if (op == "+" || op == "-");
</big></dt>
<dd>Adds or subtracts two s as well as assigning the result
        to this .
<br><br>
The legal types of arithmetic for  using this operator
        are
<br><br>

        <table>       <tr><td>TickDuration</td> <td>+=</td> <td>TickDuration</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        <tr><td>TickDuration</td> <td>-=</td> <td>TickDuration</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>TickDuration rhs</td>
<td>The  to add to or subtract from this
                  .</td></tr>
</table><br>

</dd>
<dt><big><a name="TickDuration.opBinary"></a>const pure nothrow @safe TickDuration <u>opBinary</u>(string op)(TickDuration <i>rhs</i>) if (op == "+" || op == "-");
</big></dt>
<dd>Adds or subtracts two s.
<br><br>
The legal types of arithmetic for  using this operator
        are
<br><br>

        <table>       <tr><td>TickDuration</td> <td>+</td> <td>TickDuration</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        <tr><td>TickDuration</td> <td>-</td> <td>TickDuration</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>TickDuration rhs</td>
<td>The  to add to or subtract from this
                  .</td></tr>
</table><br>

</dd>
<dt><big><a name="TickDuration.opUnary"></a>const pure nothrow @safe TickDuration <u>opUnary</u>(string op)() if (op == "-");
</big></dt>
<dd>Returns the negation of this .<br><br>

</dd>
<dt><big><a name="TickDuration.opCmp"></a>const pure nothrow @safe int <u>opCmp</u>(TickDuration <i>rhs</i>);
</big></dt>
<dd>operator overloading "&lt;, &gt;, &lt;=, &gt;="<br><br>

</dd>
<dt><big><a name="TickDuration.opOpAssign"></a>pure nothrow @safe void <u>opOpAssign</u>(string op, T)(T <i>value</i>) if (op == "*" &amp;&amp; (__traits(isIntegral, T) || __traits(isFloating, T)));
</big></dt>
<dd>The legal types of arithmetic for  using this operator
        overload are
<br><br>
<table>       <tr><td>TickDuration</td> <td>*</td> <td>long</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        <tr><td>TickDuration</td> <td>*</td> <td>floating point</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>T value</td>
<td>The value to divide from this duration.</td></tr>
</table><br>

</dd>
<dt><big><a name="TickDuration.opOpAssign"></a>pure @safe void <u>opOpAssign</u>(string op, T)(T <i>value</i>) if (op == "/" &amp;&amp; (__traits(isIntegral, T) || __traits(isFloating, T)));
</big></dt>
<dd>The legal types of arithmetic for  using this operator
        overload are
<br><br>
<table>       <tr><td>TickDuration</td> <td>/</td> <td>long</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        <tr><td>TickDuration</td> <td>/</td> <td>floating point</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>T value</td>
<td>The value to divide from this .</td></tr>
</table><br>
<b>Throws:</b><br>
 if an attempt to divide by  is made.<br><br>

</dd>
<dt><big><a name="TickDuration.opBinary"></a>const pure nothrow @safe TickDuration <u>opBinary</u>(string op, T)(T <i>value</i>) if (op == "*" &amp;&amp; (__traits(isIntegral, T) || __traits(isFloating, T)));
</big></dt>
<dd>The legal types of arithmetic for  using this operator
        overload are
<br><br>
<table>       <tr><td>TickDuration</td> <td>*</td> <td>long</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        <tr><td>TickDuration</td> <td>*</td> <td>floating point</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>T value</td>
<td>The value to divide from this .</td></tr>
</table><br>

</dd>
<dt><big><a name="TickDuration.opBinary"></a>const pure @safe TickDuration <u>opBinary</u>(string op, T)(T <i>value</i>) if (op == "/" &amp;&amp; (__traits(isIntegral, T) || __traits(isFloating, T)));
</big></dt>
<dd>The legal types of arithmetic for  using this operator
        overload are
<br><br>
<table>       <tr><td>TickDuration</td> <td>/</td> <td>long</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        <tr><td>TickDuration</td> <td>/</td> <td>floating point</td> <td>--&gt;</td> <td>TickDuration</td></tr>
        </table>

<br><br>
<b>Params:</b><br>
<table><tr><td>T value</td>
<td>The value to divide from this .</td></tr>
</table><br>
<b>Throws:</b><br>
 if an attempt to divide by  is made.<br><br>

</dd>
<dt><big><a name="TickDuration.this"></a> this(long <i>ticks</i>);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>long <i>ticks</i></td>
<td>The number of <i>ticks</i> in the TickDuration.</td></tr>
</table><br>

</dd>
<dt><big><a name="TickDuration.currSystemTick"></a>static @property @trusted TickDuration <u>currSystemTick</u>();
</big></dt>
<dd>The current system tick. The number of ticks per second varies from
        system to system.  uses a monotonic clock, so it's
        intended for precision timing by comparing relative time values, not for
        getting the current system time.
<br><br>
On Windows,  is used. On Mac OS X,
         is used, while on other Posix systems,
         is used. If  or
         is unavailable, then Posix systems use
         (the decision is made when  is
        compiled), which unfortunately, is not monotonic, but if
         and  aren't available, then
         is the the best that there is.
<br><br>

        <font color=red>Warning</font>:
            On some systems, the monotonic clock may stop counting when
            the computer goes to sleep or hibernates. So, the monotonic
            clock could be off if that occurs. This is known to happen
            on Mac OS X. It has not been tested whether it occurs on
            either Windows or on Linux.

<br><br>
<b>Throws:</b><br>
 if it fails to get the time.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="convert"></a>pure nothrow @safe long <u>convert</u>(string from, string to)(long <i>value</i>) if ((from == "weeks" || from == "days" || from == "hours" || from == "minutes" || from == "seconds" || from == "msecs" || from == "usecs" || from == "hnsecs" || from == "nsecs") &amp;&amp; (to == "weeks" || to == "days" || to == "hours" || to == "minutes" || to == "seconds" || to == "msecs" || to == "usecs" || to == "hnsecs" || to == "nsecs") || (from == "years" || from == "months") &amp;&amp; (to == "years" || to == "months"));
</big></dt>
<dd>Generic way of converting between two time units. Conversions to smaller
    units use truncating division. Years and months can be converted to each
    other, small units can be converted to each other, but years and months
    cannot be converted to or from smaller units (due to the varying number
    of days in a month or year).
<br><br>
<b>Params:</b><br>
<table><tr><td>from</td>
<td>The units of time to <u>convert</u> from.</td></tr>
<tr><td>to</td>
<td>The units of time to <u>convert</u> to.</td></tr>
<tr><td>long value</td>
<td>The value to <u>convert</u>.</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code"><font color=blue>assert</font>(<u>convert</u>!(<font color=red>"years"</font>, <font color=red>"months"</font>)(1) == 12);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"months"</font>, <font color=red>"years"</font>)(12) == 1);

<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"weeks"</font>, <font color=red>"days"</font>)(1) == 7);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"hours"</font>, <font color=red>"seconds"</font>)(1) == 3600);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"seconds"</font>, <font color=red>"days"</font>)(1) == 0);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"seconds"</font>, <font color=red>"days"</font>)(86_400) == 1);

<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"nsecs"</font>, <font color=red>"nsecs"</font>)(1) == 1);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"nsecs"</font>, <font color=red>"hnsecs"</font>)(1) == 0);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"hnsecs"</font>, <font color=red>"nsecs"</font>)(1) == 100);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"nsecs"</font>, <font color=red>"seconds"</font>)(1) == 0);
<font color=blue>assert</font>(<u>convert</u>!(<font color=red>"seconds"</font>, <font color=red>"nsecs"</font>)(1) == 1_000_000_000);
</pre>
<br><br>

</dd>
<dt><big><a name="FracSec"></a>struct <u>FracSec</u>;
</big></dt>
<dd>Represents fractional seconds.
<br><br>
This is the portion of the time which is smaller than a second and it cannot
    hold values which would be greater than or equal to a second (or less than
    or equal to a negative second).
<br><br>

    It holds hnsecs internally, but you can create it using either milliseconds,
    microseconds, or hnsecs. What it does is allow for a simple way to set or
    adjust the fractional seconds portion of a  or a
     without having to worry about whether you're
    dealing with milliseconds, microseconds, or hnsecs.
<br><br>

    's functions which take time unit strings do accept
    , but because the resolution of  and
     is hnsecs, you don't actually get precision higher
    than hnsecs.  is accepted merely for convenience. Any values
    given as nsecs will be converted to hnsecs using  (which uses
    truncating division when converting to smaller units).<br><br>

<dl><dt><big><a name="FracSec.zero"></a>static pure nothrow @property @safe FracSec <u>zero</u>();
</big></dt>
<dd>A  of . It's shorter than doing something like
         and more explicit than .<br><br>

</dd>
<dt><big><a name="FracSec.from"></a>pure @safe FracSec <u>from</u>(string units)(long <i>value</i>) if (units == "msecs" || units == "usecs" || units == "hnsecs" || units == "nsecs");
</big></dt>
<dd>Create a  <u>from</u> the given units (, ,
        or ).
<br><br>
<b>Params:</b><br>
<table><tr><td>units</td>
<td>The units to create a FracSec <u>from</u>.</td></tr>
<tr><td>long value</td>
<td>The number of the given units passed the second.</td></tr>
</table><br>
<b>Throws:</b><br>
 if the given value would result in a 
            greater than or equal to  second or less than or equal to
             seconds.<br><br>

</dd>
<dt><big><a name="FracSec.opUnary"></a>const pure nothrow @safe FracSec <u>opUnary</u>(string op)() if (op == "-");
</big></dt>
<dd>Returns the negation of this .<br><br>

</dd>
<dt><big><a name="FracSec.msecs"></a>const pure nothrow @property @safe int <u>msecs</u>();
</big></dt>
<dd>The value of this  as milliseconds.<br><br>

</dd>
<dt><big><a name="FracSec.msecs"></a>pure @property @safe void <u>msecs</u>(int <i>milliseconds</i>);
</big></dt>
<dd>The value of this  as <i>milliseconds</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>milliseconds</i></td>
<td>The number of <i>milliseconds</i> passed the second.</td></tr>
</table><br>
<b>Throws:</b><br>
 if the given value is not less than  second
            and greater than a  seconds.<br><br>

</dd>
<dt><big><a name="FracSec.usecs"></a>const pure nothrow @property @safe int <u>usecs</u>();
</big></dt>
<dd>The value of this  as microseconds.<br><br>

</dd>
<dt><big><a name="FracSec.usecs"></a>pure @property @safe void <u>usecs</u>(int <i>microseconds</i>);
</big></dt>
<dd>The value of this  as <i>microseconds</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <i>microseconds</i></td>
<td>The number of <i>microseconds</i> passed the second.</td></tr>
</table><br>
<b>Throws:</b><br>
 if the given value is not less than  second
            and greater than a  seconds.<br><br>

</dd>
<dt><big><a name="FracSec.hnsecs"></a>const pure nothrow @property @safe int <u>hnsecs</u>();
</big></dt>
<dd>The value of this  as <u>hnsecs</u>.<br><br>

</dd>
<dt><big><a name="FracSec.hnsecs"></a>pure @property @safe void <u>hnsecs</u>(int <u>hnsecs</u>);
</big></dt>
<dd>The value of this  as <u>hnsecs</u>.
<br><br>
<b>Params:</b><br>
<table><tr><td>int <u>hnsecs</u></td>
<td>The number of <u>hnsecs</u> passed the second.</td></tr>
</table><br>
<b>Throws:</b><br>
 if the given value is not less than  second
            and greater than a  seconds.<br><br>

</dd>
<dt><big><a name="FracSec.nsecs"></a>const pure nothrow @property @safe int <u>nsecs</u>();
</big></dt>
<dd>The value of this  as <u>nsecs</u>.
<br><br>
Note that this does not give you any greater precision
        than getting the value of this  as hnsecs.<br><br>

</dd>
<dt><big><a name="FracSec.nsecs"></a>pure @property @safe void <u>nsecs</u>(long <u>nsecs</u>);
</big></dt>
<dd>The value of this  as <u>nsecs</u>.
<br><br>
Note that this does not give you any greater precision
        than setting the value of this  as hnsecs.

<br><br>
<b>Params:</b><br>
<table><tr><td>long <u>nsecs</u></td>
<td>The number of <u>nsecs</u> passed the second.</td></tr>
</table><br>
<b>Throws:</b><br>
 if the given value is not less than  second
            and greater than a  seconds.<br><br>

</dd>
<dt><big><a name="FracSec.toString"></a>const pure nothrow @safe string <u>toString</u>();
</big></dt>
<dd>Converts this  to a string.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="TimeException"></a>class <u>TimeException</u>: object.Exception;
</big></dt>
<dd>Exception type used by core.time.<br><br>

<dl><dt><big><a name="TimeException.this"></a> this(string <i>msg</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null);
</big></dt>
<dd><b>Params:</b><br>
<table><tr><td>string <i>msg</i></td>
<td>The message for the exception.</td></tr>
<tr><td>string <i>file</i></td>
<td>The <i>file</i> where the exception occurred.</td></tr>
<tr><td>size_t <i>line</i></td>
<td>The <i>line</i> number where the exception occurred.</td></tr>
<tr><td>Throwable <i>next</i></td>
<td>The previous exception in the chain of exceptions, if any.</td></tr>
</table><br>

</dd>
</dl>
</dd>
<dt><big><a name="abs"></a>Duration <u>abs</u>(Duration <i>duration</i>);
<br><a name="abs"></a>TickDuration <u>abs</u>(TickDuration <i>duration</i>);
</big></dt>
<dd>Returns the absolute value of a <i>duration</i>.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright 2010 - 2012
</small>
        </body></html>
