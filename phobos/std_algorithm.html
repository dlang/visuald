<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.algorithm - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="/js/codemirror.js"></script>
<script src="/js/d.js"></script>
<script src="/js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){return lastName(a) > lastName(b)});

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="/images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="/images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="/images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos </a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>

    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>

</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std\algorithm.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/Phobos/StdAlgorithm" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>

    <h1>std.algorithm</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std\algorithm.d -->
<script type="text/javascript">inhibitQuickIndex = 1</script>
<p></p>
<table cellspacing=0 cellpadding=5 class=book><caption></caption><tr><th>Category</th> <th>Functions</th>
</tr>
<tr><td valign=top class="donthyphenate">Searching</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#all">all</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#any">any</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#balancedParens">balancedParens</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#boyerMooreFinder">boyerMooreFinder</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#canFind">canFind</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#count">count</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#countUntil">countUntil</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#commonPrefix">commonPrefix</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#endsWith">endsWith</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#find">find</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#findAdjacent">findAdjacent</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#findAmong">findAmong</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#findSkip">findSkip</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#findSplit">findSplit</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#findSplitAfter">findSplitAfter</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#findSplitBefore">findSplitBefore</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#minCount">minCount</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#minPos">minPos</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#mismatch">mismatch</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#skipOver">skipOver</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#startsWith">startsWith</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#until">until</a>&nbsp;</font> </td>
</tr>
<tr><td valign=top class="donthyphenate">Comparison</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#cmp">cmp</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#equal">equal</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#levenshteinDistance">levenshteinDistance</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#levenshteinDistanceAndPath">levenshteinDistanceAndPath</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#max">max</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#min">min</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#mismatch">mismatch</a>&nbsp;</font> </td>
</tr>
<tr><td valign=top class="donthyphenate">Iteration</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#filter">filter</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#filterBidirectional">filterBidirectional</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#group">group</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#joiner">joiner</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#map">map</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#reduce">reduce</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#splitter">splitter</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#uniq">uniq</a>&nbsp;</font> </td>
</tr>
<tr><td valign=top class="donthyphenate">Sorting</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#completeSort">completeSort</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#isPartitioned">isPartitioned</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#isSorted">isSorted</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#makeIndex">makeIndex</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#nextPermutation">nextPermutation</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#nextEvenPermutation">nextEvenPermutation</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#partialSort">partialSort</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#partition">partition</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#partition3">partition3</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#schwartzSort">schwartzSort</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#sort">sort</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#topN">topN</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#topNCopy">topNCopy</a>&nbsp;</font> </td>
</tr>
<tr><td valign=top class="donthyphenate">Set&nbsp;operations</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#cartesianProduct">cartesianProduct</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#largestPartialIntersection">largestPartialIntersection</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#largestPartialIntersectionWeighted">largestPartialIntersectionWeighted</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#nWayUnion">nWayUnion</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#setDifference">setDifference</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#setIntersection">setIntersection</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#setSymmetricDifference">setSymmetricDifference</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#setUnion">setUnion</a>&nbsp;</font> </td>
</tr>
<tr><td valign=top class="donthyphenate">Mutation</td> <td valign=top><font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#bringToFront">bringToFront</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#copy">copy</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#fill">fill</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#initializeAll">initializeAll</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#move">move</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#moveAll">moveAll</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#moveSome">moveSome</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#remove">remove</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#reverse">reverse</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#strip">strip</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#stripLeft">stripLeft</a>&nbsp;</font>
<font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#stripRight">stripRight</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#swap">swap</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#swapRanges">swapRanges</a>&nbsp;</font> <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#uninitializedFill">uninitializedFill</a>&nbsp;</font> </td></tr>
</table>
<p></p>

Implements algorithms oriented mainly towards processing of
sequences. Some functions are semantic equivalents or supersets of
those found in the <span class="d_inlinecode">&lt;algorithm&gt;</span> header in <a href="http://sgi.com/tech/stl/">Alexander Stepanov's Standard Template Library</a> for
C++.
<p></p>

Many functions in this module are parameterized with a function or a
<a href="../glossary.html#predicate">predicate</a>
. The predicate may be passed either as a
function name, a delegate name, a <a href="../glossary.html#functor">functor</a>
 name, or a
compile-time string. The string may consist of <b>any</b> legal D
expression that uses the symbol <span class="d_inlinecode">a</span> (for unary functions) or the
symbols <span class="d_inlinecode">a</span> and <span class="d_inlinecode">b</span> (for binary functions). These names will NOT
interfere with other homonym symbols in user code because they are
evaluated in a different context. The default for all binary
comparison predicates is <span class="d_inlinecode">"a == b"</span> for unordered operations and
<span class="d_inlinecode">"a &lt; b"</span> for ordered operations.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = ...;
<span class="d_keyword">static</span> <span class="d_keyword">bool</span> greater(<span class="d_keyword">int</span> a, <span class="d_keyword">int</span> b)
{
    <span class="d_keyword">return</span> a &gt; b;
}
sort!(greater)(a);  <span class="d_comment">// predicate as alias
</span>sort!(<span class="d_string">"a &gt; b"</span>)(a);  <span class="d_comment">// predicate as string
</span>                    <span class="d_comment">// (no ambiguity with array name)
</span>sort(a);            <span class="d_comment">// no predicate, "a &lt; b" is implicit
</span></pre>
<p></p>

<table cellspacing=0 cellpadding=5 class=book><caption>Cheat Sheet</caption><tr><th>Function Name</th> <th>Description</th>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Searching
</em></b></td></tr>
<tr><td valign=top class="donthyphenate"><a href="#all"><span class="d_inlinecode">all</span></a></td> <td valign=top><span class="d_inlinecode">all!"a &gt; 0"([1, 2, 3, 4])</span> returns <span class="d_inlinecode"><b>true</b></span> because all elements are positive</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#any"><span class="d_inlinecode">any</span></a></td> <td valign=top><span class="d_inlinecode">any!"a &gt; 0"([1, 2, -3, -4])</span> returns <span class="d_inlinecode"><b>true</b></span> because at least one element is positive</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#balancedParens"><span class="d_inlinecode">balancedParens</span></a></td> <td valign=top><span class="d_inlinecode">balancedParens("((1 + 1) / 2)")</span> returns <span class="d_inlinecode"><b>true</b></span> because the string
has balanced parentheses.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#boyerMooreFinder"><span class="d_inlinecode">boyerMooreFinder</span></a></td> <td valign=top><span class="d_inlinecode">find("hello
world", boyerMooreFinder("or"))</span> returns <span class="d_inlinecode">"orld"</span> using the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Boyer-Moore algorithm">Boyer-Moore algorithm</a>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#canFind"><span class="d_inlinecode">canFind</span></a></td> <td valign=top><span class="d_inlinecode">canFind("hello world",
"or")</span> returns <span class="d_inlinecode"><b>true</b></span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#count"><span class="d_inlinecode">count</span></a></td> <td valign=top>Counts elements that are equal
to a specified value or satisfy a predicate. <span class="d_inlinecode">count([1, 2, 1], 1)</span>
returns <span class="d_inlinecode">2</span> and <span class="d_inlinecode">count!"a &lt; 0"([1, -3, 0])</span> returns <span class="d_inlinecode">1</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#countUntil"><span class="d_inlinecode">countUntil</span></a></td> <td valign=top><span class="d_inlinecode">countUntil(a, b)</span>
returns the number of steps taken in <span class="d_inlinecode">a</span> to reach <span class="d_inlinecode">b</span>; for
example, <span class="d_inlinecode">countUntil("hello!", "o")</span> returns <span class="d_inlinecode">4</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#endsWith"><span class="d_inlinecode">endsWith</span></a></td> <td valign=top><span class="d_inlinecode">endsWith("rocks", "ks")</span>
returns <span class="d_inlinecode"><b>true</b></span>.</td>
</tr>
<tr><td valign=top><a href="#find"><span class="d_inlinecode">find</span></a></td> <td valign=top><span class="d_inlinecode">find("hello world",
"or")</span> returns <span class="d_inlinecode">"orld"</span> using linear search. (For binary search refer
to <a href="std_range.html#sortedRange"><span class="d_inlinecode">std.range.sortedRange</span></a>.)</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#findAdjacent"><span class="d_inlinecode">findAdjacent</span></a></td> <td valign=top><span class="d_inlinecode">findAdjacent([1, 2,
3, 3, 4])</span> returns the subrange starting with two equal adjacent
elements, i.e. <span class="d_inlinecode">[3, 3, 4]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#findAmong"><span class="d_inlinecode">findAmong</span></a></td> <td valign=top><span class="d_inlinecode">findAmong("abcd",
"qcx")</span> returns <span class="d_inlinecode">"cd"</span> because <span class="d_inlinecode">'c'</span> is among <span class="d_inlinecode">"qcx"</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#findSkip"><span class="d_inlinecode">findSkip</span></a></td> <td valign=top>If <span class="d_inlinecode">a = "abcde"</span>, then
<span class="d_inlinecode">findSkip(a, "x")</span> returns <span class="d_inlinecode"><b>false</b></span> and leaves <span class="d_inlinecode">a</span> unchanged,
whereas <span class="d_inlinecode">findSkip(a, 'c')</span> advances <span class="d_inlinecode">a</span> to <span class="d_inlinecode">"cde"</span> and
returns <span class="d_inlinecode"><b>true</b></span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#findSplit"><span class="d_inlinecode">findSplit</span></a></td> <td valign=top><span class="d_inlinecode">findSplit("abcdefg",
"de")</span> returns the three ranges <span class="d_inlinecode">"abc"</span>, <span class="d_inlinecode">"de"</span>, and <span class="d_inlinecode">"fg"</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#findSplitAfter"><span class="d_inlinecode">findSplitAfter</span></a></td> <td valign=top><span class="d_inlinecode">findSplitAfter("abcdefg", "de")</span> returns the two ranges <span class="d_inlinecode">"abcde"</span>
and <span class="d_inlinecode">"fg"</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#findSplitBefore"><span class="d_inlinecode">findSplitBefore</span></a></td> <td valign=top><span class="d_inlinecode">findSplitBefore("abcdefg", "de")</span> returns the two ranges <span class="d_inlinecode">"abc"</span> and
<span class="d_inlinecode">"defg"</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#minCount"><span class="d_inlinecode">minCount</span></a></td> <td valign=top><span class="d_inlinecode">minCount([2, 1, 1, 4,
1])</span> returns <span class="d_inlinecode">tuple(1, 3)</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#minPos"><span class="d_inlinecode">minPos</span></a></td> <td valign=top><span class="d_inlinecode">minPos([2, 3, 1, 3, 4,
1])</span> returns the subrange <span class="d_inlinecode">[1, 3, 4, 1]</span>, i.e., positions the range
at the first occurrence of its minimal element.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#skipOver"><span class="d_inlinecode">skipOver</span></a></td> <td valign=top>Assume <span class="d_inlinecode">a = "blah"</span>. Then
<span class="d_inlinecode">skipOver(a, "bi")</span> leaves <span class="d_inlinecode">a</span> unchanged and returns <span class="d_inlinecode"><b>false</b></span>,
whereas <span class="d_inlinecode">skipOver(a, "bl")</span> advances <span class="d_inlinecode">a</span> to refer to <span class="d_inlinecode">"ah"</span>
and returns <span class="d_inlinecode"><b>true</b></span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#startsWith"><span class="d_inlinecode">startsWith</span></a></td> <td valign=top><span class="d_inlinecode">startsWith("hello,
world", "hello")</span> returns <span class="d_inlinecode"><b>true</b></span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#until"><span class="d_inlinecode">until</span></a></td> <td valign=top>Lazily iterates a range
until a specific value is found.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Comparison
</em></b></td></tr>
<tr><td valign=top class="donthyphenate"><a href="#cmp"><span class="d_inlinecode">cmp</span></a></td> <td valign=top><span class="d_inlinecode">cmp("abc", "abcd")</span> is <span class="d_inlinecode">-1</span>, <span class="d_inlinecode">cmp("abc", "aba")</span> is <span class="d_inlinecode">1</span>, and <span class="d_inlinecode">cmp("abc", "abc")</span> is
<span class="d_inlinecode">0</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#equal"><span class="d_inlinecode">equal</span></a></td> <td valign=top>Compares ranges for
element-by-element equality, e.g. <span class="d_inlinecode">equal([1, 2, 3], [1.0, 2.0,
3.0])</span> returns <span class="d_inlinecode"><b>true</b></span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#levenshteinDistance"><span class="d_inlinecode">levenshteinDistance</span></a></td> <td valign=top><span class="d_inlinecode">levenshteinDistance("kitten", "sitting")</span> returns <span class="d_inlinecode">3</span> by using the
<a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Levenshtein distance algorithm">Levenshtein distance algorithm</a>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#levenshteinDistanceAndPath"><span class="d_inlinecode">levenshteinDistanceAndPath</span></a></td> <td valign=top><span class="d_inlinecode">levenshteinDistanceAndPath("kitten", "sitting")</span> returns <span class="d_inlinecode">tuple(3,
"snnnsni")</span> by using the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Levenshtein distance algorithm">Levenshtein distance algorithm</a>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#max"><span class="d_inlinecode">max</span></a></td> <td valign=top><span class="d_inlinecode">max(3, 4, 2)</span> returns <span class="d_inlinecode">4</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#min"><span class="d_inlinecode">min</span></a></td> <td valign=top><span class="d_inlinecode">min(3, 4, 2)</span> returns <span class="d_inlinecode">2</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#mismatch"><span class="d_inlinecode">mismatch</span></a></td> <td valign=top><span class="d_inlinecode">mismatch("oh hi",
"ohayo")</span> returns <span class="d_inlinecode">tuple(" hi", "ayo")</span>.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Iteration
</em></b></td></tr>
<tr><td valign=top class="donthyphenate"><a href="#filter"><span class="d_inlinecode">filter</span></a></td> <td valign=top><span class="d_inlinecode">filter!"a &gt; 0"([1, -1, 2,
0, -3])</span> iterates over elements <span class="d_inlinecode">1</span> and <span class="d_inlinecode">2</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#filterBidirectional"><span class="d_inlinecode">filterBidirectional</span></a></td> <td valign=top>Similar to <span class="d_inlinecode">filter</span>, but also provides <span class="d_inlinecode">back</span> and <span class="d_inlinecode">popBack</span> at a small
increase in cost.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#group"><span class="d_inlinecode">group</span></a></td> <td valign=top><span class="d_inlinecode">group([5, 2, 2, 3, 3])</span>
returns a range containing the tuples <span class="d_inlinecode">tuple(5, 1)</span>,
<span class="d_inlinecode">tuple(2, 2)</span>, and <span class="d_inlinecode">tuple(3, 2)</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#joiner"><span class="d_inlinecode">joiner</span></a></td> <td valign=top><span class="d_inlinecode">joiner(["hello",
"world!"], ";")</span> returns a range that iterates over the characters <span class="d_inlinecode">"hello; world!"</span>. No new string is created - the existing inputs are
iterated.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#map"><span class="d_inlinecode">map</span></a></td> <td valign=top><span class="d_inlinecode">map!"2 * a"([1, 2, 3])</span>
lazily returns a range with the numbers <span class="d_inlinecode">2</span>, <span class="d_inlinecode">4</span>, <span class="d_inlinecode">6</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#reduce"><span class="d_inlinecode">reduce</span></a></td> <td valign=top><span class="d_inlinecode">reduce!"a + b"([1, 2, 3,
4])</span> returns <span class="d_inlinecode">10</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#splitter"><span class="d_inlinecode">splitter</span></a></td> <td valign=top>Lazily splits a range by a
separator.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#uniq"><span class="d_inlinecode">uniq</span></a></td> <td valign=top>Iterates over the unique elements
in a range, which is assumed sorted.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Sorting
</em></b></td></tr>
<tr><td valign=top class="donthyphenate"><a href="#completeSort"><span class="d_inlinecode">completeSort</span></a></td> <td valign=top>If <span class="d_inlinecode">a = [10, 20, 30]</span>
and <span class="d_inlinecode">b = [40, 6, 15]</span>, then <span class="d_inlinecode">completeSort(a, b)</span> leaves <span class="d_inlinecode">a =
[6, 10, 15]</span> and <span class="d_inlinecode">b = [20, 30, 40]</span>. The range <span class="d_inlinecode">a</span> must be
sorted prior to the call, and as a result the combination <span class="d_inlinecode"><a href="std_range.html#chain"><span class="d_inlinecode">std.range.chain</span></a>(a, b)</span> is sorted.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#isPartitioned"><span class="d_inlinecode">isPartitioned</span></a></td> <td valign=top><span class="d_inlinecode">isPartitioned!"a &lt;
0"([-1, -2, 1, 0, 2])</span> returns <span class="d_inlinecode"><b>true</b></span> because the predicate is <span class="d_inlinecode"><b>true</b></span> for a portion of the range and <span class="d_inlinecode"><b>false</b></span> afterwards.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#isSorted"><span class="d_inlinecode">isSorted</span></a></td> <td valign=top><span class="d_inlinecode">isSorted([1, 1, 2, 3])</span>
returns <span class="d_inlinecode"><b>true</b></span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#makeIndex"><span class="d_inlinecode">makeIndex</span></a></td> <td valign=top>Creates a separate index
for a range.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#nextPermutation"><span class="d_inlinecode">nextPermutation</span></a></td> <td valign=top>Computes the next lexicographically
greater permutation of a range in-place.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#nextEvenPermutation"><span class="d_inlinecode">nextEvenPermutation</span></a></td> <td valign=top>Computes the next
lexicographically greater even permutation of a range in-place.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#partialSort"><span class="d_inlinecode">partialSort</span></a></td> <td valign=top>If <span class="d_inlinecode">a = [5, 4, 3, 2,
1]</span>, then <span class="d_inlinecode">partialSort(a, 3)</span> leaves <span class="d_inlinecode">a[0 .. 3] = [1, 2,
3]</span>. The other elements of <span class="d_inlinecode">a</span> are left in an unspecified order.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#partition"><span class="d_inlinecode">partition</span></a></td> <td valign=top>Partitions a range
according to a predicate.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#schwartzSort"><span class="d_inlinecode">schwartzSort</span></a></td> <td valign=top>Sorts with the help of
the <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=Schwartzian transform">Schwartzian transform</a>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#sort"><span class="d_inlinecode">sort</span></a></td> <td valign=top>Sorts.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#topN"><span class="d_inlinecode">topN</span></a></td> <td valign=top>Separates the top elements in a
range.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#topNCopy"><span class="d_inlinecode">topNCopy</span></a></td> <td valign=top>Copies out the top elements
of a range.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Set operations
</em></b></td></tr>
<tr><td valign=top class="donthyphenate"><a href="#cartesianProduct"><span class="d_inlinecode">cartesianProduct</span></a></td> <td valign=top>Computes Cartesian product of two
ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#largestPartialIntersection"><span class="d_inlinecode">largestPartialIntersection</span></a></td> <td valign=top>Copies out
the values that occur most frequently in a range of ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#largestPartialIntersectionWeighted"><span class="d_inlinecode">largestPartialIntersectionWeighted</span></a></td> <td valign=top>Copies out the values that occur most frequently (multiplied by
per-value weights) in a range of ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#nWayUnion"><span class="d_inlinecode">nWayUnion</span></a></td> <td valign=top>Computes the union of a set
of sets implemented as a range of sorted ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#setDifference"><span class="d_inlinecode">setDifference</span></a></td> <td valign=top>Lazily computes the set
difference of two or more sorted ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#setIntersection"><span class="d_inlinecode">setIntersection</span></a></td> <td valign=top>Lazily computes the
intersection of two or more sorted ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#setSymmetricDifference"><span class="d_inlinecode">setSymmetricDifference</span></a></td> <td valign=top>Lazily
computes the symmetric set difference of two or more sorted ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#setUnion"><span class="d_inlinecode">setUnion</span></a></td> <td valign=top>Lazily computes the set
union of two or more sorted ranges.</td>
</tr>
<tr class=leadingrow><td colspan=2><b><em>&nbsp;&nbsp;&nbsp;&nbsp;Mutation
</em></b></td></tr>
<tr><td valign=top class="donthyphenate"><a href="#bringToFront"><span class="d_inlinecode">bringToFront</span></a></td> <td valign=top>If <span class="d_inlinecode">a = [1, 2, 3]</span>
and <span class="d_inlinecode">b = [4, 5, 6, 7]</span>, <span class="d_inlinecode">bringToFront(a, b)</span> leaves <span class="d_inlinecode">a = [4,
5, 6]</span> and <span class="d_inlinecode">b = [7, 1, 2, 3]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#copy"><span class="d_inlinecode">copy</span></a></td> <td valign=top>Copies a range to another. If
<span class="d_inlinecode">a = [1, 2, 3]</span> and <span class="d_inlinecode">b = new int[5]</span>, then <span class="d_inlinecode">copy(a, b)</span>
leaves <span class="d_inlinecode">b = [1, 2, 3, 0, 0]</span> and returns <span class="d_inlinecode">b[3 .. $]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#fill"><span class="d_inlinecode">fill</span></a></td> <td valign=top>Fills a range with a pattern,
e.g., if <span class="d_inlinecode">a = new int[3]</span>, then <span class="d_inlinecode">fill(a, 4)</span> leaves <span class="d_inlinecode">a = [4,
4, 4]</span> and <span class="d_inlinecode">fill(a, [3, 4])</span> leaves <span class="d_inlinecode">a = [3, 4, 3]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#initializeAll"><span class="d_inlinecode">initializeAll</span></a></td> <td valign=top>If <span class="d_inlinecode">a = [1.2, 3.4]</span>,
then <span class="d_inlinecode">initializeAll(a)</span> leaves <span class="d_inlinecode">a = [double.init,
double.init]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#move"><span class="d_inlinecode">move</span></a></td> <td valign=top><span class="d_inlinecode">move(a, b)</span> moves <span class="d_inlinecode">a</span>
into <span class="d_inlinecode">b</span>. <span class="d_inlinecode">move(a)</span> reads <span class="d_inlinecode">a</span> destructively.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#moveAll"><span class="d_inlinecode">moveAll</span></a></td> <td valign=top>Moves all elements from one
range to another.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#moveSome"><span class="d_inlinecode">moveSome</span></a></td> <td valign=top>Moves as many elements as
possible from one range to another.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#reverse"><span class="d_inlinecode">reverse</span></a></td> <td valign=top>If <span class="d_inlinecode">a = [1, 2, 3]</span>, <span class="d_inlinecode">reverse(a)</span> changes it to <span class="d_inlinecode">[3, 2, 1]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#strip"><span class="d_inlinecode">strip</span></a></td> <td valign=top>Strips all leading and trailing
elements equal to a value, or that satisfy a predicate.
If <span class="d_inlinecode">a = [1, 1, 0, 1, 1]</span>, then <span class="d_inlinecode">strip(a, 1)</span> and <span class="d_inlinecode">strip!(e =&gt; e == 1)(a)</span>
returns <span class="d_inlinecode">[0]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#stripLeft"><span class="d_inlinecode">stripLeft</span></a></td> <td valign=top>Strips all leading elements equal to a value,
or that satisfy a predicate.
If <span class="d_inlinecode">a = [1, 1, 0, 1, 1]</span>, then <span class="d_inlinecode">stripLeft(a, 1)</span> and <span class="d_inlinecode">stripLeft!(e =&gt; e == 1)(a)</span>
returns <span class="d_inlinecode">[0, 1, 1]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#stripRight"><span class="d_inlinecode">stripRight</span></a></td> <td valign=top>Strips all trailing elements equal to a value,
or that satisfy a predicate.
If <span class="d_inlinecode">a = [1, 1, 0, 1, 1]</span>, then <span class="d_inlinecode">stripRight(a, 1)</span> and <span class="d_inlinecode">stripRight!(e =&gt; e == 1)(a)</span>
returns <span class="d_inlinecode">[1, 1, 0]</span>.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#swap"><span class="d_inlinecode">swap</span></a></td> <td valign=top>Swaps two values.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#swapRanges"><span class="d_inlinecode">swapRanges</span></a></td> <td valign=top>Swaps all elements of two
ranges.</td>
</tr>
<tr><td valign=top class="donthyphenate"><a href="#uninitializedFill"><span class="d_inlinecode">uninitializedFill</span></a></td> <td valign=top>Fills a range
(assumed uninitialized) with a value.</td>
</tr>
</table>

<p></p>
<b>License:</b><br><a href="http://boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.

<p></p>
<b>Authors:</b><br><a href="http://erdani.com">Andrei Alexandrescu</a>

<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/algorithm.d">std/algorithm.d</a><p></p>

<dl><dt class="d_decl"><a name=".map"></a>template <a name="map"></a><span class="ddoc_psymbol">map</span>(fun...) if (fun.length &gt;= 1)</dt>
<dd><span class="d_inlinecode">auto <a name="map"></a><span class="ddoc_psymbol">map</span>(Range)(Range r) if (isInputRange!(Unqual!Range));</span>
<p></p>
Implements the homonym function (also known as <span class="d_inlinecode">transform</span>) present
in many languages of functional flavor. The call <span class="d_inlinecode"><a name="map"></a><span class="ddoc_psymbol">map</span>!(fun)(range)</span>
returns a range of which elements are obtained by applying <span class="d_inlinecode">fun(x)</span>
left to right for all <span class="d_inlinecode">x</span> in <span class="d_inlinecode">range</span>. The original ranges are
not changed. Evaluation is done lazily.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr1 = [ 1, 2, 3, 4 ];
<span class="d_keyword">int</span>[] arr2 = [ 5, 6 ];
<span class="d_keyword">auto</span> squares = <span class="d_psymbol">map</span>!(a =&gt; a * a)(chain(arr1, arr2));
<span class="d_keyword">assert</span>(equal(squares, [ 1, 4, 9, 16, 25, 36 ]));
</pre>
<p></p>

Multiple functions can be passed to <span class="d_inlinecode"><a name="map"></a><span class="ddoc_psymbol">map</span></span>. In that case, the
element type of <span class="d_inlinecode"><a name="map"></a><span class="ddoc_psymbol">map</span></span> is a tuple containing one element for each
function.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> arr1 = [ 1, 2, 3, 4 ];
<span class="d_keyword">foreach</span> (e; <span class="d_psymbol">map</span>!(<span class="d_string">"a + a"</span>, <span class="d_string">"a * a"</span>)(arr1))
{
    writeln(e[0], <span class="d_string">" "</span>, e[1]);
}
</pre>
<p></p>

You may alias <span class="d_inlinecode"><a name="map"></a><span class="ddoc_psymbol">map</span></span> with some function(s) to a symbol and use
it separately:
<p></p>

<pre class="d_code"><span class="d_keyword">alias</span> <span class="d_psymbol">map</span>!(to!string) stringize;
<span class="d_keyword">assert</span>(equal(stringize([ 1, 2, 3, 4 ]), [ <span class="d_string">"1"</span>, <span class="d_string">"2"</span>, <span class="d_string">"3"</span>, <span class="d_string">"4"</span> ]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".reduce"></a>template <a name="reduce"></a><span class="ddoc_psymbol">reduce</span>(fun...) if (fun.length &gt;= 1)</dt>
<dd><span class="d_inlinecode">auto <a name="reduce"></a><span class="ddoc_psymbol">reduce</span>(Args...)(Args args)
    if (Args.length &gt; 0 &amp;&amp; Args.length &lt;= 2 &amp;&amp; isIterable!(Args[$ - 1]));</span>
<p></p>
Implements the homonym function (also known as <span class="d_inlinecode">accumulate</span>, <span class="d_inlinecode">compress</span>, <span class="d_inlinecode">inject</span>, or <span class="d_inlinecode">foldl</span>) present in various programming
languages of functional flavor. The call <span class="d_inlinecode"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span>!(fun)(seed,
range)</span> first assigns <span class="d_inlinecode">seed</span> to an internal variable <span class="d_inlinecode">result</span>,
also called the accumulator. Then, for each element <span class="d_inlinecode">x</span> in <span class="d_inlinecode">range</span>, <span class="d_inlinecode">result = fun(result, x)</span> gets evaluated. Finally, <span class="d_inlinecode">result</span> is returned. The one-argument version <span class="d_inlinecode"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span>!(fun)(range)</span>
works similarly, but it uses the first element of the range as the
seed (the range must be non-empty).
<p></p>

Many aggregate range operations turn out to be solved with <span class="d_inlinecode"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span></span>
quickly and easily. The example below illustrates <span class="d_inlinecode"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span></span>'s
remarkable power and flexibility.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [ 1, 2, 3, 4, 5 ];
<span class="d_comment">// Sum all elements
</span><span class="d_keyword">auto</span> sum = <span class="d_psymbol">reduce</span>!((a,b) =&gt; a + b)(0, arr);
<span class="d_keyword">assert</span>(sum == 15);

<span class="d_comment">// Sum again, using a string predicate with "a" and "b"
</span>sum = <span class="d_psymbol">reduce</span>!<span class="d_string">"a + b"</span>(0, arr);
<span class="d_keyword">assert</span>(sum == 15);

<span class="d_comment">// Compute the maximum of all elements
</span><span class="d_keyword">auto</span> largest = <span class="d_psymbol">reduce</span>!(max)(arr);
<span class="d_keyword">assert</span>(largest == 5);

<span class="d_comment">// Max again, but with Uniform Function Call Syntax (UFCS)
</span>largest = arr.<span class="d_psymbol">reduce</span>!(max);
<span class="d_keyword">assert</span>(largest == 5);

<span class="d_comment">// Compute the number of odd elements
</span><span class="d_keyword">auto</span> odds = <span class="d_psymbol">reduce</span>!((a,b) =&gt; a + (b &amp; 1))(0, arr);
<span class="d_keyword">assert</span>(odds == 3);

<span class="d_comment">// Compute the sum of squares
</span><span class="d_keyword">auto</span> ssquares = <span class="d_psymbol">reduce</span>!((a,b) =&gt; a + b * b)(0, arr);
<span class="d_keyword">assert</span>(ssquares == 55);

<span class="d_comment">// Chain multiple ranges into seed
</span><span class="d_keyword">int</span>[] a = [ 3, 4 ];
<span class="d_keyword">int</span>[] b = [ 100 ];
<span class="d_keyword">auto</span> r = <span class="d_psymbol">reduce</span>!(<span class="d_string">"a + b"</span>)(chain(a, b));
<span class="d_keyword">assert</span>(r == 107);

<span class="d_comment">// Mixing convertible types is fair game, too
</span><span class="d_keyword">double</span>[] c = [ 2.5, 3.0 ];
<span class="d_keyword">auto</span> r1 = <span class="d_psymbol">reduce</span>!(<span class="d_string">"a + b"</span>)(chain(a, b, c));
<span class="d_keyword">assert</span>(approxEqual(r1, 112.5));

<span class="d_comment">// To minimize nesting of parentheses, Uniform Function Call Syntax can be used
</span><span class="d_keyword">auto</span> r2 = chain(a, b, c).<span class="d_psymbol">reduce</span>!(<span class="d_string">"a + b"</span>);
<span class="d_keyword">assert</span>(approxEqual(r2, 112.5));
</pre>
<p></p>

<b>Multiple functions:</b><br> Sometimes it is very useful to
compute multiple aggregates in one pass. One advantage is that the
computation is faster because the looping overhead is shared. That's
why <span class="d_inlinecode"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span></span> accepts multiple functions. If two or more functions
are passed, <span class="d_inlinecode"><a name="reduce"></a><span class="ddoc_psymbol">reduce</span></span> returns a <a href="std_typecons.html#Tuple"><span class="d_inlinecode">std.typecons.Tuple</span></a> object with
one member per passed-in function. The number of seeds must be
correspondingly increased.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">double</span>[] a = [ 3.0, 4, 7, 11, 3, 2, 5 ];
<span class="d_comment">// Compute minimum and maximum in one pass
</span><span class="d_keyword">auto</span> r = <span class="d_psymbol">reduce</span>!(min, max)(a);
<span class="d_comment">// The type of r is Tuple!(int, int)
</span><span class="d_keyword">assert</span>(approxEqual(r[0], 2));  <span class="d_comment">// minimum
</span><span class="d_keyword">assert</span>(approxEqual(r[1], 11)); <span class="d_comment">// maximum
</span>
<span class="d_comment">// Compute sum and sum of squares in one pass
</span>r = <span class="d_psymbol">reduce</span>!(<span class="d_string">"a + b"</span>, <span class="d_string">"a + b * b"</span>)(tuple(0.0, 0.0), a);
<span class="d_keyword">assert</span>(approxEqual(r[0], 35));  <span class="d_comment">// sum
</span><span class="d_keyword">assert</span>(approxEqual(r[1], 233)); <span class="d_comment">// sum of squares
</span><span class="d_comment">// Compute average and standard deviation from the above
</span><span class="d_keyword">auto</span> avg = r[0] / a.length;
<span class="d_keyword">auto</span> stdev = sqrt(r[1] / a.length - avg * avg);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".fill"></a>void <a name="fill"></a><span class="ddoc_psymbol">fill</span>(Range, Value)(Range <i>range</i>, Value <i>filler</i>) if (isInputRange!Range &amp;&amp; is(typeof(<i>range</i>.front = <i>filler</i>)));
</dt>
<dd>Fills <span class="d_inlinecode">range</span> with a <span class="d_inlinecode">filler</span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 3, 4 ];
<span class="d_psymbol">fill</span>(a, 5);
<span class="d_keyword">assert</span>(a == [ 5, 5, 5, 5 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".fill"></a>void <a name="fill"></a><span class="ddoc_psymbol">fill</span>(Range1, Range2)(Range1 <i>range</i>, Range2 <i>filler</i>) if (isInputRange!Range1 &amp;&amp; (isForwardRange!Range2 || isInputRange!Range2 &amp;&amp; isInfinite!Range2) &amp;&amp; is(typeof(Range1.init.front = Range2.init.front)));
</dt>
<dd>Fills <span class="d_inlinecode">range</span> with a pattern copied from <span class="d_inlinecode">filler</span>. The length of
<span class="d_inlinecode">range</span> does not have to be a multiple of the length of <span class="d_inlinecode">filler</span>. If <span class="d_inlinecode">filler</span> is empty, an exception is thrown.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 3, 4, 5 ];
<span class="d_keyword">int</span>[] b = [ 8, 9 ];
<span class="d_psymbol">fill</span>(a, b);
<span class="d_keyword">assert</span>(a == [ 8, 9, 8, 9, 8 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".uninitializedFill"></a>void <a name="uninitializedFill"></a><span class="ddoc_psymbol">uninitializedFill</span>(Range, Value)(Range <i>range</i>, Value <i>filler</i>) if (isInputRange!Range &amp;&amp; hasLvalueElements!Range &amp;&amp; is(typeof(<i>range</i>.front = <i>filler</i>)));
</dt>
<dd>Fills a range with a value. Assumes that the range does not currently
contain meaningful content. This is of interest for structs that
define copy constructors (for all other types, fill and
<a name="uninitializedFill"></a><span class="ddoc_psymbol">uninitializedFill</span> are equivalent).
<p></p>
<a name="uninitializedFill"></a><span class="ddoc_psymbol">uninitializedFill</span> will only operate on ranges that expose references to its
members and have assignable elements.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">struct</span> S { ... }
S[] s = (<span class="d_keyword">cast</span>(S*) malloc(5 * S.sizeof))[0 .. 5];
<span class="d_psymbol">uninitializedFill</span>(s, 42);
<span class="d_keyword">assert</span>(s == [ 42, 42, 42, 42, 42 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".initializeAll"></a>void <a name="initializeAll"></a><span class="ddoc_psymbol">initializeAll</span>(Range)(Range <i>range</i>) if (isInputRange!Range &amp;&amp; hasLvalueElements!Range &amp;&amp; hasAssignableElements!Range);
</dt>
<dd>Initializes all elements of a range with their <span class="d_inlinecode">.init</span>
value. Assumes that the range does not currently contain meaningful
content.
<p></p>
<a name="initializeAll"></a><span class="ddoc_psymbol">initializeAll</span> will operate on ranges that expose references to its
members and have assignable elements, as well as on (mutable) strings.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">struct</span> S { ... }
S[] s = (<span class="d_keyword">cast</span>(S*) malloc(5 * S.sizeof))[0 .. 5];
<span class="d_psymbol">initializeAll</span>(s);
<span class="d_keyword">assert</span>(s == [ 0, 0, 0, 0, 0 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".filter"></a>template <a name="filter"></a><span class="ddoc_psymbol">filter</span>(alias pred) if (is(typeof(unaryFun!pred)))</dt>
<dd><span class="d_inlinecode">auto <a name="filter"></a><span class="ddoc_psymbol">filter</span>(Range)(Range rs) if (isInputRange!(Unqual!Range));</span>
<p></p>
Implements the homonym function present in various programming
languages of functional flavor. The call <span class="d_inlinecode"><a name="filter"></a><span class="ddoc_psymbol">filter</span>!(predicate)(range)</span>
returns a new range only containing elements <span class="d_inlinecode">x</span> in <span class="d_inlinecode">range</span> for
which <span class="d_inlinecode">predicate(x)</span> is <span class="d_inlinecode"><b>true</b></span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [ 1, 2, 3, 4, 5 ];

<span class="d_comment">// Sum all elements
</span><span class="d_keyword">auto</span> small = <span class="d_psymbol">filter</span>!(a =&gt; a &lt; 3)(arr);
<span class="d_keyword">assert</span>(equal(small, [ 1, 2 ]));

<span class="d_comment">// Sum again, but with Uniform Function Call Syntax (UFCS)
</span><span class="d_keyword">auto</span> sum = arr.<span class="d_psymbol">filter</span>!(a =&gt; a &lt; 3);
<span class="d_keyword">assert</span>(equal(sum, [ 1, 2 ]));

<span class="d_comment">// In combination with chain() to span multiple ranges
</span><span class="d_keyword">int</span>[] a = [ 3, -2, 400 ];
<span class="d_keyword">int</span>[] b = [ 100, -101, 102 ];
<span class="d_keyword">auto</span> r = chain(a, b).<span class="d_psymbol">filter</span>!(a =&gt; a &gt; 0);
<span class="d_keyword">assert</span>(equal(r, [ 3, 400, 100, 102 ]));

<span class="d_comment">// Mixing convertible types is fair game, too
</span><span class="d_keyword">double</span>[] c = [ 2.5, 3.0 ];
<span class="d_keyword">auto</span> r1 = chain(c, a, b).<span class="d_psymbol">filter</span>!(a =&gt; <span class="d_keyword">cast</span>(<span class="d_keyword">int</span>) a != a);
<span class="d_keyword">assert</span>(approxEqual(r1, [ 2.5 ]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".filterBidirectional"></a>template <a name="filterBidirectional"></a><span class="ddoc_psymbol">filterBidirectional</span>(alias pred)</dt>
<dd><span class="d_inlinecode">auto <a name="filterBidirectional"></a><span class="ddoc_psymbol">filterBidirectional</span>(Range)(Range r) if (isBidirectionalRange!(Unqual!Range));</span>
<p></p>
Similar to <span class="d_inlinecode">filter</span>, except it defines a bidirectional
 range. There is a speed disadvantage - the constructor spends time
 finding the last element in the range that satisfies the filtering
 condition (in addition to finding the first one). The advantage is
 that the filtered range can be spanned from both directions. Also,
 <a href="std_range.html#retro"><span class="d_inlinecode">std.range.retro</span></a> can be applied against the filtered range.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [ 1, 2, 3, 4, 5 ];
<span class="d_keyword">auto</span> small = <span class="d_psymbol">filterBidirectional</span>!(<span class="d_string">"a &lt; 3"</span>)(arr);
<span class="d_keyword">assert</span>(small.back == 2);
<span class="d_keyword">assert</span>(equal(small, [ 1, 2 ]));
<span class="d_keyword">assert</span>(equal(retro(small), [ 2, 1 ]));
<span class="d_comment">// In combination with chain() to span multiple ranges
</span><span class="d_keyword">int</span>[] a = [ 3, -2, 400 ];
<span class="d_keyword">int</span>[] b = [ 100, -101, 102 ];
<span class="d_keyword">auto</span> r = <span class="d_psymbol">filterBidirectional</span>!(<span class="d_string">"a &gt; 0"</span>)(chain(a, b));
<span class="d_keyword">assert</span>(r.back == 102);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".move"></a>void <a name="move"></a><span class="ddoc_psymbol">move</span>(T)(ref T <i>source</i>, ref T <i>target</i>);
<br><a name=".move"></a>T <a name="move"></a><span class="ddoc_psymbol">move</span>(T)(ref T <i>source</i>);
</dt>
<dd>Moves <span class="d_inlinecode">source</span> into <span class="d_inlinecode">target</span> via a destructive
copy. Specifically: <ul><li>If <span class="d_inlinecode">hasAliasing!T</span> is <b>true</b> (see
<a href="std_traits.html#hasAliasing"><span class="d_inlinecode">std.traits.hasAliasing</span></a>), then the representation of <span class="d_inlinecode">source</span>
is bitwise copied into <span class="d_inlinecode">target</span> and then <span class="d_inlinecode">source = T.init</span> is
evaluated.</li>  <li>Otherwise, <span class="d_inlinecode">target = source</span> is evaluated.</li></ul> See
also <a href="std_exception.html#pointsTo"><span class="d_inlinecode">std.exception.pointsTo</span></a>.
<p></p>
<b>Preconditions:</b><br>
<span class="d_inlinecode">&source == &target || !pointsTo(source, source)</span><p></p>

</dd>
<dt class="d_decl"><a name=".moveAll"></a>Range2 <a name="moveAll"></a><span class="ddoc_psymbol">moveAll</span>(Range1, Range2)(Range1 <i>src</i>, Range2 <i>tgt</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(typeof(move(<i>src</i>.front, <i>tgt</i>.front))));
</dt>
<dd>For each element <span class="d_inlinecode">a</span> in <span class="d_inlinecode">src</span> and each element <span class="d_inlinecode">b</span> in <span class="d_inlinecode">tgt</span> in lockstep in increasing order, calls <span class="d_inlinecode">move(a, b)</span>. Returns
the leftover portion of <span class="d_inlinecode">tgt</span>. Throws an exeption if there is not
enough room in <span class="d_inlinecode">tgt</span> to acommodate all of <span class="d_inlinecode">src</span>.
<p></p>
<b>Preconditions:</b><br>
<span class="d_inlinecode">walkLength(src) &lt;= walkLength(tgt)</span><p></p>

</dd>
<dt class="d_decl"><a name=".moveSome"></a>Tuple!(Range1, Range2) <a name="moveSome"></a><span class="ddoc_psymbol">moveSome</span>(Range1, Range2)(Range1 <i>src</i>, Range2 <i>tgt</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(typeof(move(<i>src</i>.front, <i>tgt</i>.front))));
</dt>
<dd>For each element <span class="d_inlinecode">a</span> in <span class="d_inlinecode">src</span> and each element <span class="d_inlinecode">b</span> in <span class="d_inlinecode">tgt</span> in lockstep in increasing order, calls <span class="d_inlinecode">move(a, b)</span>. Stops
when either <span class="d_inlinecode">src</span> or <span class="d_inlinecode">tgt</span> have been exhausted. Returns the
leftover portions of the two ranges.<p></p>

</dd>
<dt class="d_decl"><a name=".swap"></a>pure nothrow @trusted void <a name="swap"></a><span class="ddoc_psymbol">swap</span>(T)(ref T <i>lhs</i>, ref T <i>rhs</i>) if (isMutable!T &amp;&amp; !is(typeof(T.init.proxySwap(T.init))));
</dt>
<dd>Swaps <span class="d_inlinecode">lhs</span> and <span class="d_inlinecode">rhs</span>. See also <a href="std_exception.html#pointsTo"><span class="d_inlinecode">std.exception.pointsTo</span></a>.
<p></p>
<b>Preconditions:</b><br>
<span class="d_inlinecode">!pointsTo(lhs, lhs) &amp;&amp; !pointsTo(lhs, rhs) &amp;&amp; !pointsTo(rhs, lhs)
&amp;&amp; !pointsTo(rhs, rhs)</span><p></p>

</dd>
<dt class="d_decl"><a name=".forward"></a>template <a name="forward"></a><span class="ddoc_psymbol">forward</span>(args...)</dt>
<dd>Forwards function arguments with saving ref-ness.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> n) { <span class="d_keyword">return</span> 1; }
<span class="d_keyword">int</span> foo(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> n) { <span class="d_keyword">return</span> 2; }
<span class="d_keyword">int</span> bar()(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> foo(<span class="d_psymbol">forward</span>!x); }

<span class="d_keyword">assert</span>(bar(1) == 1);
<span class="d_keyword">int</span> i;
<span class="d_keyword">assert</span>(bar(i) == 2);
</pre>
<p></p>

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> n, <span class="d_keyword">ref</span> string s) { s = <span class="d_keyword">null</span>; <span class="d_keyword">foreach</span> (i; 0..n) s ~= <span class="d_string">"Hello"</span>; }

<span class="d_comment">// forwards all arguments which are bound to parameter tuple
</span><span class="d_keyword">void</span> bar(Args...)(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> Args args) { <span class="d_keyword">return</span> foo(<span class="d_psymbol">forward</span>!args); }

<span class="d_comment">// forwards all arguments with swapping order
</span><span class="d_keyword">void</span> baz(Args...)(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> Args args) { <span class="d_keyword">return</span> foo(<span class="d_psymbol">forward</span>!args[$/2..$], <span class="d_psymbol">forward</span>!args[0..$/2]); }

string s;
bar(1, s);
<span class="d_keyword">assert</span>(s == <span class="d_string">"Hello"</span>);
baz(s, 2);
<span class="d_keyword">assert</span>(s == <span class="d_string">"HelloHello"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".splitter"></a>auto <a name="splitter"></a><span class="ddoc_psymbol">splitter</span>(Range, Separator)(Range <i>r</i>, Separator <i>s</i>) if (is(typeof(ElementType!Range.init == Separator.init)) &amp;&amp; (hasSlicing!Range &amp;&amp; hasLength!Range || isNarrowString!Range));
</dt>
<dd>Splits a range using an element as a separator. This can be used with
any narrow string type or sliceable range type, but is most popular
with string types.
<p></p>
Two adjacent separators are considered to surround an empty element in
the split range.
<p></p>

If the empty range is given, the result is a range with one empty
element. If a range with one separator is given, the result is a range
with two empty elements.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(equal(<span class="d_psymbol">splitter</span>(<span class="d_string">"hello  world"</span>, ' '), [ <span class="d_string">"hello"</span>, <span class="d_string">""</span>, <span class="d_string">"world"</span> ]));
<span class="d_keyword">int</span>[] a = [ 1, 2, 0, 0, 3, 0, 4, 5, 0 ];
<span class="d_keyword">int</span>[][] w = [ [1, 2], [], [3], [4, 5] ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">splitter</span>(a, 0), w));
a = <span class="d_keyword">null</span>;
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">splitter</span>(a, 0), [ (<span class="d_keyword">int</span>[]).init ]));
a = [ 0 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">splitter</span>(a, 0), [ (<span class="d_keyword">int</span>[]).init, (<span class="d_keyword">int</span>[]).init ]));
a = [ 0, 1 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">splitter</span>(a, 0), [ [], [1] ]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".splitter"></a>auto <a name="splitter"></a><span class="ddoc_psymbol">splitter</span>(Range, Separator)(Range <i>r</i>, Separator <i>s</i>) if (is(typeof(Range.init.front == Separator.init.front) : bool) &amp;&amp; (hasSlicing!Range || isNarrowString!Range) &amp;&amp; isForwardRange!Separator &amp;&amp; (hasLength!Separator || isNarrowString!Separator));
</dt>
<dd>Splits a range using another range as a separator. This can be used
with any narrow string type or sliceable range type, but is most popular
with string types.<p></p>

</dd>
<dt class="d_decl"><a name=".joiner"></a>auto <a name="joiner"></a><span class="ddoc_psymbol">joiner</span>(RoR, Separator)(RoR <i>r</i>, Separator <i>sep</i>) if (isInputRange!RoR &amp;&amp; isInputRange!(ElementType!RoR) &amp;&amp; isForwardRange!Separator &amp;&amp; is(ElementType!Separator : ElementType!(ElementType!RoR)));
<br><a name=".joiner"></a>auto <a name="joiner"></a><span class="ddoc_psymbol">joiner</span>(RoR)(RoR <i>r</i>) if (isInputRange!RoR &amp;&amp; isInputRange!(ElementType!RoR));
</dt>
<dd>Lazily joins a range of ranges with a separator. The separator itself
is a range. If you do not provide a separator, then the ranges are
joined directly without anything in between them.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">""</span>], <span class="d_string">"xyz"</span>), <span class="d_string">""</span>));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">""</span>, <span class="d_string">""</span>], <span class="d_string">"xyz"</span>), <span class="d_string">"xyz"</span>));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">""</span>, <span class="d_string">"abc"</span>], <span class="d_string">"xyz"</span>), <span class="d_string">"xyzabc"</span>));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">"abc"</span>, <span class="d_string">""</span>], <span class="d_string">"xyz"</span>), <span class="d_string">"abcxyz"</span>));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">"abc"</span>, <span class="d_string">"def"</span>], <span class="d_string">"xyz"</span>), <span class="d_string">"abcxyzdef"</span>));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">"Mary"</span>, <span class="d_string">"has"</span>, <span class="d_string">"a"</span>, <span class="d_string">"little"</span>, <span class="d_string">"lamb"</span>], <span class="d_string">"..."</span>),
  <span class="d_string">"Mary...has...a...little...lamb"</span>));
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">joiner</span>([<span class="d_string">"abc"</span>, <span class="d_string">"def"</span>]), <span class="d_string">"abcdef"</span>));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".uniq"></a>auto <a name="uniq"></a><span class="ddoc_psymbol">uniq</span>(alias pred = "a == b", Range)(Range <i>r</i>) if (isInputRange!Range &amp;&amp; is(typeof(binaryFun!pred(<i>r</i>.front, <i>r</i>.front)) == bool));
</dt>
<dd>Iterates unique consecutive elements of the given range (functionality
akin to the <a href="http://wikipedia.org/wiki/Uniq">uniq</a> system
utility). Equivalence of elements is assessed by using the predicate
<span class="d_inlinecode">pred</span>, by default <span class="d_inlinecode">"a == b"</span>. If the given range is
bidirectional, <span class="d_inlinecode"><a name="uniq"></a><span class="ddoc_psymbol">uniq</span></span> also yields a bidirectional range.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
<span class="d_keyword">assert</span>(equal(<span class="d_psymbol">uniq</span>(arr), [ 1, 2, 3, 4, 5 ][]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".Group"></a>struct <a name="Group"></a><span class="ddoc_psymbol">Group</span>(alias pred, R) if (isInputRange!R);
<br><a name=".group"></a>Group!(pred, Range) <a name="group"></a><span class="ddoc_psymbol">group</span>(alias pred = "a == b", Range)(Range <i>r</i>);
</dt>
<dd>Similarly to <span class="d_inlinecode">uniq</span>, <span class="d_inlinecode">group</span> iterates unique consecutive
elements of the given range. The element type is <span class="d_inlinecode">Tuple!(ElementType!R, uint)</span> because it includes the count of
equivalent elements seen. Equivalence of elements is assessed by using
the predicate <span class="d_inlinecode">pred</span>, by default <span class="d_inlinecode">"a == b"</span>.
<p></p>
<span class="d_inlinecode"><a name="Group"></a><span class="ddoc_psymbol">Group</span></span> is an input range if <span class="d_inlinecode">R</span> is an input range, and a
forward range in all other cases.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [ 1, 2, 2, 2, 2, 3, 4, 4, 4, 5 ];
<span class="d_keyword">assert</span>(equal(group(arr), [ tuple(1, 1u), tuple(2, 4u), tuple(3, 1u),
    tuple(4, 3u), tuple(5, 1u) ][]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".find"></a>R <a name="find"></a><span class="ddoc_psymbol">find</span>(alias pred = "a == b", R, E)(R <i>haystack</i>, E <i>needle</i>) if (isInputRange!R &amp;&amp; is(typeof(binaryFun!pred(<i>haystack</i>.front, <i>needle</i>)) : bool));
</dt>
<dd>Finds an individual element in an input range. Elements of <span class="d_inlinecode">haystack</span> are compared with <span class="d_inlinecode">needle</span> by using predicate <span class="d_inlinecode">pred</span>. Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">walkLength(haystack)</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">pred</span>. See also <a href="http://sgi.com/tech/stl/find.html">STL's find</a>.
<p></p>
To find the last occurence of <span class="d_inlinecode">needle</span> in <span class="d_inlinecode">haystack</span>, call <span class="d_inlinecode"><a name="find"></a><span class="ddoc_psymbol">find</span>(retro(haystack), needle)</span>. See also <a href="std_range.html#retro"><span class="d_inlinecode">std.range.retro</span></a>.

<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>R haystack</td>
<td valign=top>The range searched in.</td></tr>
<tr><td valign=top>E needle</td>
<td valign=top>The element searched for.</td></tr>
</table><p></p>
<b>Constraints:</b><br>
<span class="d_inlinecode">isInputRange!R &amp;&amp; is(typeof(binaryFun!pred(haystack.front, needle)
: bool))</span>

<p></p>
<b>Returns:</b><br><span class="d_inlinecode">haystack</span> advanced such that <span class="d_inlinecode">binaryFun!pred(haystack.front,
needle)</span> is <span class="d_inlinecode"><b>true</b></span> (if no such position exists, returns <span class="d_inlinecode">haystack</span> after exhaustion).

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(<span class="d_string">"hello, world"</span>, ',') == <span class="d_string">", world"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>([1, 2, 3, 5], 4) == []);
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(SList!<span class="d_keyword">int</span>(1, 2, 3, 4, 5)[], 4) == SList!<span class="d_keyword">int</span>(4, 5)[]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>!<span class="d_string">"a &gt; b"</span>([1, 2, 3, 5], 2) == [3, 5]);

<span class="d_keyword">auto</span> a = [ 1, 2, 3 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(a, 5).empty);       <span class="d_comment">// not found
</span><span class="d_keyword">assert</span>(!<span class="d_psymbol">find</span>(a, 2).empty);      <span class="d_comment">// found
</span>
<span class="d_comment">// Case-insensitive find of a string
</span>string[] s = [ <span class="d_string">"Hello"</span>, <span class="d_string">"world"</span>, <span class="d_string">"!"</span> ];
<span class="d_keyword">assert</span>(!<span class="d_psymbol">find</span>!(<span class="d_string">"toLower(a) == b"</span>)(s, <span class="d_string">"hello"</span>).empty);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".find"></a>R1 <a name="find"></a><span class="ddoc_psymbol">find</span>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(binaryFun!pred(<i>haystack</i>.front, <i>needle</i>.front)) : bool) &amp;&amp; !isRandomAccessRange!R1);
</dt>
<dd>Finds a forward range in another. Elements are compared for
equality. Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">walkLength(haystack) * walkLength(needle)</span><b><i>)</i></b>
comparisons in the worst case. Specializations taking advantage of
bidirectional or random access (where present) may accelerate search
depending on the statistics of the two ranges' content.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>R1 haystack</td>
<td valign=top>The range searched in.</td></tr>
<tr><td valign=top>R2 needle</td>
<td valign=top>The range searched for.</td></tr>
</table><p></p>
<b>Constraints:</b><br>
<span class="d_inlinecode">isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp;
is(typeof(binaryFun!pred(haystack.front, needle.front) : bool))</span>

<p></p>
<b>Returns:</b><br><span class="d_inlinecode">haystack</span> advanced such that <span class="d_inlinecode">needle</span> is a prefix of it (if no
such position exists, returns <span class="d_inlinecode">haystack</span> advanced to termination).
<p></p>

<pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(<span class="d_string">"hello, world"</span>, <span class="d_string">"World"</span>).empty);
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(<span class="d_string">"hello, world"</span>, <span class="d_string">"wo"</span>) == <span class="d_string">"world"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>([1, 2, 3, 4], SList!(2, 3)[]) == [2, 3, 4]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".find"></a>Tuple!(Range, size_t) <a name="find"></a><span class="ddoc_psymbol">find</span>(alias pred = "a == b", Range, Ranges...)(Range <i>haystack</i>, Ranges <i>needles</i>) if (Ranges.length &gt; 1 &amp;&amp; is(typeof(startsWith!pred(<i>haystack</i>, <i>needles</i>))));
<br><a name=".BoyerMooreFinder"></a>struct <a name="BoyerMooreFinder"></a><span class="ddoc_psymbol">BoyerMooreFinder</span>(alias pred, Range);
<br><a name=".boyerMooreFinder"></a>BoyerMooreFinder!(binaryFun!pred, Range) <a name="boyerMooreFinder"></a><span class="ddoc_psymbol">boyerMooreFinder</span>(alias pred = "a == b", Range)(Range <i>needle</i>) if (isRandomAccessRange!Range || isSomeString!Range);
</dt>
<dd>Finds two or more <span class="d_inlinecode">needles</span> into a <span class="d_inlinecode">haystack</span>. The predicate <span class="d_inlinecode">pred</span> is used throughout to compare elements. By default, elements are
compared for equality.
<p></p>
<b>Parameters:</b><table class=parms><tr><td valign=top>Range haystack</td>
<td valign=top>The target of the search. Must be an <a href="../glossary.html#input
range">input
range</a>
. If any of <span class="d_inlinecode">needles</span> is a range with elements comparable to
elements in <span class="d_inlinecode">haystack</span>, then <span class="d_inlinecode">haystack</span> must be a <a href="../glossary.html#forward range">forward range</a>
 such that the search can backtrack.</td></tr>
<tr><td valign=top>Ranges needles</td>
<td valign=top>One or more items to search for. Each of <span class="d_inlinecode">needles</span> must
be either comparable to one element in <span class="d_inlinecode">haystack</span>, or be itself a
<a href="../glossary.html#forward range">forward range</a>
 with elements comparable with elements in
<span class="d_inlinecode">haystack</span>.</td></tr>
</table><p></p>
<b>Returns:</b><br>A tuple containing <span class="d_inlinecode">haystack</span> positioned to match one of the
needles and also the 1-based index of the matching element in <span class="d_inlinecode">needles</span> (0 if none of <span class="d_inlinecode">needles</span> matched, 1 if <span class="d_inlinecode">needles[0]</span>
matched, 2 if <span class="d_inlinecode">needles[1]</span> matched...). The first needle to be found
will be the one that matches. If multiple needles are found at the
same spot in the range, then the shortest one is the one which matches
(if multiple needles of the same length are found at the same spot (e.g
<span class="d_inlinecode">"a"</span> and <span class="d_inlinecode">'a'</span>), then the left-most of them in the argument list
matches).
<p></p>

The relationship between <span class="d_inlinecode">haystack</span> and <span class="d_inlinecode">needles</span> simply means
that one can e.g. search for individual <span class="d_inlinecode">int</span>s or arrays of <span class="d_inlinecode">int</span>s in an array of <span class="d_inlinecode">int</span>s. In addition, if elements are
individually comparable, searches of heterogeneous types are allowed
as well: a <span class="d_inlinecode">double[]</span> can be searched for an <span class="d_inlinecode">int</span> or a <span class="d_inlinecode">short[]</span>, and conversely a <span class="d_inlinecode">long</span> can be searched for a <span class="d_inlinecode">float</span>
or a <span class="d_inlinecode">double[]</span>. This makes for efficient searches without the need
to coerce one side of the comparison into the other's side type.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 4, 2, 3 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(a, 4) == [ 4, 2, 3 ]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(a, [ 1, 4 ]) == [ 1, 4, 2, 3 ]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(a, [ 1, 3 ], 4) == tuple([ 4, 2, 3 ], 2));
<span class="d_comment">// Mixed types allowed if comparable
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>(a, 5, [ 1.2, 3.5 ], 2.0, [ 1 ]) == tuple([ 2, 3 ], 3));
</pre>
<p></p>

The complexity of the search is <b><i>&Omicron;</i>(</b><span class="d_inlinecode">haystack.length *
max(needles.length)</span><b><i>)</i></b>. (For needles that are individual items, length
is considered to be 1.) The strategy used in searching several
subranges at once maximizes cache usage by moving in <span class="d_inlinecode">haystack</span> as
few times as possible.<p></p>

</dd>
<dt class="d_decl"><a name=".find"></a>Range <a name="find"></a><span class="ddoc_psymbol">find</span>(alias pred, Range)(Range <i>haystack</i>) if (isInputRange!Range);
</dt>
<dd>Advances the input range <span class="d_inlinecode">haystack</span> by calling <span class="d_inlinecode">haystack.popFront</span>
until either <span class="d_inlinecode">pred(haystack.front)</span>, or <span class="d_inlinecode">haystack.empty</span>. Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">haystack.length</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">pred</span>. See also <a href="http://sgi.com/tech/stl/find_if.html">STL's find_if</a>.
<p></p>
To <a name="find"></a><span class="ddoc_psymbol">find</span> the last element of a bidirectional <span class="d_inlinecode">haystack</span> satisfying
<span class="d_inlinecode">pred</span>, call <span class="d_inlinecode"><a name="find"></a><span class="ddoc_psymbol">find</span>!(pred)(retro(haystack))</span>. See also <a href="std_range.html#retro"><span class="d_inlinecode">std.range.retro</span></a>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> arr = [ 1, 2, 3, 4, 1 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>!(<span class="d_string">"a &gt; 2"</span>)(arr) == [ 3, 4, 1 ]);

<span class="d_comment">// with predicate alias
</span><span class="d_keyword">bool</span> pred(<span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x + 1 &gt; 1.5; }
<span class="d_keyword">assert</span>(<span class="d_psymbol">find</span>!(pred)(arr) == arr);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".findSkip"></a>bool <a name="findSkip"></a><span class="ddoc_psymbol">findSkip</span>(alias pred = "a == b", R1, R2)(ref R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(binaryFun!pred(<i>haystack</i>.front, <i>needle</i>.front))));
</dt>
<dd>If <span class="d_inlinecode">needle</span> occurs in <span class="d_inlinecode">haystack</span>, positions <span class="d_inlinecode">haystack</span>
 right after the first occurrence of <span class="d_inlinecode">needle</span> and returns <span class="d_inlinecode"><b>true</b></span>. Otherwise, leaves <span class="d_inlinecode">haystack</span> as is and returns <span class="d_inlinecode"><b>false</b></span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code">string s = <span class="d_string">"abcdef"</span>;
<span class="d_keyword">assert</span>(<span class="d_psymbol">findSkip</span>(s, <span class="d_string">"cd"</span>) &amp;&amp; s == <span class="d_string">"ef"</span>);
s = <span class="d_string">"abcdef"</span>;
<span class="d_keyword">assert</span>(!<span class="d_psymbol">findSkip</span>(s, <span class="d_string">"cxd"</span>) &amp;&amp; s == <span class="d_string">"abcdef"</span>);
<span class="d_keyword">assert</span>(<span class="d_psymbol">findSkip</span>(s, <span class="d_string">"def"</span>) &amp;&amp; s.empty);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".findSplit"></a>auto <a name="findSplit"></a><span class="ddoc_psymbol">findSplit</span>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; isForwardRange!R2);
<br><a name=".findSplitBefore"></a>auto <a name="findSplitBefore"></a><span class="ddoc_psymbol">findSplitBefore</span>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; isForwardRange!R2);
<br><a name=".findSplitAfter"></a>auto <a name="findSplitAfter"></a><span class="ddoc_psymbol">findSplitAfter</span>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; isForwardRange!R2);
</dt>
<dd>These functions find the first occurrence of <span class="d_inlinecode">needle</span> in <span class="d_inlinecode">haystack</span> and then split <span class="d_inlinecode">haystack</span> as follows.
<p></p>
<span class="d_inlinecode"><a name="findSplit"></a><span class="ddoc_psymbol">findSplit</span></span> returns a tuple <span class="d_inlinecode">result</span> containing <i>three</i>
ranges. <span class="d_inlinecode">result[0]</span> is the portion of <span class="d_inlinecode">haystack</span> before <span class="d_inlinecode">needle</span>, <span class="d_inlinecode">result[1]</span> is the portion of <span class="d_inlinecode">haystack</span> that matches
<span class="d_inlinecode">needle</span>, and <span class="d_inlinecode">result[2]</span> is the portion of <span class="d_inlinecode">haystack</span> after
the match. If <span class="d_inlinecode">needle</span> was not found, <span class="d_inlinecode">result[0]</span>
comprehends <span class="d_inlinecode">haystack</span> entirely and <span class="d_inlinecode">result[1]</span> and <span class="d_inlinecode">result[2]</span>
are empty.
<p></p>

<span class="d_inlinecode">findSplitBefore</span> returns a tuple <span class="d_inlinecode">result</span> containing two
ranges. <span class="d_inlinecode">result[0]</span> is the portion of <span class="d_inlinecode">haystack</span> before <span class="d_inlinecode">needle</span>, and <span class="d_inlinecode">result[1]</span> is the balance of <span class="d_inlinecode">haystack</span> starting
with the match. If <span class="d_inlinecode">needle</span> was not found, <span class="d_inlinecode">result[0]</span>
comprehends <span class="d_inlinecode">haystack</span> entirely and <span class="d_inlinecode">result[1]</span> is empty.
<p></p>

<span class="d_inlinecode">findSplitAfter</span> returns a tuple <span class="d_inlinecode">result</span> containing two ranges.
<span class="d_inlinecode">result[0]</span> is the portion of <span class="d_inlinecode">haystack</span> up to and including the
match, and <span class="d_inlinecode">result[1]</span> is the balance of <span class="d_inlinecode">haystack</span> starting
after the match. If <span class="d_inlinecode">needle</span> was not found, <span class="d_inlinecode">result[0]</span> is empty
and <span class="d_inlinecode">result[1]</span> is <span class="d_inlinecode">haystack</span>.
<p></p>

In all cases, the concatenation of the returned ranges spans the
entire <span class="d_inlinecode">haystack</span>.
<p></p>

If <span class="d_inlinecode">haystack</span> is a random-access range, all three components of the
tuple have the same type as <span class="d_inlinecode">haystack</span>. Otherwise, <span class="d_inlinecode">haystack</span>
must be a forward range and the type of <span class="d_inlinecode">result[0]</span> and <span class="d_inlinecode">result[1]</span> is the same as <a href="std_range.html#takeExactly"><span class="d_inlinecode">std.range.takeExactly</span></a>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> a = <span class="d_string">"Carl Sagan Memorial Station"</span>;
<span class="d_keyword">auto</span> r = <span class="d_psymbol">findSplit</span>(a, <span class="d_string">"Velikovsky"</span>);
<span class="d_keyword">assert</span>(r[0] == a);
<span class="d_keyword">assert</span>(r[1].empty);
<span class="d_keyword">assert</span>(r[2].empty);
r = <span class="d_psymbol">findSplit</span>(a, <span class="d_string">" "</span>);
<span class="d_keyword">assert</span>(r[0] == <span class="d_string">"Carl"</span>);
<span class="d_keyword">assert</span>(r[1] == <span class="d_string">" "</span>);
<span class="d_keyword">assert</span>(r[2] == <span class="d_string">"Sagan Memorial Station"</span>);
<span class="d_keyword">auto</span> r1 = findSplitBefore(a, <span class="d_string">"Sagan"</span>);
<span class="d_keyword">assert</span>(r1[0] == <span class="d_string">"Carl "</span>, r1[0]);
<span class="d_keyword">assert</span>(r1[1] == <span class="d_string">"Sagan Memorial Station"</span>);
<span class="d_keyword">auto</span> r2 = findSplitAfter(a, <span class="d_string">"Sagan"</span>);
<span class="d_keyword">assert</span>(r2[0] == <span class="d_string">"Carl Sagan"</span>);
<span class="d_keyword">assert</span>(r2[1] == <span class="d_string">" Memorial Station"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".countUntil"></a>ptrdiff_t <a name="countUntil"></a><span class="ddoc_psymbol">countUntil</span>(alias pred = "a == b", R, Rs...)(R <i>haystack</i>, Rs <i>needles</i>) if (isForwardRange!R &amp;&amp; Rs.length &gt; 0 &amp;&amp; isForwardRange!(Rs[0]) == isInputRange!(Rs[0]) &amp;&amp; is(typeof(startsWith!pred(<i>haystack</i>, <i>needles</i>[0]))) &amp;&amp; (Rs.length == 1 || is(typeof(<a name="countUntil"></a><span class="ddoc_psymbol">countUntil</span>!pred(<i>haystack</i>, <i>needles</i>[1..__dollar])))));
<br><a name=".countUntil"></a>ptrdiff_t <a name="countUntil"></a><span class="ddoc_psymbol">countUntil</span>(alias pred = "a == b", R, N)(R <i>haystack</i>, N <i>needle</i>) if (isInputRange!R &amp;&amp; is(typeof(binaryFun!pred(<i>haystack</i>.front, <i>needle</i>)) : bool));
</dt>
<dd>Returns the number of elements which must be popped from the front of
    <span class="d_inlinecode">haystack</span> before reaching an element for which
    <span class="d_inlinecode">startsWith!pred(haystack, needles)</span> is <span class="d_inlinecode"><b>true</b></span>. If
    <span class="d_inlinecode">startsWith!pred(haystack, needles)</span> is not <span class="d_inlinecode"><b>true</b></span> for any element in
    <span class="d_inlinecode">haystack</span>, then <span class="d_inlinecode">-1</span> is returned.
<p></p>
<span class="d_inlinecode">needles</span> may be either an element or a range.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">"hello world"</span>, <span class="d_string">"world"</span>) == 6);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">"hello world"</span>, 'r') == 8);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">"hello world"</span>, <span class="d_string">"programming"</span>) == -1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">""</span>, <span class="d_string">""</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">""</span>, '')   == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">""</span>, <span class="d_string">""</span>) == -1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>(<span class="d_string">""</span>, '') == -1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>([0, 7, 12, 22, 9], [12, 22]) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>([0, 7, 12, 22, 9], 9) == 4);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>!<span class="d_string">"a &gt; b"</span>([0, 7, 12, 22, 9], 20) == 3);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".countUntil"></a>ptrdiff_t <a name="countUntil"></a><span class="ddoc_psymbol">countUntil</span>(alias pred, R)(R <i>haystack</i>) if (isInputRange!R &amp;&amp; is(typeof(unaryFun!pred(<i>haystack</i>.front)) : bool));
</dt>
<dd>Returns the number of elements which must be popped from <span class="d_inlinecode">haystack</span>
    before <span class="d_inlinecode">pred(haystack.front)</span> is <span class="d_inlinecode"><b>true</b></span>.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>!(std.uni.isWhite)(<span class="d_string">"hello world"</span>) == 5);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>!(std.ascii.isDigit)(<span class="d_string">"hello world"</span>) == -1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">countUntil</span>!<span class="d_string">"a &gt; 20"</span>([0, 7, 12, 22, 9]) == 3);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".OpenRight"></a>enum <a name="OpenRight"></a><span class="ddoc_psymbol">OpenRight</span>: int;
</dt>
<dd>Interval option specifier for <span class="d_inlinecode">until</span> (below) and others.<p></p>

<dl><dt class="d_decl"><a name=".OpenRight.no"></a><a name="no"></a><span class="ddoc_psymbol">no</span></dt>
<dd>Interval is closed to the right (last element included)<p></p>

</dd>
<dt class="d_decl"><a name=".OpenRight.yes"></a><a name="yes"></a><span class="ddoc_psymbol">yes</span></dt>
<dd>Interval is open to the right (last element is not included)<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".Until"></a>struct <a name="Until"></a><span class="ddoc_psymbol">Until</span>(alias pred, Range, Sentinel) if (isInputRange!Range);
<br><a name=".until"></a>Until!(pred, Range, Sentinel) <a name="until"></a><span class="ddoc_psymbol">until</span>(alias pred = "a == b", Range, Sentinel)(Range <i>range</i>, Sentinel <i>sentinel</i>, OpenRight <i>openRight</i> = OpenRight.yes) if (!is(Sentinel == OpenRight));
<br><a name=".until"></a>Until!(pred, Range, void) <a name="until"></a><span class="ddoc_psymbol">until</span>(alias pred, Range)(Range <i>range</i>, OpenRight <i>openRight</i> = OpenRight.yes);
</dt>
<dd>Lazily iterates <span class="d_inlinecode">range</span> until value <span class="d_inlinecode">sentinel</span> is found, at
which point it stops.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 7, 7, 2, 4, 7, 3, 5];
<span class="d_keyword">assert</span>(equal(a.until(7), [1, 2, 4][]));
<span class="d_keyword">assert</span>(equal(a.until(7, OpenRight.no), [1, 2, 4, 7][]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".startsWith"></a>uint <a name="startsWith"></a><span class="ddoc_psymbol">startsWith</span>(alias pred = "a == b", Range, Needles...)(Range <i>doesThisStart</i>, Needles <i>withOneOfThese</i>) if (isInputRange!Range &amp;&amp; Needles.length &gt; 1 &amp;&amp; is(typeof(.<a name="startsWith"></a><span class="ddoc_psymbol">startsWith</span>!pred(<i>doesThisStart</i>, <i>withOneOfThese</i>[0])) : bool) &amp;&amp; is(typeof(.<a name="startsWith"></a><span class="ddoc_psymbol">startsWith</span>!pred(<i>doesThisStart</i>, <i>withOneOfThese</i>[1..__dollar])) : uint));
<br><a name=".startsWith"></a>bool <a name="startsWith"></a><span class="ddoc_psymbol">startsWith</span>(alias pred = "a == b", R1, R2)(R1 <i>doesThisStart</i>, R2 <i>withThis</i>) if (isInputRange!R1 &amp;&amp; isInputRange!R2 &amp;&amp; is(typeof(binaryFun!pred(<i>doesThisStart</i>.front, <i>withThis</i>.front)) : bool));
<br><a name=".startsWith"></a>bool <a name="startsWith"></a><span class="ddoc_psymbol">startsWith</span>(alias pred = "a == b", R, E)(R <i>doesThisStart</i>, E <i>withThis</i>) if (isInputRange!R &amp;&amp; is(typeof(binaryFun!pred(<i>doesThisStart</i>.front, <i>withThis</i>)) : bool));
</dt>
<dd>If the range <span class="d_inlinecode">doesThisStart</span> starts with <i>any</i> of the <span class="d_inlinecode">withOneOfThese</span> ranges or elements, returns 1 if it starts with <span class="d_inlinecode">withOneOfThese[0]</span>, 2 if it starts with <span class="d_inlinecode">withOneOfThese[1]</span>, and so
on. If none match, returns 0. In the case where <span class="d_inlinecode">doesThisStart</span> starts
with multiple of the ranges or elements in <span class="d_inlinecode">withOneOfThese</span>, then the
shortest one matches (if there are two which match which are of the same
length (e.g. <span class="d_inlinecode">"a"</span> and <span class="d_inlinecode">'a'</span>), then the left-most of them in the argument
list matches).
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">""</span>));
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"a"</span>));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"b"</span>));
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, 'a', <span class="d_string">"b"</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"b"</span>, <span class="d_string">"a"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"a"</span>, <span class="d_string">"a"</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"ab"</span>, <span class="d_string">"a"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"a"</span>, <span class="d_string">"b"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aa"</span>, <span class="d_string">"ab"</span>) == 3);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aaa"</span>, <span class="d_string">"sab"</span>) == 0);
<span class="d_keyword">assert</span>(<span class="d_psymbol">startsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aaa"</span>, <span class="d_string">"a"</span>, <span class="d_string">"sab"</span>) == 3);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".skipOver"></a>bool <a name="skipOver"></a><span class="ddoc_psymbol">skipOver</span>(alias pred = "a == b", R1, R2)(ref R1 <i>r1</i>, R2 <i>r2</i>) if (is(typeof(binaryFun!pred(<i>r1</i>.front, <i>r2</i>.front))));
</dt>
<dd>If <span class="d_inlinecode">startsWith(r1, r2)</span>, consume the corresponding elements off <span class="d_inlinecode">r1</span> and return <span class="d_inlinecode"><b>true</b></span>. Otherwise, leave <span class="d_inlinecode">r1</span> unchanged and
return <span class="d_inlinecode"><b>false</b></span>.<p></p>

</dd>
<dt class="d_decl"><a name=".skipOver"></a>bool <a name="skipOver"></a><span class="ddoc_psymbol">skipOver</span>(alias pred = "a == b", R, E)(ref R <i>r</i>, E <i>e</i>) if (is(typeof(binaryFun!pred(<i>r</i>.front, <i>e</i>))));
</dt>
<dd>Checks whether a range starts with an element, and if so, consume that
element off <span class="d_inlinecode">r</span> and return <span class="d_inlinecode"><b>true</b></span>. Otherwise, leave <span class="d_inlinecode">r</span>
unchanged and return <span class="d_inlinecode"><b>false</b></span>.<p></p>

</dd>
<dt class="d_decl"><a name=".endsWith"></a>uint <a name="endsWith"></a><span class="ddoc_psymbol">endsWith</span>(alias pred = "a == b", Range, Needles...)(Range <i>doesThisEnd</i>, Needles <i>withOneOfThese</i>) if (isBidirectionalRange!Range &amp;&amp; Needles.length &gt; 1 &amp;&amp; is(typeof(.<a name="endsWith"></a><span class="ddoc_psymbol">endsWith</span>!pred(<i>doesThisEnd</i>, <i>withOneOfThese</i>[0])) : bool) &amp;&amp; is(typeof(.<a name="endsWith"></a><span class="ddoc_psymbol">endsWith</span>!pred(<i>doesThisEnd</i>, <i>withOneOfThese</i>[1..__dollar])) : uint));
<br><a name=".endsWith"></a>bool <a name="endsWith"></a><span class="ddoc_psymbol">endsWith</span>(alias pred = "a == b", R1, R2)(R1 <i>doesThisEnd</i>, R2 <i>withThis</i>) if (isBidirectionalRange!R1 &amp;&amp; isBidirectionalRange!R2 &amp;&amp; is(typeof(binaryFun!pred(<i>doesThisEnd</i>.back, <i>withThis</i>.back)) : bool));
<br><a name=".endsWith"></a>bool <a name="endsWith"></a><span class="ddoc_psymbol">endsWith</span>(alias pred = "a == b", R, E)(R <i>doesThisEnd</i>, E <i>withThis</i>) if (isBidirectionalRange!R &amp;&amp; is(typeof(binaryFun!pred(<i>doesThisEnd</i>.back, <i>withThis</i>)) : bool));
</dt>
<dd>The reciprocal of <span class="d_inlinecode">startsWith</span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">""</span>));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"b"</span>));
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"a"</span>, 'c') == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"c"</span>, <span class="d_string">"a"</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"c"</span>, <span class="d_string">"c"</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"bc"</span>, <span class="d_string">"c"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"c"</span>, <span class="d_string">"b"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aa"</span>, <span class="d_string">"bc"</span>) == 3);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aaa"</span>, <span class="d_string">"sab"</span>) == 0);
<span class="d_keyword">assert</span>(<span class="d_psymbol">endsWith</span>(<span class="d_string">"abc"</span>, <span class="d_string">"x"</span>, <span class="d_string">"aaa"</span>, 'c', <span class="d_string">"sab"</span>) == 3);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".commonPrefix"></a>auto <a name="commonPrefix"></a><span class="ddoc_psymbol">commonPrefix</span>(alias pred = "a == b", R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>) if (isForwardRange!R1 &amp;&amp; isInputRange!R2 &amp;&amp; !isNarrowString!R1 &amp;&amp; is(typeof(binaryFun!pred(<i>r1</i>.front, <i>r2</i>.front))));
</dt>
<dd>Returns the common prefix of two ranges. Example:
<p></p>
<pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">commonPrefix</span>(<span class="d_string">"hello, world"</span>, <span class="d_string">"hello, there"</span>) == <span class="d_string">"hello, "</span>);
</pre>
<p></p>

If the first argument is a string, then the result is a slice of <span class="d_inlinecode">r1</span> which
contains the characters that both ranges start with. For all other types, the
type of the result is the same as the result of <span class="d_inlinecode">takeExactly(r1, n)</span>, where
<span class="d_inlinecode">n</span> is the number of elements that both ranges start with.

<p></p>
<b>See Also:</b><br><a href="std_range.html#takeExactly"><span class="d_inlinecode">std.range.takeExactly</span></a><p></p>

</dd>
<dt class="d_decl"><a name=".findAdjacent"></a>Range <a name="findAdjacent"></a><span class="ddoc_psymbol">findAdjacent</span>(alias pred = "a == b", Range)(Range <i>r</i>) if (isForwardRange!Range);
</dt>
<dd>Advances <span class="d_inlinecode">r</span> until it finds the first two adjacent elements <span class="d_inlinecode">a</span>,
<span class="d_inlinecode">b</span> that satisfy <span class="d_inlinecode">pred(a, b)</span>. Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length</span><b><i>)</i></b>
evaluations of <span class="d_inlinecode">pred</span>. See also <a href="http://sgi.com/tech/stl/adjacent_find.html">STL's adjacent_find</a>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 11, 10, 10, 9, 8, 8, 7, 8, 9 ];
<span class="d_keyword">auto</span> r = <span class="d_psymbol">findAdjacent</span>(a);
<span class="d_keyword">assert</span>(r == [ 10, 10, 9, 8, 8, 7, 8, 9 ]);
p = <span class="d_psymbol">findAdjacent</span>!(<span class="d_string">"a &lt; b"</span>)(a);
<span class="d_keyword">assert</span>(p == [ 7, 8, 9 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".findAmong"></a>Range1 <a name="findAmong"></a><span class="ddoc_psymbol">findAmong</span>(alias pred = "a == b", Range1, Range2)(Range1 <i>seq</i>, Range2 <i>choices</i>) if (isInputRange!Range1 &amp;&amp; isForwardRange!Range2);
</dt>
<dd>Advances <span class="d_inlinecode">seq</span> by calling <span class="d_inlinecode">seq.popFront</span> until either <span class="d_inlinecode">find!(pred)(choices, seq.front)</span> is <span class="d_inlinecode"><b>true</b></span>, or <span class="d_inlinecode">seq</span> becomes
empty. Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">seq.length * choices.length</span><b><i>)</i></b> evaluations of
<span class="d_inlinecode">pred</span>. See also <a href="http://sgi.com/tech/stl/find_first_of.html">STL's
find_first_of</a>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ -1, 0, 1, 2, 3, 4, 5 ];
<span class="d_keyword">int</span>[] b = [ 3, 1, 2 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">findAmong</span>(a, b) == a[2 .. $]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".count"></a>size_t <a name="count"></a><span class="ddoc_psymbol">count</span>(alias pred = "a == b", Range, E)(Range <i>haystack</i>, E <i>needle</i>) if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(<i>haystack</i>.front, <i>needle</i>)) : bool));
<br><a name=".count"></a>size_t <a name="count"></a><span class="ddoc_psymbol">count</span>(alias pred = "a == b", R1, R2)(R1 <i>haystack</i>, R2 <i>needle</i>) if (isForwardRange!R1 &amp;&amp; !isInfinite!R1 &amp;&amp; isForwardRange!R2 &amp;&amp; is(typeof(binaryFun!pred(<i>haystack</i>.front, <i>needle</i>.front)) : bool));
<br><a name=".count"></a>size_t <a name="count"></a><span class="ddoc_psymbol">count</span>(alias pred = "true", R)(R <i>haystack</i>) if (isInputRange!R &amp;&amp; !isInfinite!R &amp;&amp; is(typeof(unaryFun!pred(<i>haystack</i>.front)) : bool));
</dt>
<dd>The first version counts the number of elements <span class="d_inlinecode">x</span> in <span class="d_inlinecode">r</span> for
which <span class="d_inlinecode">pred(x, value)</span> is <span class="d_inlinecode"><b>true</b></span>. <span class="d_inlinecode">pred</span> defaults to
equality. Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">pred</span>.
<p></p>
The second version returns the number of times <span class="d_inlinecode">needle</span> occurs in
<span class="d_inlinecode">haystack</span>. Throws an exception if <span class="d_inlinecode">needle.empty</span>, as the count
of the empty range in any range would be infinite. Overlapped counts
are not considered, for example <span class="d_inlinecode"><a name="count"></a><span class="ddoc_psymbol">count</span>("aaa", "aa")</span> is <span class="d_inlinecode">1</span>, not
<span class="d_inlinecode">2</span>.
<p></p>

The third version counts the elements for which <span class="d_inlinecode">pred(x)</span> is <span class="d_inlinecode"><b>true</b></span>. Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">pred</span>.

<p></p>
<b>Note:</b><br>
Regardless of the overload, <span class="d_inlinecode"><a name="count"></a><span class="ddoc_psymbol">count</span></span> will not accept
infinite ranges for <span class="d_inlinecode">haystack</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// count elements in range
</span><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 3, 2, 5, 3, 2, 4 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>(a, 2) == 3);
<span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>!(<span class="d_string">"a &gt; b"</span>)(a, 2) == 5);
<span class="d_comment">// count range in range
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>(<span class="d_string">"abcadfabf"</span>, <span class="d_string">"ab"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>(<span class="d_string">"ababab"</span>, <span class="d_string">"abab"</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>(<span class="d_string">"ababab"</span>, <span class="d_string">"abx"</span>) == 0);
<span class="d_comment">// fuzzy count range in range
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>!<span class="d_string">"std.uni.toLower(a) == std.uni.toLower(b)"</span>(<span class="d_string">"AbcAdFaBf"</span>, <span class="d_string">"ab"</span>) == 2);
<span class="d_comment">// count predicate in range
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">count</span>!(<span class="d_string">"a &gt; 1"</span>)(a) == 8);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".balancedParens"></a>bool <a name="balancedParens"></a><span class="ddoc_psymbol">balancedParens</span>(Range, E)(Range <i>r</i>, E <i>lPar</i>, E <i>rPar</i>, size_t <i>maxNestingLevel</i> = size_t.max) if (isInputRange!Range &amp;&amp; is(typeof(<i>r</i>.front == <i>lPar</i>)));
</dt>
<dd>Checks whether <span class="d_inlinecode">r</span> has "balanced parentheses", i.e. all instances
of <span class="d_inlinecode">lPar</span> are closed by corresponding instances of <span class="d_inlinecode">rPar</span>. The
parameter <span class="d_inlinecode">maxNestingLevel</span> controls the nesting level allowed. The
most common uses are the default or <span class="d_inlinecode">0</span>. In the latter case, no
nesting is allowed.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> s = <span class="d_string">"1 + $(LPAREN)2 * (3 + 1 / 2)"</span>;
<span class="d_keyword">assert</span>(!<span class="d_psymbol">balancedParens</span>(s, '(', ')'));
s = <span class="d_string">"1 + (2 * (3 + 1) / 2)"</span>;
<span class="d_keyword">assert</span>(<span class="d_psymbol">balancedParens</span>(s, '(', ')'));
s = <span class="d_string">"1 + (2 * (3 + 1) / 2)"</span>;
<span class="d_keyword">assert</span>(!<span class="d_psymbol">balancedParens</span>(s, '(', ')', 1));
s = <span class="d_string">"1 + (2 * 3 + 1) / (2 - 5)"</span>;
<span class="d_keyword">assert</span>(<span class="d_psymbol">balancedParens</span>(s, '(', ')', 1));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".equal"></a>bool <a name="equal"></a><span class="ddoc_psymbol">equal</span>(Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(typeof(<i>r1</i>.front == <i>r2</i>.front)));
<br><a name=".equal"></a>bool <a name="equal"></a><span class="ddoc_psymbol">equal</span>(alias pred, Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(typeof(binaryFun!pred(<i>r1</i>.front, <i>r2</i>.front))));
</dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if and only if the two ranges compare <a name="equal"></a><span class="ddoc_psymbol">equal</span> element
for element, according to binary predicate <span class="d_inlinecode">pred</span>. The ranges may
have different element types, as long as <span class="d_inlinecode">pred(a, b)</span> evaluates to
<span class="d_inlinecode">bool</span> for <span class="d_inlinecode">a</span> in <span class="d_inlinecode">r1</span> and <span class="d_inlinecode">b</span> in <span class="d_inlinecode">r2</span>. Performs
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">min(r1.length, r2.length)</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">pred</span>. See also
<a href="http://sgi.com/tech/stl/equal.html">STL's equal</a>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 3 ];
<span class="d_keyword">assert</span>(!<span class="d_psymbol">equal</span>(a, a[1..$]));
<span class="d_keyword">assert</span>(<span class="d_psymbol">equal</span>(a, a));

<span class="d_comment">// different types
</span><span class="d_keyword">double</span>[] b = [ 1.0, 2, 4, 3];
<span class="d_keyword">assert</span>(!<span class="d_psymbol">equal</span>(a, b[1..$]));
<span class="d_keyword">assert</span>(<span class="d_psymbol">equal</span>(a, b));

<span class="d_comment">// predicated: ensure that two vectors are approximately equal
</span><span class="d_keyword">double</span>[] c = [ 1.005, 2, 4, 3];
<span class="d_keyword">assert</span>(<span class="d_psymbol">equal</span>!(approxEqual)(b, c));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".cmp"></a>int <a name="cmp"></a><span class="ddoc_psymbol">cmp</span>(alias pred = "a &lt; b", R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>) if (isInputRange!R1 &amp;&amp; isInputRange!R2 &amp;&amp; !(isSomeString!R1 &amp;&amp; isSomeString!R2));
</dt>
<dd>Performs three-way lexicographical comparison on two input ranges
according to predicate <span class="d_inlinecode">pred</span>. Iterating <span class="d_inlinecode">r1</span> and <span class="d_inlinecode">r2</span> in
lockstep, <span class="d_inlinecode"><a name="cmp"></a><span class="ddoc_psymbol">cmp</span></span> compares each element <span class="d_inlinecode">e1</span> of <span class="d_inlinecode">r1</span> with the
corresponding element <span class="d_inlinecode">e2</span> in <span class="d_inlinecode">r2</span>. If <span class="d_inlinecode">binaryFun!pred(e1,
e2)</span>, <span class="d_inlinecode"><a name="cmp"></a><span class="ddoc_psymbol">cmp</span></span> returns a negative value. If <span class="d_inlinecode">binaryFun!pred(e2,
e1)</span>, <span class="d_inlinecode"><a name="cmp"></a><span class="ddoc_psymbol">cmp</span></span> returns a positive value. If one of the ranges has been
finished, <span class="d_inlinecode"><a name="cmp"></a><span class="ddoc_psymbol">cmp</span></span> returns a negative value if <span class="d_inlinecode">r1</span> has fewer
elements than <span class="d_inlinecode">r2</span>, a positive value if <span class="d_inlinecode">r1</span> has more elements
than <span class="d_inlinecode">r2</span>, and <span class="d_inlinecode">0</span> if the ranges have the same number of
elements.
<p></p>
If the ranges are strings, <span class="d_inlinecode"><a name="cmp"></a><span class="ddoc_psymbol">cmp</span></span> performs UTF decoding
appropriately and compares the ranges one code point at a time.<p></p>

</dd>
<dt class="d_decl"><a name=".min"></a>MinType!(T1, T2, T) <a name="min"></a><span class="ddoc_psymbol">min</span>(T1, T2, T...)(T1 <i>a</i>, T2 <i>b</i>, T <i>xs</i>) if (is(typeof(<i>a</i> &lt; <i>b</i>)));
</dt>
<dd>Returns the minimum of the passed-in values. The type of the result is
computed by using <a href="std_traits.html#CommonType"><span class="d_inlinecode">std.traits.CommonType</span></a>.<p></p>

</dd>
<dt class="d_decl"><a name=".max"></a>MaxType!(T1, T2, T) <a name="max"></a><span class="ddoc_psymbol">max</span>(T1, T2, T...)(T1 <i>a</i>, T2 <i>b</i>, T <i>xs</i>) if (is(typeof(<i>a</i> &lt; <i>b</i>)));
</dt>
<dd>Returns the maximum of the passed-in values. The type of the result is
computed by using <a href="std_traits.html#CommonType"><span class="d_inlinecode">std.traits.CommonType</span></a>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span> a = 5;
<span class="d_keyword">short</span> b = 6;
<span class="d_keyword">double</span> c = 2;
<span class="d_keyword">auto</span> d = <span class="d_psymbol">max</span>(a, b);
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(d) == <span class="d_keyword">int</span>));
<span class="d_keyword">assert</span>(d == 6);
<span class="d_keyword">auto</span> e = min(a, b, c);
<span class="d_keyword">assert</span>(<span class="d_keyword">is</span>(<span class="d_keyword">typeof</span>(e) == <span class="d_keyword">double</span>));
<span class="d_keyword">assert</span>(e == 2);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".minCount"></a>Tuple!(ElementType!Range, size_t) <a name="minCount"></a><span class="ddoc_psymbol">minCount</span>(alias pred = "a &lt; b", Range)(Range <i>range</i>) if (isInputRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(<i>range</i>.front, <i>range</i>.front))));
</dt>
<dd>Returns the minimum element of a range together with the number of
occurrences. The function can actually be used for counting the
maximum or any other ordering predicate (that's why <span class="d_inlinecode">maxCount</span> is
not provided).
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];
<span class="d_comment">// Minimum is 1 and occurs 3 times
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">minCount</span>(a) == tuple(1, 3));
<span class="d_comment">// Maximum is 4 and occurs 2 times
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">minCount</span>!(<span class="d_string">"a &gt; b"</span>)(a) == tuple(4, 2));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".minPos"></a>Range <a name="minPos"></a><span class="ddoc_psymbol">minPos</span>(alias pred = "a &lt; b", Range)(Range <i>range</i>) if (isForwardRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; is(typeof(binaryFun!pred(<i>range</i>.front, <i>range</i>.front))));
</dt>
<dd>Returns the position of the minimum element of forward range <span class="d_inlinecode">range</span>, i.e. a subrange of <span class="d_inlinecode">range</span> starting at the position of its
smallest element and with the same ending as <span class="d_inlinecode">range</span>. The function
can actually be used for counting the maximum or any other ordering
predicate (that's why <span class="d_inlinecode">maxPos</span> is not provided).
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 2, 3, 4, 1, 2, 4, 1, 1, 2 ];
<span class="d_comment">// Minimum is 1 and first occurs in position 3
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">minPos</span>(a) == [ 1, 2, 4, 1, 1, 2 ]);
<span class="d_comment">// Maximum is 4 and first occurs in position 2
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">minPos</span>!(<span class="d_string">"a &gt; b"</span>)(a) == [ 4, 1, 2, 4, 1, 1, 2 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".mismatch"></a>Tuple!(Range1, Range2) <a name="mismatch"></a><span class="ddoc_psymbol">mismatch</span>(alias pred = "a == b", Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2);
</dt>
<dd>Sequentially compares elements in <span class="d_inlinecode">r1</span> and <span class="d_inlinecode">r2</span> in lockstep, and
stops at the first <a name="mismatch"></a><span class="ddoc_psymbol">mismatch</span> (according to <span class="d_inlinecode">pred</span>, by default
equality). Returns a tuple with the reduced ranges that start with the
two mismatched values. Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">min(r1.length, r2.length)</span><b><i>)</i></b>
evaluations of <span class="d_inlinecode">pred</span>. See also <a href="http://sgi.com/tech/stl/mismatch.html">STL's mismatch</a>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[]    x = [ 1,  5, 2, 7,   4, 3 ];
<span class="d_keyword">double</span>[] y = [ 1.0, 5, 2, 7.3, 4, 8 ];
<span class="d_keyword">auto</span> m = <span class="d_psymbol">mismatch</span>(x, y);
<span class="d_keyword">assert</span>(m[0] == x[3 .. $]);
<span class="d_keyword">assert</span>(m[1] == y[3 .. $]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".EditOp"></a>enum <a name="EditOp"></a><span class="ddoc_psymbol">EditOp</span>: char;
</dt>
<dd>Encodes <a href="http://realityinteractive.com/rgrzywinski/archives/000249.html">edit operations</a> necessary to transform one sequence into
another. Given sequences <span class="d_inlinecode">s</span> (source) and <span class="d_inlinecode">t</span> (target), a
sequence of <span class="d_inlinecode"><a name="EditOp"></a><span class="ddoc_psymbol">EditOp</span></span> encodes the steps that need to be taken to
convert <span class="d_inlinecode">s</span> into <span class="d_inlinecode">t</span>. For example, if <span class="d_inlinecode">s = "cat"</span> and <span class="d_inlinecode">"cars"</span>, the minimal sequence that transforms <span class="d_inlinecode">s</span> into <span class="d_inlinecode">t</span> is:
skip two characters, replace 't' with 'r', and insert an 's'. Working
with edit operations is useful in applications such as spell-checkers
(to find the closest word to a given misspelled word), approximate
searches, diff-style programs that compute the difference between
files, efficient encoding of patches, DNA sequence analysis, and
plagiarism detection.<p></p>

<dl><dt class="d_decl"><a name=".EditOp.none"></a><a name="none"></a><span class="ddoc_psymbol">none</span></dt>
<dd>Current items are equal; no editing is necessary. <p></p>

</dd>
<dt class="d_decl"><a name=".EditOp.substitute"></a><a name="substitute"></a><span class="ddoc_psymbol">substitute</span></dt>
<dd>Substitute current item in target with current item in source. <p></p>

</dd>
<dt class="d_decl"><a name=".EditOp.insert"></a><a name="insert"></a><span class="ddoc_psymbol">insert</span></dt>
<dd>Insert current item from the source into the target. <p></p>

</dd>
<dt class="d_decl"><a name=".EditOp.remove"></a><a name="remove"></a><span class="ddoc_psymbol">remove</span></dt>
<dd>Remove current item from the target. <p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".levenshteinDistance"></a>size_t <a name="levenshteinDistance"></a><span class="ddoc_psymbol">levenshteinDistance</span>(alias equals = "a == b", Range1, Range2)(Range1 <i>s</i>, Range2 <i>t</i>) if (isForwardRange!Range1 &amp;&amp; isForwardRange!Range2);
</dt>
<dd>Returns the <a href="http://wikipedia.org/wiki/Levenshtein_distance">Levenshtein
distance</a> between <span class="d_inlinecode">s</span> and <span class="d_inlinecode">t</span>. The Levenshtein distance computes
the minimal amount of edit operations necessary to transform <span class="d_inlinecode">s</span>
into <span class="d_inlinecode">t</span>.  Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">s.length * t.length</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">equals</span> and occupies <b><i>&Omicron;</i>(</b><span class="d_inlinecode">s.length * t.length</span><b><i>)</i></b> storage.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">levenshteinDistance</span>(<span class="d_string">"cat"</span>, <span class="d_string">"rat"</span>) == 1);
<span class="d_keyword">assert</span>(<span class="d_psymbol">levenshteinDistance</span>(<span class="d_string">"parks"</span>, <span class="d_string">"spark"</span>) == 2);
<span class="d_keyword">assert</span>(<span class="d_psymbol">levenshteinDistance</span>(<span class="d_string">"kitten"</span>, <span class="d_string">"sitting"</span>) == 3);
<span class="d_comment">// ignore case
</span><span class="d_keyword">assert</span>(<span class="d_psymbol">levenshteinDistance</span>!(<span class="d_string">"std.uni.toUpper(a) == std.uni.toUpper(b)"</span>)
    (<span class="d_string">"parks"</span>, <span class="d_string">"SPARK"</span>) == 2);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".levenshteinDistanceAndPath"></a>Tuple!(size_t, EditOp[]) <a name="levenshteinDistanceAndPath"></a><span class="ddoc_psymbol">levenshteinDistanceAndPath</span>(alias equals = "a == b", Range1, Range2)(Range1 <i>s</i>, Range2 <i>t</i>) if (isForwardRange!Range1 &amp;&amp; isForwardRange!Range2);
</dt>
<dd>Returns the Levenshtein distance and the edit path between <span class="d_inlinecode">s</span> and
<span class="d_inlinecode">t</span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code">string a = <span class="d_string">"Saturday"</span>, b = <span class="d_string">"Sunday"</span>;
<span class="d_keyword">auto</span> p = <span class="d_psymbol">levenshteinDistanceAndPath</span>(a, b);
<span class="d_keyword">assert</span>(p[0] == 3);
<span class="d_keyword">assert</span>(equal(p[1], <span class="d_string">"nrrnsnnn"</span>));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".copy"></a>Range2 <a name="copy"></a><span class="ddoc_psymbol">copy</span>(Range1, Range2)(Range1 <i>source</i>, Range2 <i>target</i>) if (isInputRange!Range1 &amp;&amp; isOutputRange!(Range2, ElementType!Range1));
</dt>
<dd>Copies the content of <span class="d_inlinecode">source</span> into <span class="d_inlinecode">target</span> and returns the
remaining (unfilled) part of <span class="d_inlinecode">target</span>. See also <a href="http://sgi.com/tech/stl/copy.html">STL's copy</a>. If a behavior similar to
<a href="http://sgi.com/tech/stl/copy_backward.html">STL's copy_backward</a> is
needed, use <span class="d_inlinecode"><a name="copy"></a><span class="ddoc_psymbol">copy</span>(retro(source), retro(target))</span>. See also <a href="std_range.html#retro"><span class="d_inlinecode">std.range.retro</span></a>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 5 ];
<span class="d_keyword">int</span>[] b = [ 9, 8 ];
<span class="d_keyword">int</span>[] c = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[a.length + b.length + 10];
<span class="d_keyword">auto</span> d = <span class="d_psymbol">copy</span>(b, <span class="d_psymbol">copy</span>(a, c));
<span class="d_keyword">assert</span>(c[0 .. a.length + b.length] == a ~ b);
<span class="d_keyword">assert</span>(d.length == 10);
</pre>
<p></p>

As long as the target range elements support assignment from source
range elements, different types of ranges are accepted.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">float</span>[] a = [ 1.0f, 5 ];
<span class="d_keyword">double</span>[] b = <span class="d_keyword">new</span> <span class="d_keyword">double</span>[a.length];
<span class="d_keyword">auto</span> d = <span class="d_psymbol">copy</span>(a, b);
</pre>
<p></p>

To <a name="copy"></a><span class="ddoc_psymbol">copy</span> at most <span class="d_inlinecode">n</span> elements from range <span class="d_inlinecode">a</span> to range <span class="d_inlinecode">b</span>, you
may want to use <span class="d_inlinecode"><a name="copy"></a><span class="ddoc_psymbol">copy</span>(take(a, n), b)</span>. To <a name="copy"></a><span class="ddoc_psymbol">copy</span> those elements from
range <span class="d_inlinecode">a</span> that satisfy predicate <span class="d_inlinecode">pred</span> to range <span class="d_inlinecode">b</span>, you may
want to use <span class="d_inlinecode"><a name="copy"></a><span class="ddoc_psymbol">copy</span>(filter!(pred)(a), b)</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 5, 8, 9, 10, 1, 2, 0 ];
<span class="d_keyword">auto</span> b = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[a.length];
<span class="d_keyword">auto</span> c = <span class="d_psymbol">copy</span>(filter!(<span class="d_string">"(a &amp; 1) == 1"</span>)(a), b);
<span class="d_keyword">assert</span>(b[0 .. $ - c.length] == [ 1, 5, 9, 1 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".swapRanges"></a>Tuple!(Range1, Range2) <a name="swapRanges"></a><span class="ddoc_psymbol">swapRanges</span>(Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>) if (isInputRange!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; hasSwappableElements!Range1 &amp;&amp; hasSwappableElements!Range2 &amp;&amp; is(ElementType!Range1 == ElementType!Range2));
</dt>
<dd>Swaps all elements of <span class="d_inlinecode">r1</span> with successive elements in <span class="d_inlinecode">r2</span>.
Returns a tuple containing the remainder portions of <span class="d_inlinecode">r1</span> and <span class="d_inlinecode">r2</span> that were not swapped (one of them will be empty). The ranges may
be of different types but must have the same element type and support
swapping.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 100, 101, 102, 103 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 3 ];
<span class="d_keyword">auto</span> c = <span class="d_psymbol">swapRanges</span>(a[1 .. 3], b[2 .. 4]);
<span class="d_keyword">assert</span>(c[0].empty &amp;&amp; c[1].empty);
<span class="d_keyword">assert</span>(a == [ 100, 2, 3, 103 ]);
<span class="d_keyword">assert</span>(b == [ 0, 1, 101, 102 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".reverse"></a>void <a name="reverse"></a><span class="ddoc_psymbol">reverse</span>(Range)(Range <i>r</i>) if (isBidirectionalRange!Range &amp;&amp; !isRandomAccessRange!Range &amp;&amp; hasSwappableElements!Range);
<br><a name=".reverse"></a>void <a name="reverse"></a><span class="ddoc_psymbol">reverse</span>(Range)(Range <i>r</i>) if (isRandomAccessRange!Range &amp;&amp; hasLength!Range);
</dt>
<dd>Reverses <span class="d_inlinecode">r</span> in-place.  Performs <span class="d_inlinecode">r.length / 2</span> evaluations of <span class="d_inlinecode">swap</span>. See also <a href="http://sgi.com/tech/stl/reverse.html">STL's reverse</a>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [ 1, 2, 3 ];
<span class="d_psymbol">reverse</span>(arr);
<span class="d_keyword">assert</span>(arr == [ 3, 2, 1 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".reverse"></a>void <a name="reverse"></a><span class="ddoc_psymbol">reverse</span>(Char)(Char[] <i>s</i>) if (isNarrowString!(Char[]) &amp;&amp; !is(Char == const) &amp;&amp; !is(Char == immutable));
</dt>
<dd>Reverses <span class="d_inlinecode">r</span> in-place, where <span class="d_inlinecode">r</span> is a narrow string (having
elements of type <span class="d_inlinecode">char</span> or <span class="d_inlinecode">wchar</span>). UTF sequences consisting of
multiple code units are preserved properly.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">char</span>[] arr = <span class="d_string">"hello\U00010143\u0100\U00010143"</span>.dup;
<span class="d_psymbol">reverse</span>(arr);
<span class="d_keyword">assert</span>(arr == <span class="d_string">"\U00010143\u0100\U00010143olleh"</span>);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".strip"></a>Range <a name="strip"></a><span class="ddoc_psymbol">strip</span>(Range, E)(Range <i>range</i>, E <i>element</i>) if (isBidirectionalRange!Range &amp;&amp; is(typeof(<i>range</i>.front == <i>element</i>) : bool));
<br><a name=".strip"></a>Range <a name="strip"></a><span class="ddoc_psymbol">strip</span>(alias pred, Range)(Range <i>range</i>) if (isBidirectionalRange!Range &amp;&amp; is(typeof(pred(<i>range</i>.back)) : bool));
<br><a name=".stripLeft"></a>Range <a name="stripLeft"></a><span class="ddoc_psymbol">stripLeft</span>(Range, E)(Range <i>range</i>, E <i>element</i>) if (isInputRange!Range &amp;&amp; is(typeof(<i>range</i>.front == <i>element</i>) : bool));
<br><a name=".stripLeft"></a>Range <a name="stripLeft"></a><span class="ddoc_psymbol">stripLeft</span>(alias pred, Range)(Range <i>range</i>) if (isInputRange!Range &amp;&amp; is(typeof(pred(<i>range</i>.front)) : bool));
<br><a name=".stripRight"></a>Range <a name="stripRight"></a><span class="ddoc_psymbol">stripRight</span>(Range, E)(Range <i>range</i>, E <i>element</i>) if (isBidirectionalRange!Range &amp;&amp; is(typeof(<i>range</i>.back == <i>element</i>) : bool));
<br><a name=".stripRight"></a>Range <a name="stripRight"></a><span class="ddoc_psymbol">stripRight</span>(alias pred, Range)(Range <i>range</i>) if (isBidirectionalRange!Range &amp;&amp; is(typeof(pred(<i>range</i>.back)) : bool));
</dt>
<dd>The <a name="strip"></a><span class="ddoc_psymbol">strip</span> group of functions allow stripping of either leading, trailing,
    or both leading and trailing elements.
<p></p>
The <span class="d_inlinecode">stripLeft</span> function will <a name="strip"></a><span class="ddoc_psymbol">strip</span> the <span class="d_inlinecode">front</span> of the range,
    the <span class="d_inlinecode">stripRight</span> function will <a name="strip"></a><span class="ddoc_psymbol">strip</span> the <span class="d_inlinecode">back</span> of the range,
    while the <span class="d_inlinecode"><a name="strip"></a><span class="ddoc_psymbol">strip</span></span> function will <a name="strip"></a><span class="ddoc_psymbol">strip</span> both the <span class="d_inlinecode">front</span> and <span class="d_inlinecode">back</span>
    of the range.
<p></p>

    Note that the <span class="d_inlinecode"><a name="strip"></a><span class="ddoc_psymbol">strip</span></span> and <span class="d_inlinecode">stripRight</span> functions require the range to
    be a <a href="#BidirectionalRange"><span class="d_inlinecode">BidirectionalRange</span></a> range.
<p></p>

    All of these functions come in two varieties: one takes a target element,
    where the range will be stripped as long as this element can be found.
    The other takes a lambda predicate, where the range will be stripped as
    long as the predicate returns <b>true</b>.<p></p>

<b>Examples:</b><br>Strip leading and trailing elements equal to the target element.
<pre class="d_code">
    <span class="d_keyword">assert</span>(<span class="d_string">"  foobar  "</span>.strip(' ') == <span class="d_string">"foobar"</span>);
    <span class="d_keyword">assert</span>(<span class="d_string">"00223.444500"</span>.strip('0') == <span class="d_string">"223.4445"</span>);
    <span class="d_keyword">assert</span>(<span class="d_string">"p"</span>.strip('') == <span class="d_string">"p"</span>);
    <span class="d_keyword">assert</span>([1, 1, 0, 1, 1].strip(1) == [0]);
    <span class="d_keyword">assert</span>([0.0, 0.01, 0.01, 0.0].strip(0).length == 2);
</pre>
<p></p><b>Examples:</b><br>Strip leading and trailing elements while the predicate returns <b>true</b>.
<pre class="d_code">
    <span class="d_keyword">assert</span>(<span class="d_string">"  foobar  "</span>.strip!(a =&gt; a == ' ')() == <span class="d_string">"foobar"</span>);
    <span class="d_keyword">assert</span>(<span class="d_string">"00223.444500"</span>.strip!(a =&gt; a == '0')() == <span class="d_string">"223.4445"</span>);
    <span class="d_keyword">assert</span>(<span class="d_string">"p"</span>.strip!(a =&gt; a == '')() == <span class="d_string">"p"</span>);
    <span class="d_keyword">assert</span>([1, 1, 0, 1, 1].strip!(a =&gt; a == 1)() == [0]);
    <span class="d_keyword">assert</span>([0.0, 0.01, 0.5, 0.6, 0.01, 0.0].strip!(a =&gt; a &lt; 0.4)().length == 2);
</pre>
<p></p><b>Examples:</b><br>Strip leading elements equal to the target element.
<pre class="d_code">
    <span class="d_keyword">assert</span>(<span class="d_string">"  foobar  "</span>.stripLeft(' ') == <span class="d_string">"foobar  "</span>);
    <span class="d_keyword">assert</span>(<span class="d_string">"00223.444500"</span>.stripLeft('0') == <span class="d_string">"223.444500"</span>);
    <span class="d_keyword">assert</span>(<span class="d_string">"niod"</span>.stripLeft('') == <span class="d_string">"niod"</span>);
    <span class="d_keyword">assert</span>([1, 1, 0, 1, 1].stripLeft(1) == [0, 1, 1]);
    <span class="d_keyword">assert</span>([0.0, 0.01, 0.01, 0.0].stripLeft(0).length == 3);
</pre>
<p></p><b>Examples:</b><br>Strip leading elements while the predicate returns <b>true</b>.
<pre class="d_code">
    <span class="d_keyword">assert</span>(<span class="d_string">"  foobar  "</span>.stripLeft!(a =&gt; a == ' ')() == <span class="d_string">"foobar  "</span>);
    <span class="d_keyword">assert</span>(<span class="d_string">"00223.444500"</span>.stripLeft!(a =&gt; a == '0')() == <span class="d_string">"223.444500"</span>);
    <span class="d_keyword">assert</span>(<span class="d_string">"niod"</span>.stripLeft!(a =&gt; a == '')() == <span class="d_string">"niod"</span>);
    <span class="d_keyword">assert</span>([1, 1, 0, 1, 1].stripLeft!(a =&gt; a == 1)() == [0, 1, 1]);
    <span class="d_keyword">assert</span>([0.0, 0.01, 0.10, 0.5, 0.6].stripLeft!(a =&gt; a &lt; 0.4)().length == 2);
</pre>
<p></p><b>Examples:</b><br>Strip trailing elements equal to the target element.
<pre class="d_code">
    <span class="d_keyword">assert</span>(<span class="d_string">"  foobar  "</span>.<span class="d_psymbol">stripRight</span>(' ') == <span class="d_string">"  foobar"</span>);
    <span class="d_keyword">assert</span>(<span class="d_string">"00223.444500"</span>.<span class="d_psymbol">stripRight</span>('0') == <span class="d_string">"00223.4445"</span>);
    <span class="d_keyword">assert</span>(<span class="d_string">"niod"</span>.<span class="d_psymbol">stripRight</span>('') == <span class="d_string">"niod"</span>);
    <span class="d_keyword">assert</span>([1, 1, 0, 1, 1].<span class="d_psymbol">stripRight</span>(1) == [1, 1, 0]);
    <span class="d_keyword">assert</span>([0.0, 0.01, 0.01, 0.0].<span class="d_psymbol">stripRight</span>(0).length == 3);
</pre>
<p></p><b>Examples:</b><br>Strip trailing elements while the predicate returns <b>true</b>.
<pre class="d_code">
    <span class="d_keyword">assert</span>(<span class="d_string">"  foobar  "</span>.<span class="d_psymbol">stripRight</span>!(a =&gt; a == ' ')() == <span class="d_string">"  foobar"</span>);
    <span class="d_keyword">assert</span>(<span class="d_string">"00223.444500"</span>.<span class="d_psymbol">stripRight</span>!(a =&gt; a == '0')() == <span class="d_string">"00223.4445"</span>);
    <span class="d_keyword">assert</span>(<span class="d_string">"niod"</span>.<span class="d_psymbol">stripRight</span>!(a =&gt; a == '')() == <span class="d_string">"niod"</span>);
    <span class="d_keyword">assert</span>([1, 1, 0, 1, 1].<span class="d_psymbol">stripRight</span>!(a =&gt; a == 1)() == [1, 1, 0]);
    <span class="d_keyword">assert</span>([0.0, 0.01, 0.10, 0.5, 0.6].<span class="d_psymbol">stripRight</span>!(a =&gt; a &gt; 0.4)().length == 3);
</pre>
<p></p></dd>
<dt class="d_decl"><a name=".bringToFront"></a>size_t <a name="bringToFront"></a><span class="ddoc_psymbol">bringToFront</span>(Range1, Range2)(Range1 <i>front</i>, Range2 <i>back</i>) if (isInputRange!Range1 &amp;&amp; isForwardRange!Range2);
</dt>
<dd>The <span class="d_inlinecode"><a name="bringToFront"></a><span class="ddoc_psymbol">bringToFront</span></span> function has considerable flexibility and
usefulness. It can rotate elements in one buffer left or right, swap
buffers of equal length, and even move elements across disjoint
buffers of different types and different lengths.
<p></p>
<span class="d_inlinecode"><a name="bringToFront"></a><span class="ddoc_psymbol">bringToFront</span></span> takes two ranges <span class="d_inlinecode">front</span> and <span class="d_inlinecode">back</span>, which may
be of different types. Considering the concatenation of <span class="d_inlinecode">front</span> and
<span class="d_inlinecode">back</span> one unified range, <span class="d_inlinecode"><a name="bringToFront"></a><span class="ddoc_psymbol">bringToFront</span></span> rotates that unified
range such that all elements in <span class="d_inlinecode">back</span> are brought to the beginning
of the unified range. The relative ordering of elements in <span class="d_inlinecode">front</span>
and <span class="d_inlinecode">back</span>, respectively, remains unchanged.
<p></p>

The simplest use of <span class="d_inlinecode"><a name="bringToFront"></a><span class="ddoc_psymbol">bringToFront</span></span> is for rotating elements in a
buffer. For example:
<p></p>

<pre class="d_code"><span class="d_keyword">auto</span> arr = [4, 5, 6, 7, 1, 2, 3];
<span class="d_psymbol">bringToFront</span>(arr[0 .. 4], arr[4 .. $]);
<span class="d_keyword">assert</span>(arr == [ 1, 2, 3, 4, 5, 6, 7 ]);
</pre>
<p></p>

The <span class="d_inlinecode">front</span> range may actually "step over" the <span class="d_inlinecode">back</span>
range. This is very useful with forward ranges that cannot compute
comfortably right-bounded subranges like <span class="d_inlinecode">arr[0 .. 4]</span> above. In
the example below, <span class="d_inlinecode">r2</span> is a right subrange of <span class="d_inlinecode">r1</span>.
<p></p>

<pre class="d_code"><span class="d_keyword">auto</span> list = SList!(<span class="d_keyword">int</span>)(4, 5, 6, 7, 1, 2, 3);
<span class="d_keyword">auto</span> r1 = list[];
<span class="d_keyword">auto</span> r2 = list[]; popFrontN(r2, 4);
<span class="d_keyword">assert</span>(equal(r2, [ 1, 2, 3 ]));
<span class="d_psymbol">bringToFront</span>(r1, r2);
<span class="d_keyword">assert</span>(equal(list[], [ 1, 2, 3, 4, 5, 6, 7 ]));
</pre>
<p></p>

Elements can be swapped across ranges of different types:
<p></p>

<pre class="d_code"><span class="d_keyword">auto</span> list = SList!(<span class="d_keyword">int</span>)(4, 5, 6, 7);
<span class="d_keyword">auto</span> vec = [ 1, 2, 3 ];
<span class="d_psymbol">bringToFront</span>(list[], vec);
<span class="d_keyword">assert</span>(equal(list[], [ 1, 2, 3, 4 ]));
<span class="d_keyword">assert</span>(equal(vec, [ 5, 6, 7 ]));
</pre>
<p></p>

Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">max(front.length, back.length)</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">swap</span>. See also <a href="http://sgi.com/tech/stl/rotate.html">STL's rotate</a>.

<p></p>
<b>Preconditions:</b><br>
Either <span class="d_inlinecode">front</span> and <span class="d_inlinecode">back</span> are disjoint, or <span class="d_inlinecode">back</span> is
reachable from <span class="d_inlinecode">front</span> and <span class="d_inlinecode">front</span> is not reachable from <span class="d_inlinecode">back</span>.

<p></p>
<b>Returns:</b><br>The number of elements brought to the front, i.e., the length of <span class="d_inlinecode">back</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".SwapStrategy"></a>enum <a name="SwapStrategy"></a><span class="ddoc_psymbol">SwapStrategy</span>: int;
</dt>
<dd>Defines the swapping strategy for algorithms that need to swap
elements in a range (such as partition and sort). The strategy
concerns the swapping of elements that are not the core concern of the
algorithm. For example, consider an algorithm that sorts <span class="d_inlinecode">[ "abc",
"b", "aBc" ]</span> according to <span class="d_inlinecode">toUpper(a) &lt; toUpper(b)</span>. That
algorithm might choose to swap the two equivalent strings <span class="d_inlinecode">"abc"</span>
and <span class="d_inlinecode">"aBc"</span>. That does not affect the sorting since both <span class="d_inlinecode">[
"abc", "aBc", "b" ]</span> and <span class="d_inlinecode">[ "aBc", "abc", "b" ]</span> are valid
outcomes.
<p></p>
Some situations require that the algorithm must NOT ever change the
relative ordering of equivalent elements (in the example above, only
<span class="d_inlinecode">[ "abc", "aBc", "b" ]</span> would be the correct result). Such
algorithms are called <b>stable</b>. If the ordering algorithm may swap
equivalent elements discretionarily, the ordering is called <b>unstable</b>.
<p></p>

Yet another class of algorithms may choose an intermediate tradeoff by
being stable only on a well-defined subrange of the range. There is no
established terminology for such behavior; this library calls it <b>semistable</b>.
<p></p>

Generally, the <span class="d_inlinecode">stable</span> ordering strategy may be more costly in
time and/or space than the other two because it imposes additional
constraints. Similarly, <span class="d_inlinecode">semistable</span> may be costlier than <span class="d_inlinecode">unstable</span>. As (semi-)stability is not needed very often, the ordering
algorithms in this module parameterized by <span class="d_inlinecode"><a name="SwapStrategy"></a><span class="ddoc_psymbol">SwapStrategy</span></span> all
choose <span class="d_inlinecode"><a name="SwapStrategy"></a><span class="ddoc_psymbol">SwapStrategy</span>.unstable</span> as the default.<p></p>

<dl><dt class="d_decl"><a name=".SwapStrategy.unstable"></a><a name="unstable"></a><span class="ddoc_psymbol">unstable</span></dt>
<dd>Allows freely swapping of elements as long as the output
       satisfies the algorithm's requirements.<p></p>

</dd>
<dt class="d_decl"><a name=".SwapStrategy.semistable"></a><a name="semistable"></a><span class="ddoc_psymbol">semistable</span></dt>
<dd>In algorithms partitioning ranges in two, preserve relative
       ordering of elements only to the left of the partition point.<p></p>

</dd>
<dt class="d_decl"><a name=".SwapStrategy.stable"></a><a name="stable"></a><span class="ddoc_psymbol">stable</span></dt>
<dd>Preserve the relative ordering of elements to the largest
       extent allowed by the algorithm's requirements.<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".remove"></a>Range <a name="remove"></a><span class="ddoc_psymbol">remove</span>(SwapStrategy s = SwapStrategy.stable, Range, Offset...)(Range <i>range</i>, Offset <i>offset</i>) if (s != SwapStrategy.stable &amp;&amp; isBidirectionalRange!Range &amp;&amp; hasLength!Range &amp;&amp; Offset.length &gt;= 1);
</dt>
<dd>Eliminates elements at given offsets from <span class="d_inlinecode">range</span> and returns the
shortened range. In the simplest call, one element is removed.
<p></p>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 3, 5, 7, 8 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">remove</span>(a, 1) == [ 3, 7, 8 ]);
<span class="d_keyword">assert</span>(a == [ 3, 7, 8, 8 ]);
</pre>
<p></p>

In the case above the element at offset <span class="d_inlinecode">1</span> is removed and <span class="d_inlinecode"><a name="remove"></a><span class="ddoc_psymbol">remove</span></span> returns the range smaller by one element. The original array
has remained of the same length because all functions in <span class="d_inlinecode">std.algorithm</span> only change <i>content</i>, not <i>topology</i>. The value
<span class="d_inlinecode">8</span> is repeated because <a href="std_algorithm.html#move"><span class="d_inlinecode">std.algorithm.move</span></a> was invoked to move
elements around and on integers <span class="d_inlinecode">move</span> simply copies the source to
the destination. To replace <span class="d_inlinecode">a</span> with the effect of the removal,
simply assign <span class="d_inlinecode">a = <a name="remove"></a><span class="ddoc_psymbol">remove</span>(a, 1)</span>. The slice will be rebound to the
shorter array and the operation completes with maximal efficiency.
<p></p>

Multiple indices can be passed into <span class="d_inlinecode"><a name="remove"></a><span class="ddoc_psymbol">remove</span></span>. In that case,
elements at the respective indices are all removed. The indices must
be passed in increasing order, otherwise an exception occurs.
<p></p>

<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">remove</span>(a, 1, 3, 5) ==
    [ 0, 2, 4, 6, 7, 8, 9, 10 ]);
</pre>
<p></p>

(Note how all indices refer to slots in the <i>original</i> array, not
in the array as it is being progressively shortened.) Finally, any
combination of integral offsets and tuples composed of two integral
offsets can be passed in.
<p></p>

<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">remove</span>(a, 1, tuple(3, 5), 9) == [ 0, 2, 6, 7, 8, 10 ]);
</pre>
<p></p>

In this case, the slots at positions 1, 3, 4, and 9 are removed from
the array. The tuple passes in a range closed to the left and open to
the right (consistent with built-in slices), e.g. <span class="d_inlinecode">tuple(3, 5)</span>
means indices <span class="d_inlinecode">3</span> and <span class="d_inlinecode">4</span> but not <span class="d_inlinecode">5</span>.
<p></p>

If the need is to <a name="remove"></a><span class="ddoc_psymbol">remove</span> some elements in the range but the order of
the remaining elements does not have to be preserved, you may want to
pass <span class="d_inlinecode">SwapStrategy.unstable</span> to <span class="d_inlinecode"><a name="remove"></a><span class="ddoc_psymbol">remove</span></span>.
<p></p>

<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 0, 1, 2, 3 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">remove</span>!(SwapStrategy.unstable)(a, 1) == [ 0, 3, 2 ]);
</pre>
<p></p>

In the case above, the element at slot <span class="d_inlinecode">1</span> is removed, but replaced
with the last element of the range. Taking advantage of the relaxation
of the stability requirement, <span class="d_inlinecode"><a name="remove"></a><span class="ddoc_psymbol">remove</span></span> moved elements from the end
of the array over the slots to be removed. This way there is less data
movement to be done which improves the execution time of the function.
<p></p>

The function <span class="d_inlinecode"><a name="remove"></a><span class="ddoc_psymbol">remove</span></span> works on any forward range. The moving
strategy is (listed from fastest to slowest): <ul><li>If <span class="d_inlinecode">s ==
SwapStrategy.unstable &amp;&amp; isRandomAccessRange!Range &amp;&amp;
hasLength!Range</span>, then elements are moved from the end of the range
into the slots to be filled. In this case, the absolute minimum of
moves is performed.</li>  <li>Otherwise, if <span class="d_inlinecode">s ==
SwapStrategy.unstable &amp;&amp; isBidirectionalRange!Range &amp;&amp;
hasLength!Range</span>, then elements are still moved from the end of the
range, but time is spent on advancing between slots by repeated calls
to <span class="d_inlinecode">range.popFront</span>.</li>  <li>Otherwise, elements are moved incrementally
towards the front of <span class="d_inlinecode">range</span>; a given element is never moved
several times, but more elements are moved than in the previous
cases.</li></ul><p></p>

</dd>
<dt class="d_decl"><a name=".remove"></a>Range <a name="remove"></a><span class="ddoc_psymbol">remove</span>(alias pred, SwapStrategy s = SwapStrategy.stable, Range)(Range <i>range</i>) if (isBidirectionalRange!Range);
</dt>
<dd>Reduces the length of the bidirectional range <span class="d_inlinecode">range</span> by removing
elements that satisfy <span class="d_inlinecode">pred</span>. If <span class="d_inlinecode">s = SwapStrategy.unstable</span>,
elements are moved from the right end of the range over the elements
to eliminate. If <span class="d_inlinecode">s = SwapStrategy.stable</span> (the default),
elements are moved progressively to front such that their relative
order is preserved. Returns the filtered range.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 3, 2, 3, 4, 5, 2, 5, 6 ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">remove</span>!(<span class="d_string">"a == 2"</span>)(a) == [ 1, 3, 3, 4, 5, 5, 6 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".partition"></a>Range <a name="partition"></a><span class="ddoc_psymbol">partition</span>(alias predicate, SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>) if (ss == SwapStrategy.stable &amp;&amp; isRandomAccessRange!Range || ss != SwapStrategy.stable &amp;&amp; isForwardRange!Range);
</dt>
<dd>Partitions a range in two using <span class="d_inlinecode">pred</span> as a
predicate. Specifically, reorders the range <span class="d_inlinecode">r = [left,
right)</span> using <span class="d_inlinecode">swap</span> such that all elements <span class="d_inlinecode">i</span> for
which <span class="d_inlinecode">pred(i)</span> is <span class="d_inlinecode"><b>true</b></span> come before all elements <span class="d_inlinecode">j</span> for
which <span class="d_inlinecode">pred(j)</span> returns <span class="d_inlinecode"><b>false</b></span>.
<p></p>
Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length</span><b><i>)</i></b> (if unstable or semistable) or <b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length * log(r.length)</span><b><i>)</i></b> (if stable) evaluations of <span class="d_inlinecode">less</span> and <span class="d_inlinecode">swap</span>. The unstable version computes the minimum possible evaluations
of <span class="d_inlinecode">swap</span> (roughly half of those performed by the semistable
version).
<p></p>

See also STL's <a href="http://sgi.com/tech/stl/partition.html">partition</a> and
<a href="http://sgi.com/tech/stl/stable_partition.html">stable_partition</a>.

<p></p>
<b>Returns:</b><br>The right part of <span class="d_inlinecode">r</span> after partitioning.
<p></p>

If <span class="d_inlinecode">ss == SwapStrategy.stable</span>, <span class="d_inlinecode"><a name="partition"></a><span class="ddoc_psymbol">partition</span></span> preserves the
relative ordering of all elements <span class="d_inlinecode">a</span>, <span class="d_inlinecode">b</span> in <span class="d_inlinecode">r</span> for which
<span class="d_inlinecode">pred(a) == pred(b)</span>. If <span class="d_inlinecode">ss == SwapStrategy.semistable</span>, <span class="d_inlinecode"><a name="partition"></a><span class="ddoc_psymbol">partition</span></span> preserves the relative ordering of all elements <span class="d_inlinecode">a</span>, <span class="d_inlinecode">b</span> in the left part of <span class="d_inlinecode">r</span> for which <span class="d_inlinecode">pred(a) == pred(b)</span>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> Arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
<span class="d_keyword">auto</span> arr = Arr.dup;
<span class="d_keyword">static</span> <span class="d_keyword">bool</span> even(<span class="d_keyword">int</span> a) { <span class="d_keyword">return</span> (a &amp; 1) == 0; }
<span class="d_comment">// Partition arr such that even numbers come first
</span><span class="d_keyword">auto</span> r = <span class="d_psymbol">partition</span>!(even)(arr);
<span class="d_comment">// Now arr is separated in evens and odds.
</span><span class="d_comment">// Numbers may have become shuffled due to instability
</span><span class="d_keyword">assert</span>(r == arr[5 .. $]);
<span class="d_keyword">assert</span>(count!(even)(arr[0 .. 5]) == 5);
<span class="d_keyword">assert</span>(find!(even)(r).empty);

<span class="d_comment">// Can also specify the predicate as a string.
</span><span class="d_comment">// Use 'a' as the predicate argument name
</span>arr[] = Arr[];
r = <span class="d_psymbol">partition</span>!(<span class="d_string">q{(a &amp; 1) == 0}</span>)(arr);
<span class="d_keyword">assert</span>(r == arr[5 .. $]);

<span class="d_comment">// Now for a stable partition:
</span>arr[] = Arr[];
r = <span class="d_psymbol">partition</span>!(<span class="d_string">q{(a &amp; 1) == 0}</span>, SwapStrategy.stable)(arr);
<span class="d_comment">// Now arr is [2 4 6 8 10 1 3 5 7 9], and r points to 1
</span><span class="d_keyword">assert</span>(arr == [2, 4, 6, 8, 10, 1, 3, 5, 7, 9] &amp;&amp; r == arr[5 .. $]);

<span class="d_comment">// In case the predicate needs to hold its own state, use a delegate:
</span>arr[] = Arr[];
<span class="d_keyword">int</span> x = 3;
<span class="d_comment">// Put stuff greater than 3 on the left
</span><span class="d_keyword">bool</span> fun(<span class="d_keyword">int</span> a) { <span class="d_keyword">return</span> a &gt; x; }
r = <span class="d_psymbol">partition</span>!(fun, SwapStrategy.semistable)(arr);
<span class="d_comment">// Now arr is [4 5 6 7 8 9 10 2 3 1] and r points to 2
</span><span class="d_keyword">assert</span>(arr == [4, 5, 6, 7, 8, 9, 10, 2, 3, 1] &amp;&amp; r == arr[7 .. $]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".isPartitioned"></a>bool <a name="isPartitioned"></a><span class="ddoc_psymbol">isPartitioned</span>(alias pred, Range)(Range <i>r</i>) if (isForwardRange!Range);
</dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if <span class="d_inlinecode">r</span> is partitioned according to predicate <span class="d_inlinecode">pred</span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] r = [ 1, 3, 5, 7, 8, 2, 4, ];
<span class="d_keyword">assert</span>(<span class="d_psymbol">isPartitioned</span>!(<span class="d_string">"a &amp; 1"</span>)(r));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".partition3"></a>auto <a name="partition3"></a><span class="ddoc_psymbol">partition3</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, E)(Range <i>r</i>, E <i>pivot</i>) if (ss == SwapStrategy.unstable &amp;&amp; isRandomAccessRange!Range &amp;&amp; hasSwappableElements!Range &amp;&amp; hasLength!Range &amp;&amp; is(typeof(binaryFun!less(<i>r</i>.front, <i>pivot</i>)) == bool) &amp;&amp; is(typeof(binaryFun!less(<i>pivot</i>, <i>r</i>.front)) == bool) &amp;&amp; is(typeof(binaryFun!less(<i>r</i>.front, <i>r</i>.front)) == bool));
</dt>
<dd>Rearranges elements in <span class="d_inlinecode">r</span> in three adjacent ranges and returns
them. The first and leftmost range only contains elements in <span class="d_inlinecode">r</span>
less than <span class="d_inlinecode">pivot</span>. The second and middle range only contains
elements in <span class="d_inlinecode">r</span> that are equal to <span class="d_inlinecode">pivot</span>. Finally, the third
and rightmost range only contains elements in <span class="d_inlinecode">r</span> that are greater
than <span class="d_inlinecode">pivot</span>. The less-than test is defined by the binary function
<span class="d_inlinecode">less</span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">auto</span> a = [ 8, 3, 4, 1, 4, 7, 4 ];
<span class="d_keyword">auto</span> pieces = <span class="d_psymbol">partition3</span>(a, 4);
<span class="d_keyword">assert</span>(a == [ 1, 3, 4, 4, 4, 7, 8 ]);
<span class="d_keyword">assert</span>(pieces[0] == [ 1, 3 ]);
<span class="d_keyword">assert</span>(pieces[1] == [ 4, 4, 4 ]);
<span class="d_keyword">assert</span>(pieces[2] == [ 7, 8 ]);
</pre>

<p></p>
<span style="color:red">BUGS:</span><br>stable <span class="d_inlinecode"><a name="partition3"></a><span class="ddoc_psymbol">partition3</span></span> has not been implemented yet.<p></p>

</dd>
<dt class="d_decl"><a name=".topN"></a>void <a name="topN"></a><span class="ddoc_psymbol">topN</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>, size_t <i>nth</i>) if (isRandomAccessRange!Range &amp;&amp; hasLength!Range);
</dt>
<dd>Reorders the range <span class="d_inlinecode">r</span> using <span class="d_inlinecode">swap</span> such that <span class="d_inlinecode">r[nth]</span> refers
to the element that would fall there if the range were fully
sorted. In addition, it also partitions <span class="d_inlinecode">r</span> such that all elements
<span class="d_inlinecode">e1</span> from <span class="d_inlinecode">r[0]</span> to <span class="d_inlinecode">r[nth]</span> satisfy <span class="d_inlinecode">!less(r[nth], e1)</span>,
and all elements <span class="d_inlinecode">e2</span> from <span class="d_inlinecode">r[nth]</span> to <span class="d_inlinecode">r[r.length]</span> satisfy
<span class="d_inlinecode">!less(e2, r[nth])</span>. Effectively, it finds the nth smallest
(according to <span class="d_inlinecode">less</span>) elements in <span class="d_inlinecode">r</span>. Performs an expected
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length</span><b><i>)</i></b> (if unstable) or <b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length * log(r.length)</span><b><i>)</i></b>
(if stable) evaluations of <span class="d_inlinecode">less</span> and <span class="d_inlinecode">swap</span>. See also <a href="http://sgi.com/tech/stl/nth_element.html">STL's nth_element</a>.
<p></p>
If <span class="d_inlinecode">n &gt;= r.length</span>, the algorithm has no effect.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">int</span>[] v = [ 25, 7, 9, 2, 0, 5, 21 ];
<span class="d_keyword">auto</span> n = 4;
<span class="d_psymbol">topN</span>!(less)(v, n);
<span class="d_keyword">assert</span>(v[n] == 9);
<span class="d_comment">// Equivalent form:
</span><span class="d_psymbol">topN</span>!(<span class="d_string">"a &lt; b"</span>)(v, n);
<span class="d_keyword">assert</span>(v[n] == 9);
</pre>

<p></p>
<span style="color:red">BUGS:</span><br>Stable <a name="topN"></a><span class="ddoc_psymbol">topN</span> has not been implemented yet.<p></p>

</dd>
<dt class="d_decl"><a name=".topN"></a>void <a name="topN"></a><span class="ddoc_psymbol">topN</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range1, Range2)(Range1 <i>r1</i>, Range2 <i>r2</i>) if (isRandomAccessRange!Range1 &amp;&amp; hasLength!Range1 &amp;&amp; isInputRange!Range2 &amp;&amp; is(ElementType!Range1 == ElementType!Range2));
</dt>
<dd>Stores the smallest elements of the two ranges in the left-hand range.<p></p>
<b>Examples:</b><br>Ditto
<pre class="d_code">
    <span class="d_keyword">int</span>[] a = [ 5, 7, 2, 6, 7 ];
    <span class="d_keyword">int</span>[] b = [ 2, 1, 5, 6, 7, 3, 0 ];
    <span class="d_psymbol">topN</span>(a, b);
    sort(a);
    <span class="d_keyword">assert</span>(a == [0, 1, 2, 2, 3]);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".sort"></a>SortedRange!(Range, less) <a name="sort"></a><span class="ddoc_psymbol">sort</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>) if ((ss == SwapStrategy.unstable &amp;&amp; (hasSwappableElements!Range || hasAssignableElements!Range) || ss != SwapStrategy.unstable &amp;&amp; hasAssignableElements!Range) &amp;&amp; isRandomAccessRange!Range &amp;&amp; hasSlicing!Range &amp;&amp; hasLength!Range);
</dt>
<dd>Sorts a random-access range according to the predicate <span class="d_inlinecode">less</span>. Performs
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length * log(r.length)</span><b><i>)</i></b> (if unstable) or <b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length *
log(r.length) * log(r.length)</span><b><i>)</i></b> (if stable) evaluations of <span class="d_inlinecode">less</span>
and <span class="d_inlinecode">swap</span>. See also STL's <a href="http://sgi.com/tech/stl/sort.html">sort</a>
and <a href="http://sgi.com/tech/stl/stable_sort.html">stable_sort</a>.
<p></p>
<span class="d_inlinecode"><a name="sort"></a><span class="ddoc_psymbol">sort</span></span> returns a <a href="std_range.html#SortedRange"><span class="d_inlinecode">std.range.SortedRange</span></a> over the original range, which
functions that can take advantage of sorted data can then use to know that the
range is sorted and adjust accordingly. The <a href="std_range.html#SortedRange"><span class="d_inlinecode">std.range.SortedRange</span></a> is a
wrapper around the original range, so both it and the original range are sorted,
but other functions won't know that the original range has been sorted, whereas
they <i>can</i> know that <a href="std_range.html#SortedRange"><span class="d_inlinecode">std.range.SortedRange</span></a> has been sorted.

<p></p>
<b>See Also:</b><br><a href="std_range.html#assumeSorted"><span class="d_inlinecode">std.range.assumeSorted</span></a>

<p></p>
<b>Remark:</b><br>
Stable <a name="sort"></a><span class="ddoc_psymbol">sort</span> is implementated as Timsort, the original code at
<a href="http://github.com/Xinok/XSort">XSort</a> by Xinok, public domain.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] array = [ 1, 2, 3, 4 ];
<span class="d_comment">// sort in descending order
</span><span class="d_psymbol">sort</span>!(<span class="d_string">"a &gt; b"</span>)(array);
<span class="d_keyword">assert</span>(array == [ 4, 3, 2, 1 ]);
<span class="d_comment">// sort in ascending order
</span><span class="d_psymbol">sort</span>(array);
<span class="d_keyword">assert</span>(array == [ 1, 2, 3, 4 ]);
<span class="d_comment">// sort with a delegate
</span><span class="d_keyword">bool</span> myComp(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> x &gt; y; }
<span class="d_psymbol">sort</span>!(myComp)(array);
<span class="d_keyword">assert</span>(array == [ 4, 3, 2, 1 ]);
<span class="d_comment">// Showcase stable sorting
</span>string[] words = [ <span class="d_string">"aBc"</span>, <span class="d_string">"a"</span>, <span class="d_string">"abc"</span>, <span class="d_string">"b"</span>, <span class="d_string">"ABC"</span>, <span class="d_string">"c"</span> ];
<span class="d_psymbol">sort</span>!(<span class="d_string">"toUpper(a) &lt; toUpper(b)"</span>, SwapStrategy.stable)(words);
<span class="d_keyword">assert</span>(words == [ <span class="d_string">"a"</span>, <span class="d_string">"aBc"</span>, <span class="d_string">"abc"</span>, <span class="d_string">"ABC"</span>, <span class="d_string">"b"</span>, <span class="d_string">"c"</span> ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".multiSort"></a>template <a name="multiSort"></a><span class="ddoc_psymbol">multiSort</span>(less...)</dt>
<dd><span class="d_inlinecode">void <a name="multiSort"></a><span class="ddoc_psymbol">multiSort</span>(Range)(Range r)
    if (validPredicates!(ElementType!Range, less));</span>
<p></p>
Sorts a range by multiple keys. The call <span class="d_inlinecode"><a name="multiSort"></a><span class="ddoc_psymbol">multiSort</span>!("a.id &lt; b.id",
"a.date &gt; b.date")(r)</span> sorts the range <span class="d_inlinecode">r</span> by <span class="d_inlinecode">id</span> ascending,
and sorts elements that have the same <span class="d_inlinecode">id</span> by <span class="d_inlinecode">date</span>
descending. Such a call is equivalent to <span class="d_inlinecode">sort!"a.id != b.id ? a.id
&lt; b.id : a.date &gt; b.date"(r)</span>, but <span class="d_inlinecode"><a name="multiSort"></a><span class="ddoc_psymbol">multiSort</span></span> is faster because it
does fewer comparisons (in addition to being more convenient).

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">static</span> <span class="d_keyword">struct</span> Point { <span class="d_keyword">int</span> x, y; }
<span class="d_keyword">auto</span> pts1 = [ Point(0, 0), Point(5, 5), Point(0, 1), Point(0, 2) ];
<span class="d_keyword">auto</span> pts2 = [ Point(0, 0), Point(0, 1), Point(0, 2), Point(5, 5) ];
<span class="d_psymbol">multiSort</span>!(<span class="d_string">"a.x &lt; b.x"</span>, <span class="d_string">"a.y &lt; b.y"</span>, SwapStrategy.unstable)(pts1);
<span class="d_keyword">assert</span>(pts1 == pts2);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".schwartzSort"></a>SortedRange!(R, (a, b) =&gt; binaryFun!less(unaryFun!transform(a), unaryFun!transform(b))) <a name="schwartzSort"></a><span class="ddoc_psymbol">schwartzSort</span>(alias transform, alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, R)(R <i>r</i>) if (isRandomAccessRange!R &amp;&amp; hasLength!R);
</dt>
<dd>Sorts a range using an algorithm akin to the <a href="http://wikipedia.org/wiki/Schwartzian_transform">Schwartzian transform</a>, also
known as the decorate-sort-undecorate pattern in Python and Lisp. (Not
to be confused with <a href="http://youtube.com/watch?v=UHw6KXbvazs">the other
Schwartz</a>.) This function is helpful when the sort comparison includes
an expensive computation. The complexity is the same as that of the
corresponding <span class="d_inlinecode">sort</span>, but <span class="d_inlinecode"><a name="schwartzSort"></a><span class="ddoc_psymbol">schwartzSort</span></span> evaluates <span class="d_inlinecode">transform</span> only <span class="d_inlinecode">r.length</span> times (less than half when compared to
regular sorting). The usage can be best illustrated with an example.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">uint</span> hashFun(string) { ... expensive computation ... }
string[] array = ...;
<span class="d_comment">// Sort strings by hash, slow
</span>sort!((a, b) =&gt; hashFun(a) &lt; hashFun(b))(array);
<span class="d_comment">// Sort strings by hash, fast (only computes arr.length hashes):
</span><span class="d_psymbol">schwartzSort</span>!(hashFun, <span class="d_string">"a &lt; b"</span>)(array);
</pre>
<p></p>

The <span class="d_inlinecode"><a name="schwartzSort"></a><span class="ddoc_psymbol">schwartzSort</span></span> function might require less temporary data and
be faster than the Perl idiom or the decorate-sort-undecorate idiom
present in Python and Lisp. This is because sorting is done in-place
and only minimal extra data (one array of transformed elements) is
created.
<p></p>

To check whether an array was sorted and benefit of the speedup of
Schwartz sorting, a function <span class="d_inlinecode">schwartzIsSorted</span> is not provided
because the effect can be achieved by calling <span class="d_inlinecode">isSorted!less(map!transform(r))</span>.

<p></p>
<b>Returns:</b><br>The initial range wrapped as a <span class="d_inlinecode">SortedRange</span> with the
predicate <span class="d_inlinecode">(a, b) =&gt; binaryFun!less(transform(a),
transform(b))</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".partialSort"></a>void <a name="partialSort"></a><span class="ddoc_psymbol">partialSort</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range)(Range <i>r</i>, size_t <i>n</i>) if (isRandomAccessRange!Range &amp;&amp; hasLength!Range &amp;&amp; hasSlicing!Range);
</dt>
<dd>Reorders the random-access range <span class="d_inlinecode">r</span> such that the range <span class="d_inlinecode">r[0
.. mid]</span> is the same as if the entire <span class="d_inlinecode">r</span> were sorted, and leaves
the range <span class="d_inlinecode">r[mid .. r.length]</span> in no particular order. Performs
<b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length * log(mid)</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">pred</span>. The
implementation simply calls <span class="d_inlinecode">topN!(less, ss)(r, n)</span> and then <span class="d_inlinecode">sort!(less, ss)(r[0 .. n])</span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ];
<span class="d_psymbol">partialSort</span>(a, 5);
<span class="d_keyword">assert</span>(a[0 .. 5] == [ 0, 1, 2, 3, 4 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".completeSort"></a>void <a name="completeSort"></a><span class="ddoc_psymbol">completeSort</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range1, Range2)(SortedRange!(Range1, less) <i>lhs</i>, Range2 <i>rhs</i>) if (hasLength!Range2 &amp;&amp; hasSlicing!Range2);
</dt>
<dd>Sorts the random-access range <span class="d_inlinecode">chain(lhs, rhs)</span> according to
predicate <span class="d_inlinecode">less</span>. The left-hand side of the range <span class="d_inlinecode">lhs</span> is
assumed to be already sorted; <span class="d_inlinecode">rhs</span> is assumed to be unsorted. The
exact strategy chosen depends on the relative sizes of <span class="d_inlinecode">lhs</span> and
<span class="d_inlinecode">rhs</span>.  Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">lhs.length + rhs.length * log(rhs.length)</span><b><i>)</i></b>
(best case) to <b><i>&Omicron;</i>(</b><span class="d_inlinecode">(lhs.length + rhs.length) * log(lhs.length +
rhs.length)</span><b><i>)</i></b> (worst-case) evaluations of <span class="d_inlinecode">swap</span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 3 ];
<span class="d_keyword">int</span>[] b = [ 4, 0, 6, 5 ];
<span class="d_psymbol">completeSort</span>(assumeSorted(a), b);
<span class="d_keyword">assert</span>(a == [ 0, 1, 2 ]);
<span class="d_keyword">assert</span>(b == [ 3, 4, 5, 6 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".isSorted"></a>bool <a name="isSorted"></a><span class="ddoc_psymbol">isSorted</span>(alias less = "a &lt; b", Range)(Range <i>r</i>) if (isForwardRange!Range);
</dt>
<dd>Checks whether a forward range is sorted according to the comparison
operation <span class="d_inlinecode">less</span>. Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">less</span>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] arr = [4, 3, 2, 1];
<span class="d_keyword">assert</span>(!<span class="d_psymbol">isSorted</span>(arr));
sort(arr);
<span class="d_keyword">assert</span>(<span class="d_psymbol">isSorted</span>(arr));
sort!(<span class="d_string">"a &gt; b"</span>)(arr);
<span class="d_keyword">assert</span>(<span class="d_psymbol">isSorted</span>!(<span class="d_string">"a &gt; b"</span>)(arr));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".makeIndex"></a>SortedRange!(RangeIndex, (a, b) =&gt; binaryFun!less(*a, *b)) <a name="makeIndex"></a><span class="ddoc_psymbol">makeIndex</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, RangeIndex)(Range <i>r</i>, RangeIndex <i>index</i>) if (isForwardRange!Range &amp;&amp; isRandomAccessRange!RangeIndex &amp;&amp; is(ElementType!RangeIndex : ElementType!Range*));
<br><a name=".makeIndex"></a>void <a name="makeIndex"></a><span class="ddoc_psymbol">makeIndex</span>(alias less = "a &lt; b", SwapStrategy ss = SwapStrategy.unstable, Range, RangeIndex)(Range <i>r</i>, RangeIndex <i>index</i>) if (isRandomAccessRange!Range &amp;&amp; !isInfinite!Range &amp;&amp; isRandomAccessRange!RangeIndex &amp;&amp; !isInfinite!RangeIndex &amp;&amp; isIntegral!(ElementType!RangeIndex));
</dt>
<dd>Computes an index for <span class="d_inlinecode">r</span> based on the comparison <span class="d_inlinecode">less</span>. The
index is a sorted array of pointers or indices into the original
range. This technique is similar to sorting, but it is more flexible
because (1) it allows "sorting" of immutable collections, (2) allows
binary search even if the original collection does not offer random
access, (3) allows multiple indexes, each on a different predicate,
and (4) may be faster when dealing with large objects. However, using
an index may also be slower under certain circumstances due to the
extra indirection, and is always larger than a sorting-based solution
because it needs space for the index in addition to the original
collection. The complexity is the same as <span class="d_inlinecode">sort</span>'s.
<p></p>
The first overload of <span class="d_inlinecode"><a name="makeIndex"></a><span class="ddoc_psymbol">makeIndex</span></span> writes to a range containing
pointers, and the second writes to a range containing offsets. The
first overload requires <span class="d_inlinecode">Range</span> to be a forward range, and the
latter requires it to be a random-access range.
<p></p>

<span class="d_inlinecode"><a name="makeIndex"></a><span class="ddoc_psymbol">makeIndex</span></span> overwrites its second argument with the result, but
never reallocates it.

<p></p>
<b>Returns:</b><br>The pointer-based version returns a <span class="d_inlinecode">SortedRange</span> wrapper
over index, of type <span class="d_inlinecode">SortedRange!(RangeIndex, (a, b) =&gt;
binaryFun!less(*a, *b))</span> thus reflecting the ordering of the
index. The index-based version returns <span class="d_inlinecode">void</span> because the ordering
relation involves not only <span class="d_inlinecode">index</span> but also <span class="d_inlinecode">r</span>.

<p></p>
<b>Throws:</b><br>If the second argument's length is less than that of the range
indexed, an exception is thrown.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>[]) arr = [ 2, 3, 1, 5, 0 ];
<span class="d_comment">// index using pointers
</span><span class="d_keyword">auto</span> index1 = <span class="d_keyword">new</span> <span class="d_keyword">immutable</span>(<span class="d_keyword">int</span>)*[arr.length];
<span class="d_psymbol">makeIndex</span>!(<span class="d_string">"a &lt; b"</span>)(arr, index1);
<span class="d_keyword">assert</span>(isSorted!(<span class="d_string">"*a &lt; *b"</span>)(index1));
<span class="d_comment">// index using offsets
</span><span class="d_keyword">auto</span> index2 = <span class="d_keyword">new</span> size_t[arr.length];
<span class="d_psymbol">makeIndex</span>!(<span class="d_string">"a &lt; b"</span>)(arr, index2);
<span class="d_keyword">assert</span>(isSorted!
    ((size_t a, size_t b){ <span class="d_keyword">return</span> arr[a] &lt; arr[b];})
    (index2));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".SortOutput"></a>enum <a name="SortOutput"></a><span class="ddoc_psymbol">SortOutput</span>: int;
</dt>
<dd>Specifies whether the output of certain algorithm is desired in sorted
format.<p></p>

<dl><dt class="d_decl"><a name=".SortOutput.no"></a><a name="no"></a><span class="ddoc_psymbol">no</span></dt>
<dd>Don't sort output<p></p>

</dd>
<dt class="d_decl"><a name=".SortOutput.yes"></a><a name="yes"></a><span class="ddoc_psymbol">yes</span></dt>
<dd>Sort output<p></p>

</dd>
</dl>
</dd>
<dt class="d_decl"><a name=".canFind"></a>bool <a name="canFind"></a><span class="ddoc_psymbol">canFind</span>(alias pred = "a == b", R, E)(R <i>haystack</i>, E <i>needle</i>) if (is(typeof(find!pred(<i>haystack</i>, <i>needle</i>))));
</dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if and only if <span class="d_inlinecode">value</span> can be found in <span class="d_inlinecode">range</span>. Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">needle.length</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">pred</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".canFind"></a>size_t <a name="canFind"></a><span class="ddoc_psymbol">canFind</span>(alias pred = "a == b", Range, Ranges...)(Range <i>haystack</i>, Ranges <i>needles</i>) if (Ranges.length &gt; 1 &amp;&amp; allSatisfy!(isForwardRange, Ranges) &amp;&amp; is(typeof(find!pred(<i>haystack</i>, <i>needles</i>))));
</dt>
<dd>Returns the 1-based index of the first needle found in <span class="d_inlinecode">haystack</span>. If no
    needle is found, then <span class="d_inlinecode">0</span> is returned.
<p></p>
So, if used directly in the condition of an if statement or loop, the result
    will be <span class="d_inlinecode"><b>true</b></span> if one of the needles is found and <span class="d_inlinecode"><b>false</b></span> if none are
    found, whereas if the result is used elsewhere, it can either be cast to
    <span class="d_inlinecode">bool</span> for the same effect or used to get which needle was found first
    without having to deal with the tuple that <span class="d_inlinecode">LREF find</span> returns for the
    same operation.<p></p>

</dd>
<dt class="d_decl"><a name=".any"></a>bool <a name="any"></a><span class="ddoc_psymbol">any</span>(alias pred, Range)(Range <i>range</i>) if (is(typeof(find!pred(<i>range</i>))));
</dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if and only if a value <span class="d_inlinecode">v</span> satisfying the
predicate <span class="d_inlinecode">pred</span> can be found in the forward range <span class="d_inlinecode">range</span>. Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">pred</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".all"></a>bool <a name="all"></a><span class="ddoc_psymbol">all</span>(alias pred, R)(R <i>range</i>) if (isInputRange!R &amp;&amp; is(typeof(unaryFun!pred(<i>range</i>.front))));
</dt>
<dd>Returns <span class="d_inlinecode"><b>true</b></span> if and only if <a name="all"></a><span class="ddoc_psymbol">all</span> values in <span class="d_inlinecode">range</span> satisfy the
predicate <span class="d_inlinecode">pred</span>.  Performs <b><i>&Omicron;</i>(</b><span class="d_inlinecode">r.length</span><b><i>)</i></b> evaluations of <span class="d_inlinecode">pred</span>.
<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">assert</span>(<span class="d_psymbol">all</span>!<span class="d_string">"a &amp; 1"</span>([1, 3, 5, 7, 9]));
<span class="d_keyword">assert</span>(!<span class="d_psymbol">all</span>!<span class="d_string">"a &amp; 1"</span>([1, 2, 3, 5, 7, 9]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".topNCopy"></a>TRange <a name="topNCopy"></a><span class="ddoc_psymbol">topNCopy</span>(alias less = "a &lt; b", SRange, TRange)(SRange <i>source</i>, TRange <i>target</i>, SortOutput <i>sorted</i> = SortOutput.no) if (isInputRange!SRange &amp;&amp; isRandomAccessRange!TRange &amp;&amp; hasLength!TRange &amp;&amp; hasSlicing!TRange);
</dt>
<dd>Copies the top <span class="d_inlinecode">n</span> elements of the input range <span class="d_inlinecode">source</span> into the
random-access range <span class="d_inlinecode">target</span>, where <span class="d_inlinecode">n =
target.length</span>. Elements of <span class="d_inlinecode">source</span> are not touched. If <span class="d_inlinecode">sorted</span> is <span class="d_inlinecode"><b>true</b></span>, the target is sorted. Otherwise, the target
respects the <a href="http://en.wikipedia.org/wiki/Binary_heap">heap property</a>.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 10, 16, 2, 3, 1, 5, 0 ];
<span class="d_keyword">int</span>[] b = <span class="d_keyword">new</span> <span class="d_keyword">int</span>[3];
<span class="d_psymbol">topNCopy</span>(a, b, <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(b == [ 0, 1, 2 ]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".SetUnion"></a>struct <a name="SetUnion"></a><span class="ddoc_psymbol">SetUnion</span>(alias less = "a &lt; b", Rs...) if (allSatisfy!(isInputRange, Rs));
<br><a name=".setUnion"></a>SetUnion!(less, Rs) <a name="setUnion"></a><span class="ddoc_psymbol">setUnion</span>(alias less = "a &lt; b", Rs...)(Rs <i>rs</i>);
</dt>
<dd>Lazily computes the union of two or more ranges <span class="d_inlinecode">rs</span>. The ranges
are assumed to be sorted by <span class="d_inlinecode">less</span>. Elements in the output are not
unique; the length of the output is the sum of the lengths of the
inputs. (The <span class="d_inlinecode">length</span> member is offered if all ranges also have
length.) The element types of all ranges must have a common type.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 5, 7, 9 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 4, 7, 8 ];
<span class="d_keyword">int</span>[] c = [ 10 ];
<span class="d_keyword">assert</span>(setUnion(a, b).length == a.length + b.length);
<span class="d_keyword">assert</span>(equal(setUnion(a, b), [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9][]));
<span class="d_keyword">assert</span>(equal(setUnion(a, c, b),
    [0, 1, 1, 2, 2, 4, 4, 5, 7, 7, 8, 9, 10][]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".SetIntersection"></a>struct <a name="SetIntersection"></a><span class="ddoc_psymbol">SetIntersection</span>(alias less = "a &lt; b", Rs...) if (allSatisfy!(isInputRange, Rs));
<br><a name=".setIntersection"></a>SetIntersection!(less, Rs) <a name="setIntersection"></a><span class="ddoc_psymbol">setIntersection</span>(alias less = "a &lt; b", Rs...)(Rs <i>ranges</i>) if (allSatisfy!(isInputRange, Rs));
</dt>
<dd>Lazily computes the intersection of two or more input ranges <span class="d_inlinecode">rs</span>. The ranges are assumed to be sorted by <span class="d_inlinecode">less</span>. The element
types of all ranges must have a common type.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 5, 7, 9 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 4, 7, 8 ];
<span class="d_keyword">int</span>[] c = [ 0, 1, 4, 5, 7, 8 ];
<span class="d_keyword">assert</span>(equal(setIntersection(a, a), a));
<span class="d_keyword">assert</span>(equal(setIntersection(a, b), [1, 2, 4, 7][]));
<span class="d_keyword">assert</span>(equal(setIntersection(a, b, c), [1, 4, 7][]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".SetDifference"></a>struct <a name="SetDifference"></a><span class="ddoc_psymbol">SetDifference</span>(alias less = "a &lt; b", R1, R2) if (isInputRange!R1 &amp;&amp; isInputRange!R2);
<br><a name=".setDifference"></a>SetDifference!(less, R1, R2) <a name="setDifference"></a><span class="ddoc_psymbol">setDifference</span>(alias less = "a &lt; b", R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>);
</dt>
<dd>Lazily computes the difference of <span class="d_inlinecode">r1</span> and <span class="d_inlinecode">r2</span>. The two ranges
are assumed to be sorted by <span class="d_inlinecode">less</span>. The element types of the two
ranges must have a common type.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 5, 7, 9 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 4, 7, 8 ];
<span class="d_keyword">assert</span>(equal(setDifference(a, b), [5, 9][]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".SetSymmetricDifference"></a>struct <a name="SetSymmetricDifference"></a><span class="ddoc_psymbol">SetSymmetricDifference</span>(alias less = "a &lt; b", R1, R2) if (isInputRange!R1 &amp;&amp; isInputRange!R2);
<br><a name=".setSymmetricDifference"></a>SetSymmetricDifference!(less, R1, R2) <a name="setSymmetricDifference"></a><span class="ddoc_psymbol">setSymmetricDifference</span>(alias less = "a &lt; b", R1, R2)(R1 <i>r1</i>, R2 <i>r2</i>);
</dt>
<dd>Lazily computes the symmetric difference of <span class="d_inlinecode">r1</span> and <span class="d_inlinecode">r2</span>,
i.e. the elements that are present in exactly one of <span class="d_inlinecode">r1</span> and <span class="d_inlinecode">r2</span>. The two ranges are assumed to be sorted by <span class="d_inlinecode">less</span>, and the
output is also sorted by <span class="d_inlinecode">less</span>. The element types of the two
ranges must have a common type.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">int</span>[] a = [ 1, 2, 4, 5, 7, 9 ];
<span class="d_keyword">int</span>[] b = [ 0, 1, 2, 4, 7, 8 ];
<span class="d_keyword">assert</span>(equal(setSymmetricDifference(a, b), [0, 5, 8, 9][]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".NWayUnion"></a>struct <a name="NWayUnion"></a><span class="ddoc_psymbol">NWayUnion</span>(alias less, RangeOfRanges);
<br><a name=".nWayUnion"></a>NWayUnion!(less, RangeOfRanges) <a name="nWayUnion"></a><span class="ddoc_psymbol">nWayUnion</span>(alias less = "a &lt; b", RangeOfRanges)(RangeOfRanges <i>ror</i>);
</dt>
<dd>Computes the union of multiple sets. The input sets are passed as a
range of ranges and each is assumed to be sorted by <span class="d_inlinecode">less</span>. Computation is done lazily, one union element at a time. The
complexity of one <span class="d_inlinecode">popFront</span> operation is <b><i>&Omicron;</i>(</b><span class="d_inlinecode">log(ror.length)</span><b><i>)</i></b>. However, the length of <span class="d_inlinecode">ror</span> decreases as ranges
in it are exhausted, so the complexity of a full pass through <span class="d_inlinecode"><a name="NWayUnion"></a><span class="ddoc_psymbol">NWayUnion</span></span> is dependent on the distribution of the lengths of ranges
contained within <span class="d_inlinecode">ror</span>. If all ranges have the same length <span class="d_inlinecode">n</span>
(worst case scenario), the complexity of a full pass through <span class="d_inlinecode"><a name="NWayUnion"></a><span class="ddoc_psymbol">NWayUnion</span></span> is <b><i>&Omicron;</i>(</b><span class="d_inlinecode">n * ror.length * log(ror.length)</span><b><i>)</i></b>, i.e., <span class="d_inlinecode">log(ror.length)</span> times worse than just spanning all ranges in
turn. The output comes sorted (unstably) by <span class="d_inlinecode">less</span>.
<p></p>
<b>Warning:</b><br>
Because <span class="d_inlinecode"><a name="NWayUnion"></a><span class="ddoc_psymbol">NWayUnion</span></span> does not allocate extra memory, it
will leave <span class="d_inlinecode">ror</span> modified. Namely, <span class="d_inlinecode"><a name="NWayUnion"></a><span class="ddoc_psymbol">NWayUnion</span></span> assumes ownership
of <span class="d_inlinecode">ror</span> and discretionarily swaps and advances elements of it. If
you want <span class="d_inlinecode">ror</span> to preserve its contents after the call, you may
want to pass a duplicate to <span class="d_inlinecode"><a name="NWayUnion"></a><span class="ddoc_psymbol">NWayUnion</span></span> (and perhaps cache the
duplicate in between calls).

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_keyword">double</span>[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
<span class="d_keyword">auto</span> witness = [
    1, 1, 1, 4, 4, 7, 7, 7, 7, 8, 8
];
<span class="d_keyword">assert</span>(equal(nWayUnion(a), witness[]));
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".largestPartialIntersection"></a>void <a name="largestPartialIntersection"></a><span class="ddoc_psymbol">largestPartialIntersection</span>(alias less = "a &lt; b", RangeOfRanges, Range)(RangeOfRanges <i>ror</i>, Range <i>tgt</i>, SortOutput <i>sorted</i> = SortOutput.no);
</dt>
<dd>Given a range of sorted forward ranges <span class="d_inlinecode">ror</span>, copies to <span class="d_inlinecode">tgt</span>
the elements that are common to most ranges, along with their number
of occurrences. All ranges in <span class="d_inlinecode">ror</span> are assumed to be sorted by <span class="d_inlinecode">less</span>. Only the most frequent <span class="d_inlinecode">tgt.length</span> elements are returned.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Figure which number can be found in most arrays of the set of
</span><span class="d_comment">// arrays below.
</span><span class="d_keyword">double</span>[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
<span class="d_keyword">auto</span> b = <span class="d_keyword">new</span> Tuple!(<span class="d_keyword">double</span>, <span class="d_keyword">uint</span>)[1];
<span class="d_psymbol">largestPartialIntersection</span>(a, b);
<span class="d_comment">// First member is the item, second is the occurrence count
</span><span class="d_keyword">assert</span>(b[0] == tuple(7.0, 4u));
</pre>
<p></p>

<span class="d_inlinecode">7.0</span> is the correct answer because it occurs in <span class="d_inlinecode">4</span> out of the
<span class="d_inlinecode">5</span> inputs, more than any other number. The second member of the
resulting tuple is indeed <span class="d_inlinecode">4</span> (recording the number of occurrences
of <span class="d_inlinecode">7.0</span>). If more of the top-frequent numbers are needed, just
create a larger <span class="d_inlinecode">tgt</span> range. In the axample above, creating <span class="d_inlinecode">b</span>
with length <span class="d_inlinecode">2</span> yields <span class="d_inlinecode">tuple(1.0, 3u)</span> in the second position.
<p></p>

The function <span class="d_inlinecode"><a name="largestPartialIntersection"></a><span class="ddoc_psymbol">largestPartialIntersection</span></span> is useful for
e.g. searching an <a href="http://google.com/search?btnI=I%27m+Feeling+Lucky&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=inverted index">inverted index</a> for the documents most
likely to contain some terms of interest. The complexity of the search
is <b><i>&Omicron;</i>(</b><span class="d_inlinecode">n * log(tgt.length)</span><b><i>)</i></b>, where <span class="d_inlinecode">n</span> is the sum of lengths of
all input ranges. This approach is faster than keeping an associative
array of the occurrences and then selecting its top items, and also
requires less memory (<span class="d_inlinecode"><a name="largestPartialIntersection"></a><span class="ddoc_psymbol">largestPartialIntersection</span></span> builds its
result directly in <span class="d_inlinecode">tgt</span> and requires no extra memory).

<p></p>
<b>Warning:</b><br>
Because <span class="d_inlinecode"><a name="largestPartialIntersection"></a><span class="ddoc_psymbol">largestPartialIntersection</span></span> does not allocate
extra memory, it will leave <span class="d_inlinecode">ror</span> modified. Namely, <span class="d_inlinecode"><a name="largestPartialIntersection"></a><span class="ddoc_psymbol">largestPartialIntersection</span></span> assumes ownership of <span class="d_inlinecode">ror</span> and
discretionarily swaps and advances elements of it. If you want <span class="d_inlinecode">ror</span> to preserve its contents after the call, you may want to pass a
duplicate to <span class="d_inlinecode"><a name="largestPartialIntersection"></a><span class="ddoc_psymbol">largestPartialIntersection</span></span> (and perhaps cache the
duplicate in between calls).<p></p>

</dd>
<dt class="d_decl"><a name=".largestPartialIntersectionWeighted"></a>void <a name="largestPartialIntersectionWeighted"></a><span class="ddoc_psymbol">largestPartialIntersectionWeighted</span>(alias less = "a &lt; b", RangeOfRanges, Range, WeightsAA)(RangeOfRanges <i>ror</i>, Range <i>tgt</i>, WeightsAA <i>weights</i>, SortOutput <i>sorted</i> = SortOutput.no);
</dt>
<dd>Similar to <span class="d_inlinecode">largestPartialIntersection</span>, but associates a weight
with each distinct element in the intersection.
<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Figure which number can be found in most arrays of the set of
</span><span class="d_comment">// arrays below, with specific per-element weights
</span><span class="d_keyword">double</span>[][] a =
[
    [ 1, 4, 7, 8 ],
    [ 1, 7 ],
    [ 1, 7, 8],
    [ 4 ],
    [ 7 ],
];
<span class="d_keyword">auto</span> b = <span class="d_keyword">new</span> Tuple!(<span class="d_keyword">double</span>, <span class="d_keyword">uint</span>)[1];
<span class="d_keyword">double</span>[<span class="d_keyword">double</span>] weights = [ 1:1.2, 4:2.3, 7:1.1, 8:1.1 ];
<span class="d_psymbol">largestPartialIntersectionWeighted</span>(a, b, weights);
<span class="d_comment">// First member is the item, second is the occurrence count
</span><span class="d_keyword">assert</span>(b[0] == tuple(4.0, 2u));
</pre>
<p></p>

The correct answer in this case is <span class="d_inlinecode">4.0</span>, which, although only
appears two times, has a total weight <span class="d_inlinecode">4.6</span> (three times its weight
<span class="d_inlinecode">2.3</span>). The value <span class="d_inlinecode">7</span> is weighted with <span class="d_inlinecode">1.1</span> and occurs four
times for a total weight <span class="d_inlinecode">4.4</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".nextPermutation"></a>bool <a name="nextPermutation"></a><span class="ddoc_psymbol">nextPermutation</span>(alias less = "a&lt;b", BidirectionalRange)(ref BidirectionalRange <i>range</i>) if (isBidirectionalRange!BidirectionalRange &amp;&amp; hasSwappableElements!BidirectionalRange);
</dt>
<dd>Permutes <span class="d_inlinecode">range</span> in-place to the next lexicographically greater
 permutation.
<p></p>
The predicate <span class="d_inlinecode">less</span> defines the lexicographical ordering to be used on
 the range.
<p></p>

 If the range is currently the lexicographically greatest permutation, it is
 permuted back to the least permutation and <b>false</b> is returned.  Otherwise,
 <b>true</b> is returned. One can thus generate all permutations of a range by
 sorting it according to <span class="d_inlinecode">less</span>, which produces the lexicographically
 least permutation, and then calling <a name="nextPermutation"></a><span class="ddoc_psymbol">nextPermutation</span> until it returns <b>false</b>.
 This is guaranteed to generate all distinct permutations of the range
 exactly once.  If there are <i>N</i> elements in the range and all of them are
 unique, then <i>N</i>! permutations will be generated. Otherwise, if there are
 some duplicated elements, fewer permutations will be produced.
<pre class="d_code"><span class="d_comment">// Enumerate all permutations
</span><span class="d_keyword">int</span>[] a = [1,2,3,4,5];
<span class="d_keyword">while</span> (<span class="d_psymbol">nextPermutation</span>(a))
{
    <span class="d_comment">// a now contains the next permutation of the array.
</span>}
</pre>
<p></p>
<b>Returns:</b><br><b>false</b> if the range was lexicographically the greatest, in which
 case the range is reversed back to the lexicographically smallest
 permutation; otherwise returns <b>true</b>.

<p></p>
<b>Example:</b><br>
<pre class="d_code"><span class="d_comment">// Step through all permutations of a sorted array in lexicographic order
</span><span class="d_keyword">int</span>[] a = [1,2,3];
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [1,3,2]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [2,1,3]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [2,3,1]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [3,1,2]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [3,2,1]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">false</span>);
<span class="d_keyword">assert</span>(a == [1,2,3]);
</pre>
<pre class="d_code"><span class="d_comment">// Step through permutations of an array containing duplicate elements:
</span><span class="d_keyword">int</span>[] a = [1,1,2];
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [1,2,1]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [2,1,1]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextPermutation</span>(a) == <span class="d_keyword">false</span>);
<span class="d_keyword">assert</span>(a == [1,1,2]);
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".nextEvenPermutation"></a>bool <a name="nextEvenPermutation"></a><span class="ddoc_psymbol">nextEvenPermutation</span>(alias less = "a&lt;b", BidirectionalRange)(ref BidirectionalRange <i>range</i>) if (isBidirectionalRange!BidirectionalRange &amp;&amp; hasSwappableElements!BidirectionalRange);
</dt>
<dd>Permutes <span class="d_inlinecode">range</span> in-place to the next lexicographically greater <i>even</i>
 permutation.
<p></p>
The predicate <span class="d_inlinecode">less</span> defines the lexicographical ordering to be used on
 the range.
<p></p>

 An even permutation is one which is produced by swapping an even number of
 pairs of elements in the original range. The set of <i>even</i> permutations
 is distinct from the set of <i>all</i> permutations only when there are no
 duplicate elements in the range. If the range has <i>N</i> unique elements,
 then there are exactly <i>N</i>!/2 even permutations.
<p></p>

 If the range is already the lexicographically greatest even permutation, it
 is permuted back to the least even permutation and <b>false</b> is returned.
 Otherwise, <b>true</b> is returned, and the range is modified in-place to be the
 lexicographically next even permutation.
<p></p>

 One can thus generate the even permutations of a range with unique elements
 by starting with the lexicographically smallest permutation, and repeatedly
 calling <a name="nextEvenPermutation"></a><span class="ddoc_psymbol">nextEvenPermutation</span> until it returns <b>false</b>.
<pre class="d_code"><span class="d_comment">// Enumerate even permutations
</span><span class="d_keyword">int</span>[] a = [1,2,3,4,5];
<span class="d_keyword">while</span> (<span class="d_psymbol">nextEvenPermutation</span>(a))
{
    <span class="d_comment">// a now contains the next even permutation of the array.
</span>}
</pre>
 One can also generate the <i>odd</i> permutations of a range by noting that
 permutations obey the rule that even + even = even, and odd + even = odd.
 Thus, by swapping the last two elements of a lexicographically least range,
 it is turned into the first odd permutation. Then calling
 <a name="nextEvenPermutation"></a><span class="ddoc_psymbol">nextEvenPermutation</span> on this first odd permutation will generate the next
 even permutation relative to this odd permutation, which is actually the
 next odd permutation of the original range. Thus, by repeatedly calling
 <a name="nextEvenPermutation"></a><span class="ddoc_psymbol">nextEvenPermutation</span> until it returns <b>false</b>, one enumerates the odd
 permutations of the original range.
<pre class="d_code"><span class="d_comment">// Enumerate odd permutations
</span><span class="d_keyword">int</span>[] a = [1,2,3,4,5];
swap(a[$-2], a[$-1]);    <span class="d_comment">// a is now the first odd permutation of [1,2,3,4,5]
</span><span class="d_keyword">while</span> (<span class="d_psymbol">nextEvenPermutation</span>(a))
{
    <span class="d_comment">// a now contains the next odd permutation of the original array
</span>    <span class="d_comment">// (which is an even permutation of the first odd permutation).
</span>}
</pre>

<p></p>
<b>Warning:</b><br>
Since even permutations are only distinct from all permutations
 when the range elements are unique, this function assumes that there are no
 duplicate elements under the specified ordering. If this is not true, some
 permutations may fail to be generated. When the range has non-unique
 elements, you should use <font face='Consolas, "Bitstream Vera Sans Mono", "Andale Mono", Monaco, "DejaVu Sans Mono", "Lucida Console", monospace'><a href="#nextPermutation">nextPermutation</a>&nbsp;</font> instead.

<p></p>
<b>Returns:</b><br><b>false</b> if the range was lexicographically the greatest, in which
 case the range is reversed back to the lexicographically smallest
 permutation; otherwise returns <b>true</b>.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_comment">// Step through even permutations of a sorted array in lexicographic order
</span><span class="d_keyword">int</span>[] a = [1,2,3];
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextEvenPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [2,3,1]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextEvenPermutation</span>(a) == <span class="d_keyword">true</span>);
<span class="d_keyword">assert</span>(a == [3,1,2]);
<span class="d_keyword">assert</span>(<span class="d_psymbol">nextEvenPermutation</span>(a) == <span class="d_keyword">false</span>);
<span class="d_keyword">assert</span>(a == [1,2,3]);
</pre>
 Even permutations are useful for generating coordinates of certain geometric
 shapes. Here's a non-trivial example:
<pre class="d_code"><span class="d_comment">// Print the 60 vertices of a uniform truncated icosahedron (soccer ball)
</span><span class="d_keyword">import</span> std.math, std.stdio;
<span class="d_keyword">enum</span> <span class="d_keyword">real</span> Phi = (1.0 + sqrt(5.0)) / 2.0;    <span class="d_comment">// Golden ratio
</span><span class="d_keyword">real</span>[][] seeds = [
    [0.0, 1.0, 3.0*Phi],
    [1.0, 2.0+Phi, 2.0*Phi],
    [Phi, 2.0, Phi^^3]
];
<span class="d_keyword">foreach</span> (seed; seeds)
{
    <span class="d_comment">// Loop over even permutations of each seed
</span>    <span class="d_keyword">do</span>
    {
        <span class="d_comment">// Loop over all sign changes of each permutation
</span>        size_t i;
        <span class="d_keyword">do</span>
        {
            <span class="d_comment">// Generate all possible sign changes
</span>            <span class="d_keyword">for</span> (i=0; i &lt; seed.length; i++)
            {
                <span class="d_keyword">if</span> (seed[i] != 0.0)
                {
                    seed[i] = -seed[i];
                    <span class="d_keyword">if</span> (seed[i] &lt; 0.0)
                        <span class="d_keyword">break</span>;
                }
            }
            writeln(seed);
        } <span class="d_keyword">while</span> (i &lt; seed.length);
    } <span class="d_keyword">while</span> (<span class="d_psymbol">nextEvenPermutation</span>(seed));
}
</pre>
<p></p>

</dd>
<dt class="d_decl"><a name=".cartesianProduct"></a>auto <a name="cartesianProduct"></a><span class="ddoc_psymbol">cartesianProduct</span>(R1, R2)(R1 <i>range1</i>, R2 <i>range2</i>);
<br><a name=".cartesianProduct"></a>auto <a name="cartesianProduct"></a><span class="ddoc_psymbol">cartesianProduct</span>(R1, R2, RR...)(R1 <i>range1</i>, R2 <i>range2</i>, RR <i>otherRanges</i>);
</dt>
<dd>Lazily computes the Cartesian product of two or more ranges. The product is a
range of tuples of elements from each respective range.
<p></p>
The conditions for the two-range case are as follows:
<p></p>

If both ranges are finite, then one must be (at least) a forward range and the
other an input range.
<p></p>

If one range is infinite and the other finite, then the finite range must
be a forward range, and the infinite range can be an input range.
<p></p>

If both ranges are infinite, then both must be forward ranges.
<p></p>

When there are more than two ranges, the above conditions apply to each
adjacent pair of ranges.

<p></p>
<b>Examples:</b><br><pre class="d_code"><span class="d_keyword">auto</span> N = sequence!<span class="d_string">"n"</span>(0);         <span class="d_comment">// the range of natural numbers
</span><span class="d_keyword">auto</span> N2 = <span class="d_psymbol">cartesianProduct</span>(N, N); <span class="d_comment">// the range of all pairs of natural numbers
</span>
<span class="d_comment">// Various arbitrary number pairs can be found in the range in finite time.
</span><span class="d_keyword">assert</span>(canFind(N2, tuple(0, 0)));
<span class="d_keyword">assert</span>(canFind(N2, tuple(123, 321)));
<span class="d_keyword">assert</span>(canFind(N2, tuple(11, 35)));
<span class="d_keyword">assert</span>(canFind(N2, tuple(279, 172)));
</pre>
<p></p>

<pre class="d_code"><span class="d_keyword">auto</span> B = [ 1, 2, 3 ];
<span class="d_keyword">auto</span> C = [ 4, 5, 6 ];
<span class="d_keyword">auto</span> BC = <span class="d_psymbol">cartesianProduct</span>(B, C);

<span class="d_keyword">foreach</span> (n; [[1, 4], [2, 4], [3, 4], [1, 5], [2, 5], [3, 5], [1, 6],
             [2, 6], [3, 6]])
{
    <span class="d_keyword">assert</span>(canFind(BC, tuple(n[0], n[1])));
}
</pre>
<p></p>

<pre class="d_code"><span class="d_keyword">auto</span> A = [ 1, 2, 3 ];
<span class="d_keyword">auto</span> B = [ 'a', 'b', 'c' ];
<span class="d_keyword">auto</span> C = [ <span class="d_string">"x"</span>, <span class="d_string">"y"</span>, <span class="d_string">"z"</span> ];
<span class="d_keyword">auto</span> ABC = <span class="d_psymbol">cartesianProduct</span>(A, B, C);

<span class="d_keyword">assert</span>(ABC.equal([
    tuple(1, 'a', <span class="d_string">"x"</span>), tuple(2, 'a', <span class="d_string">"x"</span>), tuple(3, 'a', <span class="d_string">"x"</span>),
    tuple(1, 'b', <span class="d_string">"x"</span>), tuple(2, 'b', <span class="d_string">"x"</span>), tuple(3, 'b', <span class="d_string">"x"</span>),
    tuple(1, 'c', <span class="d_string">"x"</span>), tuple(2, 'c', <span class="d_string">"x"</span>), tuple(3, 'c', <span class="d_string">"x"</span>),
    tuple(1, 'a', <span class="d_string">"y"</span>), tuple(2, 'a', <span class="d_string">"y"</span>), tuple(3, 'a', <span class="d_string">"y"</span>),
    tuple(1, 'b', <span class="d_string">"y"</span>), tuple(2, 'b', <span class="d_string">"y"</span>), tuple(3, 'b', <span class="d_string">"y"</span>),
    tuple(1, 'c', <span class="d_string">"y"</span>), tuple(2, 'c', <span class="d_string">"y"</span>), tuple(3, 'c', <span class="d_string">"y"</span>),
    tuple(1, 'a', <span class="d_string">"z"</span>), tuple(2, 'a', <span class="d_string">"z"</span>), tuple(3, 'a', <span class="d_string">"z"</span>),
    tuple(1, 'b', <span class="d_string">"z"</span>), tuple(2, 'b', <span class="d_string">"z"</span>), tuple(3, 'b', <span class="d_string">"z"</span>),
    tuple(1, 'c', <span class="d_string">"z"</span>), tuple(2, 'c', <span class="d_string">"z"</span>), tuple(3, 'c', <span class="d_string">"z"</span>)
]));
</pre>
<p></p>

</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div><!--/content-->


<div id="copyright">
Andrei Alexandrescu 2008-.

 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

