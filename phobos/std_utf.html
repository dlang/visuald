<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html4/loose.dtd">
<html lang='en-US'>

<!--
	Copyright (c) 1999-2010 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://www.digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>std.utf - D Programming Language - Digital Mars</title>
<link rel="stylesheet" type="text/css" href="../css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="../css/style.css">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="/js/codemirror.js"></script>
<script src="/js/d.js"></script>
<script src="/js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function listanchors()
{
    if (typeof inhibitQuickIndex !== 'undefined') return;
    var a = document.getElementById("quickindex");
    if (!a) return;
    var newText = "";
    var hash = new Array;
    var n = 0;
    var values = new Array;
    // List all anchors.
    for (var i = 0; i < document.anchors.length; i++)
    {
        var a = document.anchors[i];
        var text = a.name;
        // ignore anchors from DDOC_PSYMBOL
        if (text[0] != '.') continue;
        if (hash[text] > 0) continue;
        hash[text] = 1;
        values[n++] = a.name
    }

    // we won't display the qualifying names to save space, so sort by last name
    var lastName = function(a){
        var li = a.lastIndexOf('.');
        return a.slice(li + 1);
    }
    values.sort(function(a,b){return lastName(a) > lastName(b)});

    for(var i = 0; i < values.length; i++) {
        var a = values[i];
        var text = lastName(a);
        newText += ' \x3Ca href="\x23' + a +
            '"\x3E\x3Cspan class="d_psymbol"\x3E' + text + '\x3C/span\x3E\x3C/a\x3E';
    }
    if (newText != "") newText = "\x3Cp\x3E\x3Cb\x3EJump to:\x3C/b\x3E" + newText + "\x3C/p\x3E";
    var a = document.getElementById("quickindex");
    a.innerHTML = newText;
}
jQuery(document).ready(listanchors);
</script>

</head>

<body class='hyphenate'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="/images/search-left.gif" width="11" height="22" alt=""><input id="q" name="q"><input type="image" id="search-submit" name="submit" src="/images/search-button.gif">
			<input type="hidden" id="domains" name="domains" value="dlang.org">
			<input type="hidden" id="sourceid" name="sourceid" value="google-search">
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D  Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="www.digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a href="/"><img id="logo" width="125" height="95" border="0" alt="D Logo" src="/images/dlogo.png"></a>
		<a id="d-language" href="/">D Programming Language </a>
	</div>
</div>

<div id="navigation">
    
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input name="q" size="10" value="RTL Search" onFocus='if(this.value == "RTL Search"){this.value="";}'>
<input type="hidden" name="domains" value="www.digitalmars.com">
<input type="hidden" name="sitesearch" value="dlang.org/phobos">
<input type="hidden" name="sourceid" value="google-search">
<input type="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="../index.html" title="D Programming Language">D</a></li>
	<li><a href="../spec.html" title="D Language Specification">Language</a></li>
	<li><a href="../phobos/index.html" title="D Runtime Library">Phobos </a></li>
	<li><a href="../phobos-prerelease/index.html" title="D Runtime Library (prerelease)">Phobos (prerelease)</a></li>
	<li><a href="../comparison.html" title="Language Comparisons">Comparisons</a></li>
    </ul>
</div>
</div>

    
<div class="navblock">
    <ul>	<li><a href="object.html" title="root of object hierarchy">object</a></li>
    </ul>
    <h2><a href="index.html#std" title="D standard modules">std</a></h2>
    <ul>	<li><a href="std_algorithm.html" title="General-purpose algorithms">std.algorithm</a></li>
	<li><a href="std_array.html" title="Array functions">std.array</a></li>
	<li><a href="std_ascii.html" title="Functions which operate on ASCII characters">std.ascii</a></li>
	<li><a href="std_base64.html" title="Encode/decode base64 format">std.base64</a></li>
	<li><a href="std_bigint.html" title="Arbitrary-precision ('bignum') arithmetic">std.bigint</a></li>
	<li><a href="std_bitmanip.html" title="Bit-level manipulation">std.bitmanip</a></li>
	<li><a href="std_compiler.html" title="Information about the D compiler implementation">std.compiler</a></li>
	<li><a href="std_complex.html" title="Complex numbers">std.complex</a></li>
	<li><a href="std_concurrency.html" title="Message Passing">std.concurrency</a></li>
	<li><a href="std_container.html" title="Containers">std.container</a></li>
	<li><a href="std_conv.html" title="Conversion of strings to integers">std.conv</a></li>
	<li><a href="std_csv.html" title="CSV file parser">std.csv</a></li>
	<li><a href="std_datetime.html" title="Date and time-related types and functions">std.datetime</a></li>
	<li><a href="std_encoding.html" title="Character and string encoding">std.encoding</a></li>
	<li><a href="std_exception.html" title="Exceptions and error handling">std.exception</a></li>
	<li><a href="std_file.html" title="Basic file operations">std.file</a></li>
	<li><a href="std_format.html" title="Formatted conversions of values to strings">std.format</a></li>
	<li><a href="std_functional.html" title="functional">std.functional</a></li>
	<li><a href="std_getopt.html" title="Command line options">std.getopt</a></li>
	<li><a href="std_json.html" title="JSON reader">std.json</a></li>
	<li><a href="std_math.html" title="the usual math functions">std.math</a></li>
	<li><a href="std_mathspecial.html" title="mathematical special functions">std.mathspecial</a></li>
	<li><a href="std_metastrings.html" title="Metaprogramming with strings">std.metastrings</a></li>
	<li><a href="std_mmfile.html" title="Memory mapped files">std.mmfile</a></li>
	<li><a href="std_numeric.html" title="Numeric algorithms">std.numeric</a></li>
	<li><a href="std_outbuffer.html" title="Assemble data into an array of bytes">std.outbuffer</a></li>
	<li><a href="std_parallelism.html" title="High-level primitives for SMP parallelism">std.parallelism</a></li>
	<li><a href="std_path.html" title="Manipulate file names, path names, etc.">std.path</a></li>
	<li><a href="std_process.html" title="Create/destroy processes">std.process</a></li>
	<li><a href="std_random.html" title="Random number generation">std.random</a></li>
	<li><a href="std_range.html" title="Ranges">std.range</a></li>
	<li><a href="std_regex.html" title="regular expressions">std.regex</a></li>
	<li><a href="std_signals.html" title="Signals">std.signals</a></li>
	<li><a href="std_socket.html" title="Sockets">std.socket</a></li>
	<li><a href="std_socketstream.html" title="Stream for a blocking, connected Socket">std.socketstream</a></li>
	<li><a href="std_stdio.html" title="Standard I/O">std.stdio</a></li>
	<li><a href="std_cstream.html" title="Stream I/O">std.cstream</a></li>
	<li><a href="std_stream.html" title="Stream I/O">std.stream</a></li>
	<li><a href="std_string.html" title="Basic string operations">std.string</a></li>
	<li><a href="std_system.html" title="Inquire about the CPU, operating system">std.system</a></li>
	<li><a href="std_traits.html" title="Type traits">std.traits</a></li>
	<li><a href="std_typecons.html" title="Type constructors">std.typecons</a></li>
	<li><a href="std_typetuple.html" title="Type tuples">std.typetuple</a></li>
	<li><a href="std_uni.html" title="Unicode classification">std.uni</a></li>
	<li><a href="std_uri.html" title="Encode and decode Uniform Resource Identifiers (URIs)">std.uri</a></li>
	<li><a href="std_utf.html" title="Encode and decode utf character encodings">std.utf</a></li>
	<li><a href="std_uuid.html" title="Generate and use UUIDs">std.uuid</a></li>
	<li><a href="std_variant.html" title="Stores all types in a uniform, dynamically-checked representation">std.variant</a></li>
	<li><a href="std_xml.html" title="XML file processing">std.xml</a></li>
	<li><a href="std_zip.html" title="Read/write zip archives">std.zip</a></li>
	<li><a href="std_zlib.html" title="Compression / Decompression of data">std.zlib</a></li>
	<li><a href="std_net_curl.html" title="High level curl wrapper">std.net.curl</a></li>
	<li><a href="std_net_isemail.html" title="Validate e-mail addresses">std.net.isemail</a></li>
	<li><a href="std_digest_crc.html" title="CRC digest functions">std.digest.crc</a></li>
	<li><a href="std_digest_digest.html" title="API for digest functions">std.digest.digest</a></li>
	<li><a href="std_digest_md.html" title="MD digest functions">std.digest.md</a></li>
	<li><a href="std_digest_ripemd.html" title="RIPEMD digest functions">std.digest.ripemd</a></li>
	<li><a href="std_digest_sha.html" title="SHA digest functions">std.digest.sha</a></li>
	<li><a href="std_windows_charset.html" title="Conversion to/from Windows character sets">std.windows.charset</a></li>
    </ul>
    <h2><a href="index.html#etc" title="D etc modules">etc</a></h2>
    <ul>	<li><a href="etc_c_curl.html" title="Interface to libcurl library">etc.c.curl</a></li>
	<li><a href="etc_c_sqlite3.html" title="Interface to sqlite3 library">etc.c.sqlite3</a></li>
	<li><a href="etc_c_zlib.html" title="Interface to zlib library">etc.c.zlib</a></li>
    </ul>
    <h2><a href="index.html#core" title="D core modules">core</a></h2>
    <ul>	<li><a href="core_atomic.html" title="Atomic operations">core.atomic</a></li>
	<li><a href="core_bitop.html" title="Bitwise operations">core.bitop</a></li>
	<li><a href="core_cpuid.html" title="CPU identification">core.cpuid</a></li>
	<li><a href="core_demangle.html" title="D symbol mangling">core.demangle</a></li>
	<li><a href="core_exception.html" title="Root of exception hierarchy">core.exception</a></li>
	<li><a href="core_memory.html" title="Interface to memory management">core.memory</a></li>
	<li><a href="core_runtime.html" title="Interface to D runtime library internals">core.runtime</a></li>
	<li><a href="core_simd.html" title="Builtin SIMD intrinsics">core.simd</a></li>
	<li><a href="core_thread.html" title="Thread management">core.thread</a></li>
	<li><a href="core_time.html" title="Core time functionality">core.time</a></li>
	<li><a href="core_vararg.html" title="Variable function arguments">core.vararg</a></li>
	<li><a href="core_sync_barrier.html" title="Synchronizing progress of a group of threads">core.sync.barrier</a></li>
	<li><a href="core_sync_condition.html" title="Synchronized condition checking">core.sync.condition</a></li>
	<li><a href="core_sync_config.html" title="Stuff for core.sync">core.sync.config</a></li>
	<li><a href="core_sync_exception.html" title="SyncException">core.sync.exception</a></li>
	<li><a href="core_sync_mutex.html" title="Mutexes">core.sync.mutex</a></li>
	<li><a href="core_sync_rwmutex.html" title="R/W mutually exclusive access">core.sync.rwmutex</a></li>
	<li><a href="core_sync_semaphore.html" title="Semaphores">core.sync.semaphore</a></li>
    </ul>
</div>

</div><!--/navigation-->
<div id="content">
    
<div id="tools">
	<!--span id="lastupdate">Last update </span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/phobos/edit/master/std\utf.d" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/Phobos/StdUtf" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>

    <h1>std.utf</h1>
    <div id=quickindex class=quickindex></div>
    <!-- Generated by Ddoc from std\utf.d -->
Encode and decode UTF-8, UTF-16 and UTF-32 strings.
<p></p>
UTF character support is restricted to
    <span class="d_inlinecode">'\u0000' &lt;= character &lt;= '\U0010FFFF'</span>.

<p></p>
<b>See Also:</b><br><a href="http://en.wikipedia.org/wiki/Unicode">Wikipedia</a><br>
        <a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8">http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8</a><br>
        <a href="http://anubis.dkuug.dk/JTC1/SC2/WG2/docs/n1335">http://anubis.dkuug.dk/JTC1/SC2/WG2/docs/n1335</a>
<p></p>
<b>License:</b><br><a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<p></p>
<b>Authors:</b><br><a href="http://digitalmars.com">Walter Bright</a> and Jonathan M Davis
<p></p>
<b>Source:</b><br>
<a href="https://github.com/D-Programming-Language/phobos/blob/master/std/utf.d">std/utf.d</a><p></p>

<dl><dt class="d_decl"><a name=".UTFException"></a>class <a name="UTFException"></a><span class="ddoc_psymbol">UTFException</span>: object.Exception;
</dt>
<dd>Exception thrown on errors in std.utf functions.<p></p>

</dd>
<dt class="d_decl"><a name=".isValidDchar"></a>pure nothrow @safe bool <a name="isValidDchar"></a><span class="ddoc_psymbol">isValidDchar</span>(dchar <i>c</i>);
</dt>
<dd>Returns whether <span class="d_inlinecode"><i>c</i></span> is a valid UTF-32 character.
<p></p>
<span class="d_inlinecode">'\uFFFE'</span> and <span class="d_inlinecode">'\uFFFF'</span> are considered valid by <span class="d_inlinecode"><a name="isValidDchar"></a><span class="ddoc_psymbol">isValidDchar</span></span>,
    as they are permitted for internal use by an application, but they are
    not allowed for interchange by the Unicode standard.<p></p>

</dd>
<dt class="d_decl"><a name=".stride"></a>uint <a name="stride"></a><span class="ddoc_psymbol">stride</span>(S)(auto ref S <i>str</i>, size_t <i>index</i>) if (is(S : const(char[])) || isRandomAccessRange!S &amp;&amp; is(Unqual!(ElementType!S) == char));
<br><a name=".stride"></a>uint <a name="stride"></a><span class="ddoc_psymbol">stride</span>(S)(auto ref S <i>str</i>) if (is(S : const(char[])) || isInputRange!S &amp;&amp; is(Unqual!(ElementType!S) == char));
</dt>
<dd><span class="d_inlinecode"><a name="stride"></a><span class="ddoc_psymbol">stride</span></span> returns the length of the UTF-8 sequence starting at <span class="d_inlinecode">index</span>
    in <span class="d_inlinecode">str</span>.
<p></p>
<span class="d_inlinecode"><a name="stride"></a><span class="ddoc_psymbol">stride</span></span> works with both UTF-8 strings and ranges of <span class="d_inlinecode">char</span>. If no
    index is passed, then an input range will work, but if an index is passed,
    then a random-access range is required.
<p></p>

    <span class="d_inlinecode">index</span> defaults to <span class="d_inlinecode">0</span> if none is passed.

<p></p>
<b>Returns:</b><br>The number of bytes in the UTF-8 sequence.

<p></p>
<b>Throws:</b><br>May throw a <span class="d_inlinecode">UTFException</span> if <span class="d_inlinecode">str[index]</span> is not the start of a
        valid UTF-8 sequence.

<p></p>
<b>Notes:</b><br>
<span class="d_inlinecode"><a name="stride"></a><span class="ddoc_psymbol">stride</span></span> will only analize the first <span class="d_inlinecode">str[index]</span> element. It
        will not fully verify the validity of UTF-8 sequence, nor even verify
        the presence of the sequence: it will not actually guarantee that
        <span class="d_inlinecode">index + <a name="stride"></a><span class="ddoc_psymbol">stride</span>(str, index) &lt;= str.length</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".strideBack"></a>uint <a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span>(S)(auto ref S <i>str</i>, size_t <i>index</i>) if (is(S : const(char[])) || isRandomAccessRange!S &amp;&amp; is(Unqual!(ElementType!S) == char));
<br><a name=".strideBack"></a>uint <a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span>(S)(auto ref S <i>str</i>) if (is(S : const(char[])) || isRandomAccessRange!S &amp;&amp; hasLength!S &amp;&amp; is(Unqual!(ElementType!S) == char));
</dt>
<dd><span class="d_inlinecode"><a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span></span> returns the length of the UTF-8 sequence ending one code
    unit before <span class="d_inlinecode">index</span> in <span class="d_inlinecode">str</span>.
<p></p>
<span class="d_inlinecode"><a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span></span> works with both UTF-8 strings and bidirectional ranges of
    <span class="d_inlinecode">char</span>. If no index is passed, then a bidirectional range will work, but
    if an index is passed, then a random-access range is required.
<p></p>

    <span class="d_inlinecode">index</span> defaults to <span class="d_inlinecode">str.length</span> if none is passed.

<p></p>
<b>Returns:</b><br>The number of bytes in the UTF-8 sequence.

<p></p>
<b>Throws:</b><br>May throw a <span class="d_inlinecode">UTFException</span> if <span class="d_inlinecode">str[index]</span> is not one past the
        end of a valid UTF-8 sequence.

<p></p>
<b>Notes:</b><br>
<span class="d_inlinecode"><a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span></span> will not fully verify the validity of the UTF-8
        sequence. It will, however, guarantee that
        <span class="d_inlinecode">index - stride(str, index)</span> is a valid index.<p></p>

</dd>
<dt class="d_decl"><a name=".stride"></a>uint <a name="stride"></a><span class="ddoc_psymbol">stride</span>(S)(auto ref S <i>str</i>, size_t <i>index</i>) if (is(S : const(wchar[])) || isRandomAccessRange!S &amp;&amp; is(Unqual!(ElementType!S) == wchar));
<br><a name=".stride"></a>pure @safe uint <a name="stride"></a><span class="ddoc_psymbol">stride</span>(S)(auto ref S <i>str</i>) if (is(S : const(wchar[])));
</dt>
<dd><span class="d_inlinecode"><a name="stride"></a><span class="ddoc_psymbol">stride</span></span> returns the length of the UTF-16 sequence starting at <span class="d_inlinecode">index</span>
    in <span class="d_inlinecode">str</span>.
<p></p>
<span class="d_inlinecode"><a name="stride"></a><span class="ddoc_psymbol">stride</span></span> works with both UTF-16 strings and ranges of <span class="d_inlinecode">wchar</span>. If no
    index is passed, then an input range will work, but if an index is passed,
    then a random-access range is required.
<p></p>

    <span class="d_inlinecode">index</span> defaults to <span class="d_inlinecode">0</span> if none is passed.

<p></p>
<b>Returns:</b><br>The number of bytes in the UTF-16 sequence.

<p></p>
<b>Throws:</b><br>May throw a <span class="d_inlinecode">UTFException</span> if <span class="d_inlinecode">str[index]</span> is not the start of a
        valid UTF-16 sequence.

<p></p>
<b>Notes:</b><br>
<span class="d_inlinecode"><a name="stride"></a><span class="ddoc_psymbol">stride</span></span> will only analize the first <span class="d_inlinecode">str[index]</span> element. It
        will not fully verify the validity of UTF-16 sequence, nor even verify
        the presence of the sequence: it will not actually guarantee that
        <span class="d_inlinecode">index + <a name="stride"></a><span class="ddoc_psymbol">stride</span>(str, index) &lt;= str.length</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".strideBack"></a>uint <a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span>(S)(auto ref S <i>str</i>, size_t <i>index</i>) if (is(S : const(wchar[])) || isRandomAccessRange!S &amp;&amp; is(Unqual!(ElementType!S) == wchar));
<br><a name=".strideBack"></a>uint <a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span>(S)(auto ref S <i>str</i>) if (is(S : const(wchar[])) || isBidirectionalRange!S &amp;&amp; is(Unqual!(ElementType!S) == wchar));
</dt>
<dd><span class="d_inlinecode"><a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span></span> returns the length of the UTF-16 sequence ending one code
    unit before <span class="d_inlinecode">index</span> in <span class="d_inlinecode">str</span>.
<p></p>
<span class="d_inlinecode"><a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span></span> works with both UTF-16 strings and ranges of <span class="d_inlinecode">wchar</span>. If
    no index is passed, then a bidirectional range will work, but if an index is
    passed, then a random-access range is required.
<p></p>

    <span class="d_inlinecode">index</span> defaults to <span class="d_inlinecode">str.length</span> if none is passed.

<p></p>
<b>Returns:</b><br>The number of bytes in the UTF-16 sequence.

<p></p>
<b>Throws:</b><br>May throw a <span class="d_inlinecode">UTFException</span> if <span class="d_inlinecode">str[index]</span> is not one past the
        end of a valid UTF-16 sequence.

<p></p>
<b>Notes:</b><br>
<span class="d_inlinecode">stride</span> will only analize the element at <span class="d_inlinecode">str[index - 1]</span>
        element. It will not fully verify the validity of UTF-16 sequence, nor
        even verify the presence of the sequence: it will not actually
        guarantee that <span class="d_inlinecode">stride(str, index) &lt;= index</span>.<p></p>

</dd>
<dt class="d_decl"><a name=".stride"></a>uint <a name="stride"></a><span class="ddoc_psymbol">stride</span>(S)(auto ref S <i>str</i>, size_t <i>index</i> = 0) if (is(S : const(dchar[])) || isInputRange!S &amp;&amp; is(Unqual!(ElementEncodingType!S) == dchar));
</dt>
<dd><span class="d_inlinecode"><a name="stride"></a><span class="ddoc_psymbol">stride</span></span> returns the length of the UTF-32 sequence starting at <span class="d_inlinecode">index</span>
    in <span class="d_inlinecode">str</span>.
<p></p>
<span class="d_inlinecode"><a name="stride"></a><span class="ddoc_psymbol">stride</span></span> works with both UTF-32 strings and ranges of <span class="d_inlinecode">dchar</span>.

<p></p>
<b>Returns:</b><br>The number of bytes in the UTF-32 sequence (always <span class="d_inlinecode">1</span>).

<p></p>
<b>Throws:</b><br>Never.<p></p>

</dd>
<dt class="d_decl"><a name=".strideBack"></a>uint <a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span>(S)(auto ref S <i>str</i>, size_t <i>index</i>) if (isRandomAccessRange!S &amp;&amp; is(Unqual!(ElementEncodingType!S) == dchar));
<br><a name=".strideBack"></a>uint <a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span>(S)(auto ref S <i>str</i>) if (isBidirectionalRange!S &amp;&amp; is(Unqual!(ElementEncodingType!S) == dchar));
</dt>
<dd><span class="d_inlinecode"><a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span></span> returns the length of the UTF-32 sequence ending one code
    unit before <span class="d_inlinecode">index</span> in <span class="d_inlinecode">str</span>.
<p></p>
<span class="d_inlinecode"><a name="strideBack"></a><span class="ddoc_psymbol">strideBack</span></span> works with both UTF-32 strings and ranges of <span class="d_inlinecode">dchar</span>. If
    no index is passed, then a bidirectional range will work, but if an index is
    passed, then a random-access range is required.
<p></p>

    <span class="d_inlinecode">index</span> defaults to <span class="d_inlinecode">str.length</span> if none is passed.

<p></p>
<b>Returns:</b><br>The number of bytes in the UTF-32 sequence (always <span class="d_inlinecode">1</span>).

<p></p>
<b>Throws:</b><br>Never.<p></p>

</dd>
<dt class="d_decl"><a name=".toUCSindex"></a>pure @safe size_t <a name="toUCSindex"></a><span class="ddoc_psymbol">toUCSindex</span>(C)(const(C)[] <i>str</i>, size_t <i>index</i>) if (isSomeChar!C);
</dt>
<dd>Given <span class="d_inlinecode">index</span> into <span class="d_inlinecode">str</span> and assuming that <span class="d_inlinecode">index</span> is at the start
    of a UTF sequence, <span class="d_inlinecode"><a name="toUCSindex"></a><span class="ddoc_psymbol">toUCSindex</span></span> determines the number of UCS characters
    up to <span class="d_inlinecode">index</span>. So, <span class="d_inlinecode">index</span> is the index of a code unit at the
    beginning of a code point, and the return value is how many code points into
    the string that that code point is.<p></p>
<b>Examples:</b><br><pre class="d_code">
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUCSindex</span>(<span class="d_string">`hello world`</span>, 7) == 7);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUCSindex</span>(<span class="d_string">`hello world`w</span>, 7) == 7);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUCSindex</span>(<span class="d_string">`hello world`d</span>, 7) == 7);

    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUCSindex</span>(<span class="d_string">`Ma Chérie`</span>, 7) == 6);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUCSindex</span>(<span class="d_string">`Ma Chérie`w</span>, 7) == 7);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUCSindex</span>(<span class="d_string">`Ma Chérie`d</span>, 7) == 7);

    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUCSindex</span>(<span class="d_string">`さいごの果実 / ミツバチと科学者`</span>, 9) == 3);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUCSindex</span>(<span class="d_string">`さいごの果実 / ミツバチと科学者`w</span>, 9) == 9);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUCSindex</span>(<span class="d_string">`さいごの果実 / ミツバチと科学者`d</span>, 9) == 9);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".toUTFindex"></a>pure @safe size_t <a name="toUTFindex"></a><span class="ddoc_psymbol">toUTFindex</span>(C)(const(C)[] <i>str</i>, size_t <i>n</i>) if (isSomeChar!C);
</dt>
<dd>Given a UCS index <span class="d_inlinecode">n</span> into <span class="d_inlinecode">str</span>, returns the UTF index.
    So, <span class="d_inlinecode">n</span> is how many code points into the string the code point is, and
    the array index of the code unit is returned.<p></p>
<b>Examples:</b><br><pre class="d_code">
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUTFindex</span>(<span class="d_string">`hello world`</span>, 7) == 7);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUTFindex</span>(<span class="d_string">`hello world`w</span>, 7) == 7);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUTFindex</span>(<span class="d_string">`hello world`d</span>, 7) == 7);

    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUTFindex</span>(<span class="d_string">`Ma Chérie`</span>, 6) == 7);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUTFindex</span>(<span class="d_string">`Ma Chérie`w</span>, 7) == 7);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUTFindex</span>(<span class="d_string">`Ma Chérie`d</span>, 7) == 7);

    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUTFindex</span>(<span class="d_string">`さいごの果実 / ミツバチと科学者`</span>, 3) == 9);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUTFindex</span>(<span class="d_string">`さいごの果実 / ミツバチと科学者`w</span>, 9) == 9);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">toUTFindex</span>(<span class="d_string">`さいごの果実 / ミツバチと科学者`d</span>, 9) == 9);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".decode"></a>dchar <a name="decode"></a><span class="ddoc_psymbol">decode</span>(S)(auto ref S <i>str</i>, ref size_t <i>index</i>) if (!isSomeString!S &amp;&amp; isRandomAccessRange!S &amp;&amp; hasSlicing!S &amp;&amp; hasLength!S &amp;&amp; isSomeChar!(ElementType!S));
</dt>
<dd>Decodes and returns the code point starting at <span class="d_inlinecode">str[index]</span>. <span class="d_inlinecode">index</span>
    is advanced to one past the decoded code point. If the code point is not
    well-formed, then a <span class="d_inlinecode">UTFException</span> is thrown and <span class="d_inlinecode">index</span> remains
    unchanged.
<p></p>
<a name="decode"></a><span class="ddoc_psymbol">decode</span> will only work with strings and random access ranges of code units
    with length and slicing, whereas <a href="#decodeFront"><span class="d_inlinecode">decodeFront</span></a> will work with any
    input range of code units.

<p></p>
<b>Throws:</b><br><a href="#UTFException"><span class="d_inlinecode">UTFException</span></a> if <span class="d_inlinecode">str[index]</span> is not the start of a valid UTF
        sequence.<p></p>

</dd>
<dt class="d_decl"><a name=".decodeFront"></a>dchar <a name="decodeFront"></a><span class="ddoc_psymbol">decodeFront</span>(S)(ref S <i>str</i>, out size_t <i>numCodeUnits</i>) if (!isSomeString!S &amp;&amp; isInputRange!S &amp;&amp; isSomeChar!(ElementType!S));
<br><a name=".decodeFront"></a>dchar <a name="decodeFront"></a><span class="ddoc_psymbol">decodeFront</span>(S)(ref S <i>str</i>) if (isInputRange!S &amp;&amp; isSomeChar!(ElementType!S));
</dt>
<dd><span class="d_inlinecode"><a name="decodeFront"></a><span class="ddoc_psymbol">decodeFront</span></span> is a variant of <a href="#decode"><span class="d_inlinecode">decode</span></a> which specifically decodes
    the first code point. Unlike <a href="#decode"><span class="d_inlinecode">decode</span></a>, <span class="d_inlinecode"><a name="decodeFront"></a><span class="ddoc_psymbol">decodeFront</span></span> accepts any
    input range of code units (rather than just a string or random access
    range). It also takes the range by <span class="d_inlinecode">ref</span> and pops off the elements as it
    decodes them. If <span class="d_inlinecode">numCodeUnits</span> is passed in, it gets set to the number
    of code units which were in the code point which was decoded.
<p></p>
<b>Throws:</b><br><a href="#UTFException"><span class="d_inlinecode">UTFException</span></a> if <span class="d_inlinecode">str.front</span> is not the start of a valid UTF
        sequence. If an exception is thrown, then there is no guarantee as to
        the number of code units which were popped off, as it depends on the
        type of range being used and how many code units had to be popped off
        before the code point was determined to be invalid.<p></p>

</dd>
<dt class="d_decl"><a name=".encode"></a>pure @safe size_t <a name="encode"></a><span class="ddoc_psymbol">encode</span>(ref char[4] <i>buf</i>, dchar <i>c</i>);
<br><a name=".encode"></a>pure @safe size_t <a name="encode"></a><span class="ddoc_psymbol">encode</span>(ref wchar[2] <i>buf</i>, dchar <i>c</i>);
</dt>
<dd>Encodes <span class="d_inlinecode"><i>c</i></span> into the static array, <span class="d_inlinecode"><i>buf</i></span>, and returns the actual
    length of the encoded character (a number between <span class="d_inlinecode">1</span> and <span class="d_inlinecode">4</span> for
    <span class="d_inlinecode">char[4]</span> buffers and a number between <span class="d_inlinecode">1</span> and <span class="d_inlinecode">2</span> for
    <span class="d_inlinecode">wchar[2]</span> buffers).
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">UTFException</span> if <span class="d_inlinecode"><i>c</i></span> is not a valid UTF code point.<p></p>

</dd>
<dt class="d_decl"><a name=".encode"></a>pure @safe void <a name="encode"></a><span class="ddoc_psymbol">encode</span>(ref char[] <i>str</i>, dchar <i>c</i>);
<br><a name=".encode"></a>pure @safe void <a name="encode"></a><span class="ddoc_psymbol">encode</span>(ref wchar[] <i>str</i>, dchar <i>c</i>);
<br><a name=".encode"></a>pure @safe void <a name="encode"></a><span class="ddoc_psymbol">encode</span>(ref dchar[] <i>str</i>, dchar <i>c</i>);
</dt>
<dd>Encodes <span class="d_inlinecode"><i>c</i></span> in <span class="d_inlinecode"><i>str</i></span>'s encoding and appends it to <span class="d_inlinecode"><i>str</i></span>.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">UTFException</span> if <span class="d_inlinecode"><i>c</i></span> is not a valid UTF code point.<p></p>

</dd>
<dt class="d_decl"><a name=".codeLength"></a>pure nothrow @safe ubyte <a name="codeLength"></a><span class="ddoc_psymbol">codeLength</span>(C)(dchar <i>c</i>) if (isSomeChar!C);
</dt>
<dd>Returns the number of code units that are required to encode the code point
    <span class="d_inlinecode">c</span> when <span class="d_inlinecode">C</span> is the character type used to encode it.<p></p>
<b>Examples:</b><br><pre class="d_code">
    <span class="d_keyword">assert</span>(<span class="d_psymbol">codeLength</span>!<span class="d_keyword">char</span>('a') == 1);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">codeLength</span>!<span class="d_keyword">wchar</span>('a') == 1);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">codeLength</span>!<span class="d_keyword">dchar</span>('a') == 1);

    <span class="d_keyword">assert</span>(<span class="d_psymbol">codeLength</span>!<span class="d_keyword">char</span>('\U0010FFFF') == 4);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">codeLength</span>!<span class="d_keyword">wchar</span>('\U0010FFFF') == 2);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">codeLength</span>!<span class="d_keyword">dchar</span>('\U0010FFFF') == 1);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".codeLength"></a>size_t <a name="codeLength"></a><span class="ddoc_psymbol">codeLength</span>(C, InputRange)(InputRange <i>input</i>) if (isInputRange!InputRange &amp;&amp; is(ElementType!InputRange : dchar));
</dt>
<dd>Returns the number of code units that are required to encode <span class="d_inlinecode">str</span>
    in a string whose character type is <span class="d_inlinecode">C</span>. This is particularly useful
    when slicing one string with the length of another and the two string
    types use different character types.<p></p>
<b>Examples:</b><br><pre class="d_code">
    <span class="d_keyword">assert</span>(<span class="d_psymbol">codeLength</span>!<span class="d_keyword">char</span>(<span class="d_string">"hello world"</span>) ==
           to!string(<span class="d_string">"hello world"</span>).length);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">codeLength</span>!<span class="d_keyword">wchar</span>(<span class="d_string">"hello world"</span>) ==
           to!wstring(<span class="d_string">"hello world"</span>).length);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">codeLength</span>!<span class="d_keyword">dchar</span>(<span class="d_string">"hello world"</span>) ==
           to!dstring(<span class="d_string">"hello world"</span>).length);

    <span class="d_keyword">assert</span>(<span class="d_psymbol">codeLength</span>!<span class="d_keyword">char</span>(<span class="d_string">`プログラミング`</span>) ==
           to!string(<span class="d_string">`プログラミング`</span>).length);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">codeLength</span>!<span class="d_keyword">wchar</span>(<span class="d_string">`プログラミング`</span>) ==
           to!wstring(<span class="d_string">`プログラミング`</span>).length);
    <span class="d_keyword">assert</span>(<span class="d_psymbol">codeLength</span>!<span class="d_keyword">dchar</span>(<span class="d_string">`プログラミング`</span>) ==
           to!dstring(<span class="d_string">`プログラミング`</span>).length);

    string haystack = <span class="d_string">`Être sans la verité, ça, ce ne serait pas bien.`</span>;
    wstring needle = <span class="d_string">`Être sans la verité`</span>;
    <span class="d_keyword">assert</span>(haystack[<span class="d_psymbol">codeLength</span>!<span class="d_keyword">char</span>(needle) .. $] ==
           <span class="d_string">`, ça, ce ne serait pas bien.`</span>);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".validate"></a>pure @safe void <a name="validate"></a><span class="ddoc_psymbol">validate</span>(S)(in S <i>str</i>) if (isSomeString!S);
</dt>
<dd>Checks to see if <span class="d_inlinecode">str</span> is well-formed unicode or not.
<p></p>
<b>Throws:</b><br><span class="d_inlinecode">UTFException</span> if <span class="d_inlinecode">str</span> is not well-formed.<p></p>

</dd>
<dt class="d_decl"><a name=".toUTF8"></a>pure @safe string <a name="toUTF8"></a><span class="ddoc_psymbol">toUTF8</span>(in char[] <i>s</i>);
<br><a name=".toUTF8"></a>pure @trusted string <a name="toUTF8"></a><span class="ddoc_psymbol">toUTF8</span>(in wchar[] <i>s</i>);
<br><a name=".toUTF8"></a>pure @trusted string <a name="toUTF8"></a><span class="ddoc_psymbol">toUTF8</span>(in dchar[] <i>s</i>);
</dt>
<dd>Encodes string <span class="d_param"><i>s</i></span> into UTF-8 and returns the encoded string.<p></p>

</dd>
<dt class="d_decl"><a name=".toUTF16"></a>pure @trusted wstring <a name="toUTF16"></a><span class="ddoc_psymbol">toUTF16</span>(in char[] <i>s</i>);
<br><a name=".toUTF16"></a>pure @safe wstring <a name="toUTF16"></a><span class="ddoc_psymbol">toUTF16</span>(in wchar[] <i>s</i>);
<br><a name=".toUTF16"></a>pure @trusted wstring <a name="toUTF16"></a><span class="ddoc_psymbol">toUTF16</span>(in dchar[] <i>s</i>);
</dt>
<dd>Encodes string <span class="d_inlinecode"><i>s</i></span> into UTF-16 and returns the encoded string.<p></p>

</dd>
<dt class="d_decl"><a name=".toUTF32"></a>pure @trusted dstring <a name="toUTF32"></a><span class="ddoc_psymbol">toUTF32</span>(in char[] <i>s</i>);
<br><a name=".toUTF32"></a>pure @trusted dstring <a name="toUTF32"></a><span class="ddoc_psymbol">toUTF32</span>(in wchar[] <i>s</i>);
<br><a name=".toUTF32"></a>pure @safe dstring <a name="toUTF32"></a><span class="ddoc_psymbol">toUTF32</span>(in dchar[] <i>s</i>);
</dt>
<dd>Encodes string <span class="d_param"><i>s</i></span> into UTF-32 and returns the encoded string.<p></p>

</dd>
<dt class="d_decl"><a name=".toUTFz"></a>template <a name="toUTFz"></a><span class="ddoc_psymbol">toUTFz</span>(P)</dt>
<dd>Returns a C-style zero-terminated string equivalent to <span class="d_inlinecode">str</span>. <span class="d_inlinecode">str</span>
    must not contain embedded <span class="d_inlinecode">'\0'</span>'s as any C function will treat the first
    <span class="d_inlinecode">'\0'</span> that it sees as the end of the string. If <span class="d_inlinecode">str.empty</span> is
    <span class="d_inlinecode"><b>true</b></span>, then a string containing only <span class="d_inlinecode">'\0'</span> is returned.
<p></p>
<span class="d_inlinecode"><a name="toUTFz"></a><span class="ddoc_psymbol">toUTFz</span></span> accepts any type of string and is templated on the type of
    character pointer that you wish to convert to. It will avoid allocating a
    new string if it can, but there's a decent chance that it will end up having
    to allocate a new string - particularly when dealing with character types
    other than <span class="d_inlinecode">char</span>.
<p></p>

    <span style="color:red">Warning 1:</span> If the result of <span class="d_inlinecode"><a name="toUTFz"></a><span class="ddoc_psymbol">toUTFz</span></span> equals <span class="d_inlinecode">str.ptr</span>, then if
    anything alters the character one past the end of <span class="d_inlinecode">str</span> (which is the
    <span class="d_inlinecode">'\0'</span> character terminating the string), then the string won't be
    zero-terminated anymore. The most likely scenarios for that are if you
    append to <span class="d_inlinecode">str</span> and no reallocation takes place or when <span class="d_inlinecode">str</span> is a
    slice of a larger array, and you alter the character in the larger array
    which is one character past the end of <span class="d_inlinecode">str</span>. Another case where it could
    occur would be if you had a mutable character array immediately after
    <span class="d_inlinecode">str</span> in memory (for example, if they're member variables in a
    user-defined type with one declared right after the other) and that
    character array happened to start with <span class="d_inlinecode">'\0'</span>. Such scenarios will never
    occur if you immediately use the zero-terminated string after calling
    <span class="d_inlinecode"><a name="toUTFz"></a><span class="ddoc_psymbol">toUTFz</span></span> and the C function using it doesn't keep a reference to it.
    Also, they are unlikely to occur even if you save the zero-terminated string
    (the cases above would be among the few examples of where it could happen).
    However, if you save the zero-terminate string and want to be absolutely
    certain that the string stays zero-terminated, then simply append a
    <span class="d_inlinecode">'\0'</span> to the string and use its <span class="d_inlinecode">ptr</span> property rather than calling
    <span class="d_inlinecode"><a name="toUTFz"></a><span class="ddoc_psymbol">toUTFz</span></span>.
<p></p>

    <span style="color:red">Warning 2:</span> When passing a character pointer to a C function, and the
    C function keeps it around for any reason, make sure that you keep a
    reference to it in your D code. Otherwise, it may go away during a garbage
    collection cycle and cause a nasty bug when the C code tries to use it.<p></p>
<b>Examples:</b><br><pre class="d_code">
    <span class="d_keyword">auto</span> p1 = <span class="d_psymbol">toUTFz</span>!(<span class="d_keyword">char</span>*)(<span class="d_string">"hello world"</span>);
    <span class="d_keyword">auto</span> p2 = <span class="d_psymbol">toUTFz</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">char</span>)*)(<span class="d_string">"hello world"</span>);
    <span class="d_keyword">auto</span> p3 = <span class="d_psymbol">toUTFz</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">char</span>)*)(<span class="d_string">"hello world"</span>);
    <span class="d_keyword">auto</span> p4 = <span class="d_psymbol">toUTFz</span>!(<span class="d_keyword">char</span>*)(<span class="d_string">"hello world"d</span>);
    <span class="d_keyword">auto</span> p5 = <span class="d_psymbol">toUTFz</span>!(<span class="d_keyword">const</span>(<span class="d_keyword">wchar</span>)*)(<span class="d_string">"hello world"</span>);
    <span class="d_keyword">auto</span> p6 = <span class="d_psymbol">toUTFz</span>!(<span class="d_keyword">immutable</span>(<span class="d_keyword">dchar</span>)*)(<span class="d_string">"hello world"w</span>);
</pre>
<p></p>
</dd>
<dt class="d_decl"><a name=".toUTF16z"></a>const(wchar)* <a name="toUTF16z"></a><span class="ddoc_psymbol">toUTF16z</span>(C)(const(C)[] <i>str</i>) if (isSomeChar!C);
</dt>
<dd><span class="d_inlinecode"><a name="toUTF16z"></a><span class="ddoc_psymbol">toUTF16z</span></span> is a convenience function for <span class="d_inlinecode">toUTFz!(const(wchar)*)</span>.
<p></p>
Encodes string <span class="d_inlinecode">s</span> into UTF-16 and returns the encoded string.
    <span class="d_inlinecode"><a name="toUTF16z"></a><span class="ddoc_psymbol">toUTF16z</span></span> is suitable for calling the 'W' functions in the Win32 API
    that take an <span class="d_inlinecode">LPWSTR</span> or <span class="d_inlinecode">LPCWSTR</span> argument.<p></p>

</dd>
<dt class="d_decl"><a name=".count"></a>pure @trusted size_t <a name="count"></a><span class="ddoc_psymbol">count</span>(C)(const(C)[] <i>str</i>) if (isSomeChar!C);
</dt>
<dd>Returns the total number of code points encoded in <span class="d_inlinecode">str</span>.
<p></p>
<b>Supercedes:</b><br>
This function supercedes <a href="#toUCSindex"><span class="d_inlinecode">toUCSindex</span></a>.

<p></p>
<b>Standards:</b><br>Unicode 5.0, ASCII, ISO-8859-1, WINDOWS-1252

<p></p>
<b>Throws:</b><br><span class="d_inlinecode">UTFException</span> if <span class="d_inlinecode">str</span> is not well-formed.<p></p>

</dd>
</dl>

    
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="6203743411";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div><!--/content-->


<div id="copyright">
Copyright Digital Mars 2000 - 2012.
 |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>

