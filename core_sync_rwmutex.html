<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>core.sync.rwmutex</title>
        </head><body>
        <h1>core.sync.rwmutex</h1>
        <!-- Generated by Ddoc from src\core\sync\rwmutex.d -->
The read/write mutex module provides a primitive for maintaining shared read
 access and mutually exclusive write access.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>
<br><br>
<b>Authors:</b><br>
Sean Kelly
<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big><a name="ReadWriteMutex"></a>class <u>ReadWriteMutex</u>;
</big></dt>
<dd>This class represents a mutex that allows any number of readers to enter,
 but when a writer enters, all other readers and writers are blocked.
<br><br>
Please note that this mutex is not recursive and is intended to guard access
 to data only.  Also, no deadlock checking is in place because doing so would
 require dynamic memory allocation, which would reduce performance by an
 unacceptable amount.  As a result, any attempt to recursively acquire this
 mutex may well deadlock the caller, particularly if a write lock is acquired
 while holding a read lock, or vice-versa.  In practice, this should not be
 an issue however, because it is uncommon to call deeply into unknown code
 while holding a lock that simply protects data.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
    <font color=blue>import</font> core.atomic, core.thread, core.sync.semaphore;

    <font color=blue>static</font> <font color=blue>void</font> runTest(<u>ReadWriteMutex</u>.Policy policy)
    {
        <font color=blue>scope</font> mutex = <font color=blue>new</font> <u>ReadWriteMutex</u>(policy);
        <font color=blue>scope</font> rdSemA = <font color=blue>new</font> Semaphore, rdSemB = <font color=blue>new</font> Semaphore,
              wrSemA = <font color=blue>new</font> Semaphore, wrSemB = <font color=blue>new</font> Semaphore;
        <font color=blue>shared</font> size_t numReaders, numWriters;

        <font color=blue>void</font> readerFn()
        {
            <font color=blue>synchronized</font> (mutex.reader)
            {
                atomicOp!<font color=red>"+="</font>(numReaders, 1);
                rdSemA.notify();
                rdSemB.wait();
                atomicOp!<font color=red>"-="</font>(numReaders, 1);
            }
        }

        <font color=blue>void</font> writerFn()
        {
            <font color=blue>synchronized</font> (mutex.writer)
            {
                atomicOp!<font color=red>"+="</font>(numWriters, 1);
                wrSemA.notify();
                wrSemB.wait();
                atomicOp!<font color=red>"-="</font>(numWriters, 1);
            }
        }

        <font color=blue>void</font> waitQueued(size_t queuedReaders, size_t queuedWriters)
        {
            <font color=blue>for</font> (;;)
            {
                <font color=blue>synchronized</font> (mutex.m_commonMutex)
                {
                    <font color=blue>if</font> (mutex.m_numQueuedReaders == queuedReaders &amp;&amp;
                        mutex.m_numQueuedWriters == queuedWriters)
                        <font color=blue>break</font>;
                }
                Thread.yield();
            }
        }

        <font color=blue>scope</font> group = <font color=blue>new</font> ThreadGroup;

        <font color=green>// 2 simultaneous readers
</font>        group.create(&amp;readerFn); group.create(&amp;readerFn);
        rdSemA.wait(); rdSemA.wait();
        <font color=blue>assert</font>(numReaders == 2);
        rdSemB.notify(); rdSemB.notify();
        group.joinAll();
        <font color=blue>assert</font>(numReaders == 0);
        <font color=blue>foreach</font> (t; group) group.remove(t);

        <font color=green>// 1 writer at a time
</font>        group.create(&amp;writerFn); group.create(&amp;writerFn);
        wrSemA.wait();
        <font color=blue>assert</font>(!wrSemA.tryWait());
        <font color=blue>assert</font>(numWriters == 1);
        wrSemB.notify();
        wrSemA.wait();
        <font color=blue>assert</font>(numWriters == 1);
        wrSemB.notify();
        group.joinAll();
        <font color=blue>assert</font>(numWriters == 0);
        <font color=blue>foreach</font> (t; group) group.remove(t);

        <font color=green>// reader and writer are mutually exclusive
</font>        group.create(&amp;readerFn);
        rdSemA.wait();
        group.create(&amp;writerFn);
        waitQueued(0, 1);
        <font color=blue>assert</font>(!wrSemA.tryWait());
        <font color=blue>assert</font>(numReaders == 1 &amp;&amp; numWriters == 0);
        rdSemB.notify();
        wrSemA.wait();
        <font color=blue>assert</font>(numReaders == 0 &amp;&amp; numWriters == 1);
        wrSemB.notify();
        group.joinAll();
        <font color=blue>assert</font>(numReaders == 0 &amp;&amp; numWriters == 0);
        <font color=blue>foreach</font> (t; group) group.remove(t);

        <font color=green>// writer and reader are mutually exclusive
</font>        group.create(&amp;writerFn);
        wrSemA.wait();
        group.create(&amp;readerFn);
        waitQueued(1, 0);
        <font color=blue>assert</font>(!rdSemA.tryWait());
        <font color=blue>assert</font>(numReaders == 0 &amp;&amp; numWriters == 1);
        wrSemB.notify();
        rdSemA.wait();
        <font color=blue>assert</font>(numReaders == 1 &amp;&amp; numWriters == 0);
        rdSemB.notify();
        group.joinAll();
        <font color=blue>assert</font>(numReaders == 0 &amp;&amp; numWriters == 0);
        <font color=blue>foreach</font> (t; group) group.remove(t);

        <font color=green>// policy determines whether queued reader or writers progress first
</font>        group.create(&amp;writerFn);
        wrSemA.wait();
        group.create(&amp;readerFn);
        group.create(&amp;writerFn);
        waitQueued(1, 1);
        <font color=blue>assert</font>(numReaders == 0 &amp;&amp; numWriters == 1);
        wrSemB.notify();

        <font color=blue>if</font> (policy == <u>ReadWriteMutex</u>.Policy.PREFER_READERS)
        {
            rdSemA.wait();
            <font color=blue>assert</font>(numReaders == 1 &amp;&amp; numWriters == 0);
            rdSemB.notify();
            wrSemA.wait();
            <font color=blue>assert</font>(numReaders == 0 &amp;&amp; numWriters == 1);
            wrSemB.notify();
        }
        <font color=blue>else</font> <font color=blue>if</font> (policy == <u>ReadWriteMutex</u>.Policy.PREFER_WRITERS)
        {
            wrSemA.wait();
            <font color=blue>assert</font>(numReaders == 0 &amp;&amp; numWriters == 1);
            wrSemB.notify();
            rdSemA.wait();
            <font color=blue>assert</font>(numReaders == 1 &amp;&amp; numWriters == 0);
            rdSemB.notify();
        }
        group.joinAll();
        <font color=blue>assert</font>(numReaders == 0 &amp;&amp; numWriters == 0);
        <font color=blue>foreach</font> (t; group) group.remove(t);
    }
    runTest(<u>ReadWriteMutex</u>.Policy.PREFER_READERS);
    runTest(<u>ReadWriteMutex</u>.Policy.PREFER_WRITERS);
</pre>
<br><br>
<dl><dt><big><a name="ReadWriteMutex.Policy"></a>enum <u>Policy</u>: int;
</big></dt>
<dd>Defines the policy used by this mutex.  Currently, two policies are
 defined.
<br><br>
The first will queue writers until no readers hold the mutex, then
 pass the writers through one at a time.  If a reader acquires the mutex
 while there are still writers queued, the reader will take precedence.
<br><br>

 The second will queue readers if there are any writers queued.  Writers
 are passed through one at a time, and once there are no writers present,
 all queued readers will be alerted.
<br><br>

 Future policies may offer a more even balance between reader and writer
 precedence.<br><br>

<dl><dt><big><a name="ReadWriteMutex.Policy.PREFER_READERS"></a><u>PREFER_READERS</u></big></dt>
<dd>Readers get preference.  This may starve writers.<br><br>

</dd>
<dt><big><a name="ReadWriteMutex.Policy.PREFER_WRITERS"></a><u>PREFER_WRITERS</u></big></dt>
<dd>Writers get preference.  This may starve readers.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ReadWriteMutex.this"></a> this(Policy <i>policy</i> = Policy.PREFER_WRITERS);
</big></dt>
<dd>Initializes a read/write mutex object with the supplied <i>policy</i>.
<br><br>
<b>Params:</b><br>
<table><tr><td>Policy <i>policy</i></td>
<td>The <i>policy</i> to use.</td></tr>
</table><br>
<b>Throws:</b><br>
SyncException on error.<br><br>

</dd>
<dt><big><a name="ReadWriteMutex.policy"></a>@property Policy <u>policy</u>();
</big></dt>
<dd>Gets the <u>policy</u> used by this mutex.
<br><br>
<b>Returns:</b><br>
The <u>policy</u> used by this mutex.<br><br>

</dd>
<dt><big><a name="ReadWriteMutex.reader"></a>@property Reader <u>reader</u>();
</big></dt>
<dd>Gets an object representing the <u>reader</u> lock for the associated mutex.
<br><br>
<b>Returns:</b><br>
A <u>reader</u> sub-mutex.<br><br>

</dd>
<dt><big><a name="ReadWriteMutex.writer"></a>@property Writer <u>writer</u>();
</big></dt>
<dd>Gets an object representing the <u>writer</u> lock for the associated mutex.
<br><br>
<b>Returns:</b><br>
A <u>writer</u> sub-mutex.<br><br>

</dd>
<dt><big><a name="ReadWriteMutex.Reader"></a>class <u>Reader</u>: object.Object.Monitor;
</big></dt>
<dd>This class can be considered a mutex in its own right, and is used to
 negotiate a read lock for the enclosing mutex.<br><br>

<dl><dt><big><a name="ReadWriteMutex.Reader.this"></a> this();
</big></dt>
<dd>Initializes a read/write mutex reader proxy object.<br><br>

</dd>
<dt><big><a name="ReadWriteMutex.Reader.lock"></a>@trusted void <u>lock</u>();
</big></dt>
<dd>Acquires a read <u>lock</u> on the enclosing mutex.<br><br>

</dd>
<dt><big><a name="ReadWriteMutex.Reader.unlock"></a>@trusted void <u>unlock</u>();
</big></dt>
<dd>Releases a read lock on the enclosing mutex.<br><br>

</dd>
<dt><big><a name="ReadWriteMutex.Reader.tryLock"></a>bool <u>tryLock</u>();
</big></dt>
<dd>Attempts to acquire a read lock on the enclosing mutex.  If one can
 be obtained without blocking, the lock is acquired and <b>true</b> is
 returned.  If not, the lock is not acquired and <b>false</b> is returned.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the lock was acquired and <b>false</b> if not.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="ReadWriteMutex.Writer"></a>class <u>Writer</u>: object.Object.Monitor;
</big></dt>
<dd>This class can be considered a mutex in its own right, and is used to
 negotiate a write lock for the enclosing mutex.<br><br>

<dl><dt><big><a name="ReadWriteMutex.Writer.this"></a> this();
</big></dt>
<dd>Initializes a read/write mutex writer proxy object.<br><br>

</dd>
<dt><big><a name="ReadWriteMutex.Writer.lock"></a>@trusted void <u>lock</u>();
</big></dt>
<dd>Acquires a write <u>lock</u> on the enclosing mutex.<br><br>

</dd>
<dt><big><a name="ReadWriteMutex.Writer.unlock"></a>@trusted void <u>unlock</u>();
</big></dt>
<dd>Releases a write lock on the enclosing mutex.<br><br>

</dd>
<dt><big><a name="ReadWriteMutex.Writer.tryLock"></a>bool <u>tryLock</u>();
</big></dt>
<dd>Attempts to acquire a write lock on the enclosing mutex.  If one can
 be obtained without blocking, the lock is acquired and <b>true</b> is
 returned.  If not, the lock is not acquired and <b>false</b> is returned.
<br><br>
<b>Returns:</b><br>
<b>true</b> if the lock was acquired and <b>false</b> if not.<br><br>

</dd>
</dl>
</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright Sean Kelly 2005 - 2009.
</small>
        </body></html>
