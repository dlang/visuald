<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>core.sync.mutex</title>
        </head><body>
        <h1>core.sync.mutex</h1>
        <!-- Generated by Ddoc from src\core\sync\mutex.d -->
The <u>mutex</u> module provides a primitive for maintaining mutually exclusive
 access.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>
<br><br>
<b>Authors:</b><br>
Sean Kelly
<br><br>
<b>Source:</b><br>
<br><br>

<dl><dt><big><a name="Mutex"></a>class <u>Mutex</u>: object.Object.Monitor;
</big></dt>
<dd>This class represents a general purpose, recursive mutex.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
<font color=blue>auto</font> mutex      = <font color=blue>new</font> <u>Mutex</u>;
<font color=blue>int</font>  numThreads = 10;
<font color=blue>int</font>  numTries   = 1000;
<font color=blue>int</font>  lockCount  = 0;

<font color=blue>void</font> testFn()
{
    <font color=blue>for</font>( <font color=blue>int</font> i = 0; i &lt; numTries; ++i )
    {
        <font color=blue>synchronized</font>( mutex )
        {
            ++lockCount;
        }
    }
}

<font color=blue>auto</font> group = <font color=blue>new</font> ThreadGroup;

<font color=blue>for</font>( <font color=blue>int</font> i = 0; i &lt; numThreads; ++i )
    group.create( &amp;testFn );

group.joinAll();
<font color=blue>assert</font>( lockCount == numThreads * numTries );
</pre>
<br><br>
<dl><dt><big><a name="Mutex.this"></a> this();
</big></dt>
<dd>Initializes a mutex object.
<br><br>
<b>Throws:</b><br>
SyncException on error.<br><br>

</dd>
<dt><big><a name="Mutex.this"></a> this(Object <i>o</i>);
</big></dt>
<dd>Initializes a mutex object and sets it as the monitor for <i>o</i>.
<br><br>
<b>In:</b><br>
<i>o</i> must not already have a monitor.<br><br>

</dd>
<dt><big><a name="Mutex.lock"></a>@trusted void <u>lock</u>();
</big></dt>
<dd>If this <u>lock</u> is not already held by the caller, the <u>lock</u> is acquired,
 then the internal counter is incremented by one.
<br><br>
<b>Throws:</b><br>
SyncException on error.<br><br>

</dd>
<dt><big><a name="Mutex.unlock"></a>@trusted void <u>unlock</u>();
</big></dt>
<dd>Decrements the internal lock count by one.  If this brings the count to
 zero, the lock is released.
<br><br>
<b>Throws:</b><br>
SyncException on error.<br><br>

</dd>
<dt><big><a name="Mutex.tryLock"></a>bool <u>tryLock</u>();
</big></dt>
<dd>If the lock is held by another caller, the method returns.  Otherwise,
 the lock is acquired if it is not already held, and then the internal
 counter is incremented by one.
<br><br>
<b>Throws:</b><br>
SyncException on error.

<br><br>
<b>Returns:</b><br>
<b>true</b> if the lock was acquired and <b>false</b> if not.<br><br>

</dd>
</dl>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright Sean Kelly 2005 - 2009.
</small>
        </body></html>
