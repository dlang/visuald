
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
	Copyright (c) 1999-2013 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Traits - D Programming Language</title>
<link rel="stylesheet" href="css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="css/style.css" />
<link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="/js/codemirror.js"></script>
<script src="/js/run-main-website.js" type="text/javascript"></script>
<script src="/js/d.js"></script>
<script src="/js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function bodyLoad()
{
	var links = document.getElementById("navigation").getElementsByTagName("a");
	for (var i = 0; i < links.length; i++)
	{
		var url = "/" + links[i].getAttribute("href");
		if (window.location.href.match(url + "\x24") == url)
		{
			var cls = links[i].getAttribute("class");
			links[i].setAttribute("class", cls ? cls + " active" : "active");
			break;
		}
	}
}
</script>
</head>

<body onLoad='bodyLoad()'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="/images/search-left.gif" width="11" height="22" /><input id="q" name="q" /><input type="image" id="search-submit" name="submit" src="/images/search-button.gif" />
			<input type="hidden" id="domains" name="domains" value="dlang.org" />
			<input type="hidden" id="sourceid" name="sourceid" value="google-search" />
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a id="d-language" href="/">
		<img id="logo" width="125" height="95" border="0" alt="D Logo" src="/images/dlogo.png">
		D Programming Language</a>
	</div>
</div>

<!--Generated by Ddoc from traits.dd-->



<div id="navigation">
  

<div class="navblock">
<h2><a href="index.html" title="D Programming Language">D </a></h2>
<ul>	<li><a href="overview.html" title="D language overview">Overview</a></li>

	<li><a href="comparison.html" title="D feature list">Features</a></li>

	<li><a href="download.html" title="Download a D compiler">Downloads &amp; Tools</a></li>

	<li><a href="changelog.html" title="History of changes to D">Change Log</a></li>
	<li><a href="bugstats.php" title="D issue and bug tracking system">Bug Tracker</a></li>
	<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>

	<li><a href="appendices.html">Appendices</a></li>
	<li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgments</a></li>
	<li><a href="sitemap.html" title="Documents on this site, indexed alphabetically">Sitemap</a></li>
	<li><a href="http://digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
</ul>
    </div>


<div class="navblock">
<h2>Documentation</h2>
<ul>    <li><a href="http://www.amazon.com/exec/obidos/ASIN/0321635361/classicempire">Book</a>
</li>
	<li><a href="http://www.informit.com/articles/article.aspx?p=1381876">&nbsp;<font size=-1><span style="visibility: hidden">3</span>1.&nbsp;Tutorial</font></a></li>
	<li><a href="http://www.informit.com/articles/article.aspx?p=1609144">&nbsp;<font size=-1>13.&nbsp;Concurrency</font></a></li>

	<li><a href="language-reference.html">Language Reference</a>

    <div class="navblock">
<ul>	<li><a href="lex.html">Lexical</a></li>
	<li><a href="module.html">Modules</a></li>
	<li><a href="declaration.html">Declarations</a></li>
	<li><a href="type.html">Types</a></li>
	<li><a href="property.html">Properties</a></li>
	<li><a href="attribute.html">Attributes</a></li>
	<li><a href="pragma.html">Pragmas</a></li>
	<li><a href="expression.html">Expressions</a></li>
	<li><a href="statement.html">Statements</a></li>
	<li><a href="arrays.html">Arrays</a></li>
	<li><a href="hash-map.html">Associative Arrays</a></li>
	<li><a href="struct.html">Structs &amp; Unions</a></li>
	<li><a href="class.html">Classes</a></li>
	<li><a href="interface.html">Interfaces</a></li>
	<li><a href="enum.html">Enums</a></li>
	<li><a href="const3.html">Const and Immutable</a></li>
	<li><a href="function.html">Functions</a></li>
	<li><a href="operatoroverloading.html">Operator Overloading</a></li>
	<li><a href="template.html">Templates</a></li>
	<li><a href="template-mixin.html">Template Mixins</a></li>
	<li><a href="dbc.html">Contracts</a></li>
	<li><a href="version.html">Conditional Compilation</a></li>
	<li><a href="simd.html">Vector Extensions</a></li>
	<li><a href="traits.html">Traits</a></li>
	<li><a href="errors.html">Handling errors</a></li>
	<li><a href="unittest.html">Unit Tests</a></li>
	<li><a href="garbage.html">Garbage Collection</a></li>
	<li><a href="float.html">Floating Point</a></li>
	<li><a href="iasm.html">Inline Assembler</a></li>
	<li><a href="ddoc.html">Documentation Comments</a></li>
	<li><a href="interfaceToC.html">Interfacing To C</a></li>
	<li><a href="cpp_interface.html">Interfacing To C++</a></li>
	<li><a href="portability.html">Portability Guide</a></li>
	<li><a href="entity.html">Named Character Entities</a></li>
	<li><a href="memory-safe-d.html">Memory Safe D Spec</a></li>
	<li><a href="abi.html">Application Binary Interface</a></li>
    </ul>
</div>
</li>
	<li><a href="phobos/index.html">Library Reference</a></li>
	<li><a href="howtos.html" title="Helps for using D">How-tos</a></li>

	<li><a href="articles.html">Articles</a></li>
</ul>
    </div>


<div class="navblock">
<h2><a href="http://rainers.github.io/visuald/visuald/StartPage.html
">Visual D</a></h2>
<ul></ul>
    </div>


<div class="navblock">
<h2>Community</h2>
<ul>	<li><a href="http://forum.dlang.org/" title="User forums">Forums</a></li>
	<li><a href="http://github.com/D-Programming-Language" title="D on github">GitHub</a></li>
	<li><a href="http://wiki.dlang.org" title="Wiki for the D Programming Language">Wiki</a></li>
	<li><a href="http://wiki.dlang.org/Review_Queue" title="Queue of current and upcoming standard library additions">Review Queue</a></li>
	<li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
	<li><a href="http://digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
	
</ul>
    </div>


  
<div id="translate" class="tool">Translate this page:
	<div id="google_translate_element"></div><script type="text/javascript">
	function googleTranslateElementInit() {
	  new google.translate.TranslateElement({
	    pageLanguage: 'en',
	    autoDisplay: false,
	    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
	  }, 'google_translate_element');
	}
	</script>
<script type="text/javascript" src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</div>

</div><!--/navigation-->
<div id="content" class='hyphenate'>
  
<div id="tools">
	<!--span id="lastupdate">Last update Sun Sep 22 15:36:54 2013

</span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/dlang.org/edit/master/traits.dd" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/Traits" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>

  <h1>Traits</h1>
  
	<p>Traits are extensions to the language to enable
	programs, at compile time, to get at information
	internal to the compiler. This is also known as
	compile time reflection.
	It is done as a special, easily extended syntax (similar
	to Pragmas) so that new capabilities can be added
	as required.
	</p>

<pre class="bnf"><span class="notranslate"><a name="TraitsExpression"><i>TraitsExpression</i></a>:
    <b>__traits</b> <b>(</b> <a href="#TraitsKeyword"><i>TraitsKeyword</i></a> <b>,</b> <a href="#TraitsArguments"><i>TraitsArguments</i></a> <b>)</b>

<a name="TraitsKeyword"><i>TraitsKeyword</i></a>:
    <a href="#isAbstractClass"><b>isAbstractClass</b></a>
    <a href="#isArithmetic"><b>isArithmetic</b></a>
    <a href="#isAssociativeArray"><b>isAssociativeArray</b></a>
    <a href="#isFinalClass"><b>isFinalClass</b></a>
    <a href="#isPOD"><b>isPOD</b></a>
    <a href="#isNested"><b>isNested</b></a>
    <a href="#isFloating"><b>isFloating</b></a>
    <a href="#isIntegral"><b>isIntegral</b></a>
    <a href="#isScalar"><b>isScalar</b></a>
    <a href="#isStaticArray"><b>isStaticArray</b></a>
    <a href="#isUnsigned"><b>isUnsigned</b></a>
    <a href="#isVirtualFunction"><b>isVirtualFunction</b></a>
    <a href="#isVirtualMethod"><b>isVirtualMethod</b></a>
    <a href="#isAbstractFunction"><b>isAbstractFunction</b></a>
    <a href="#isFinalFunction"><b>isFinalFunction</b></a>
    <a href="#isStaticFunction"><b>isStaticFunction</b></a>
    <a href="#isRef"><b>isRef</b></a>
    <a href="#isOut"><b>isOut</b></a>
    <a href="#isLazy"><b>isLazy</b></a>
    <a href="#hasMember"><b>hasMember</b></a>
    <a href="#identifier"><b>identifier</b></a>
    <a href="#getAttributes"><b>getAttributes</b></a>
    <a href="#getMember"><b>getMember</b></a>
    <a href="#getOverloads"><b>getOverloads</b></a>
    <a href="#getProtection"><b>getProtection</b></a>
    <a href="#getVirtualFunctions"><b>getVirtualFunctions</b></a>
    <a href="#getVirtualMethods"><b>getVirtualMethods</b></a>
    <a href="#parent"><b>parent</b></a>
    <a href="#classInstanceSize"><b>classInstanceSize</b></a>
    <a href="#getVirtualIndex"><b>getVirtualIndex</b></a>
    <a href="#allMembers"><b>allMembers</b></a>
    <a href="#derivedMembers"><b>derivedMembers</b></a>
    <a href="#isSame"><b>isSame</b></a>
    <a href="#compiles"><b>compiles</b></a>

<a name="TraitsArguments"><i>TraitsArguments</i></a>:
    <a href="#TraitsArgument"><i>TraitsArgument</i></a>
    <a href="#TraitsArgument"><i>TraitsArgument</i></a> <b>,</b> <i>TraitsArguments</i>

<a name="TraitsArgument"><i>TraitsArgument</i></a>:
    <a href="expression.html#AssignExpression"><i>AssignExpression</i></a>
    <a href="declaration.html#Type"><i>Type</i></a>
</span></pre>

<p>Additionally special keywords are provided for debugging purposes:</p>

<pre class="bnf"><span class="notranslate"><a name="Special Keywords"><i>Special Keywords</i></a>:
    <span class="notranslate"><span class="d_inlinecode donthyphenate"><a href="#specialkeywords">__FILE__</a></span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate"><a href="#specialkeywords">__MODULE__</a></span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate"><a href="#specialkeywords">__LINE__</a></span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate"><a href="#specialkeywords">__FUNCTION__</a></span></span>
    <span class="notranslate"><span class="d_inlinecode donthyphenate"><a href="#specialkeywords">__PRETTY_FUNCTION__</a></span></span>
</span></pre>

<h2><a name="isArithmetic"><i>isArithmetic</i></a></h2>

	<p>If the arguments are all either types that are arithmetic types,
	or expressions that are typed as arithmetic types, then <b>true</b>
	is returned.
	Otherwise, <b>false</b> is returned.
	If there are no arguments, <b>false</b> is returned.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> main() {
  <span class="d_keyword">int</span> i;
  writeln(<span class="d_keyword">__traits</span>(isArithmetic, <span class="d_keyword">int</span>));
  writeln(<span class="d_keyword">__traits</span>(isArithmetic, i, i+1, <span class="d_keyword">int</span>));
  writeln(<span class="d_keyword">__traits</span>(isArithmetic));
  writeln(<span class="d_keyword">__traits</span>(isArithmetic, <span class="d_keyword">int</span>*));
}
</span></pre>

	<p>Prints:</p>

<pre class="console"><span class="notranslate">true
true
false
false
</span></pre>

<h2><a name="isFloating"><i>isFloating</i></a></h2>

	<p>Works like <b>isArithmetic</b>, except it's for floating
	point types (including imaginary and complex types).</p>

<h2><a name="isIntegral"><i>isIntegral</i></a></h2>

	<p>Works like <b>isArithmetic</b>, except it's for integral
	types (including character types).</p>

<h2><a name="isScalar"><i>isScalar</i></a></h2>

	<p>Works like <b>isArithmetic</b>, except it's for scalar
	types.</p>

<h2><a name="isUnsigned"><i>isUnsigned</i></a></h2>

	<p>Works like <b>isArithmetic</b>, except it's for unsigned
	types.</p>

<h2><a name="isStaticArray"><i>isStaticArray</i></a></h2>

	<p>Works like <b>isArithmetic</b>, except it's for static array
	types.</p>

<h2><a name="isAssociativeArray"><i>isAssociativeArray</i></a></h2>

	<p>Works like <b>isArithmetic</b>, except it's for associative array
	types.</p>

<h2><a name="isAbstractClass"><i>isAbstractClass</i></a></h2>

	<p>If the arguments are all either types that are abstract classes,
	or expressions that are typed as abstract classes, then <b>true</b>
	is returned.
	Otherwise, <b>false</b> is returned.
	If there are no arguments, <b>false</b> is returned.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">abstract</span> <span class="d_keyword">class</span> C { <span class="d_keyword">int</span> foo(); }

<span class="d_keyword">void</span> main() {
  C c;
  writeln(<span class="d_keyword">__traits</span>(isAbstractClass, C));
  writeln(<span class="d_keyword">__traits</span>(isAbstractClass, c, C));
  writeln(<span class="d_keyword">__traits</span>(isAbstractClass));
  writeln(<span class="d_keyword">__traits</span>(isAbstractClass, <span class="d_keyword">int</span>*));
}
</span></pre>

	<p>Prints:</p>

<pre class="console"><span class="notranslate">true
true
false
false
</span></pre>

<h2><a name="isFinalClass"><i>isFinalClass</i></a></h2>

	<p>Works like <b>isAbstractClass</b>, except it's for final
	classes.</p>

<h2><a name="isPOD"><i>isPOD</i></a></h2>

	<p>Takes one argument, which must be a type. It returns
	<b>true</b> if the type is a <a href="glossary.html#pod">POD</a> type, otherwise <b>false</b>.</p>

<h2><a name="isNested"><i>isNested</i></a></h2>

    <p>Takes one argument.
    It returns <b>true</b> if the argument is a nested type which internally
    stores a context pointer, otherwise it returns <b>false</b>.
    Nested types can be  <a href="class.html#nested">classes</a>,
    <a href="struct.html#nested">structs</a>, and
    <a href="function.html#variadicnested">functions</a>.</p>

<h2><a name="isVirtualFunction"><i>isVirtualFunction</i></a></h2>

	<p>The same as <a href="#isVirtualMethod"><i>isVirtualMethod</i></a>, except
	that final functions that don't override anything return true.
	</p>

<h2><a name="isVirtualMethod"><i>isVirtualMethod</i></a></h2>

	<p>Takes one argument. If that argument is a virtual function,
	<b>true</b> is returned, otherwise <b>false</b>.
	Final functions that don't override anything return false.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S {
  <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">class</span> C {
  <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">void</span> main() {
  writeln(<span class="d_keyword">__traits</span>(isVirtualMethod, C.bar));  <span class="d_comment">// true
</span>  writeln(<span class="d_keyword">__traits</span>(isVirtualMethod, S.bar));  <span class="d_comment">// false
</span>}
</span></pre>

<h2><a name="isAbstractFunction"><i>isAbstractFunction</i></a></h2>

	<p>Takes one argument. If that argument is an abstract function,
	<b>true</b> is returned, otherwise <b>false</b>.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S {
  <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">class</span> C {
  <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">class</span> AC {
  <span class="d_keyword">abstract</span> <span class="d_keyword">void</span> foo();
}

<span class="d_keyword">void</span> main() {
  writeln(<span class="d_keyword">__traits</span>(isAbstractFunction, C.bar));   <span class="d_comment">// false
</span>  writeln(<span class="d_keyword">__traits</span>(isAbstractFunction, S.bar));   <span class="d_comment">// false
</span>  writeln(<span class="d_keyword">__traits</span>(isAbstractFunction, AC.foo));  <span class="d_comment">// true
</span>}
</span></pre>

<h2><a name="isFinalFunction"><i>isFinalFunction</i></a></h2>

	<p>Takes one argument. If that argument is a final function,
	<b>true</b> is returned, otherwise <b>false</b>.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S {
  <span class="d_keyword">void</span> bar() { }
}

<span class="d_keyword">class</span> C {
  <span class="d_keyword">void</span> bar() { }
  <span class="d_keyword">final</span> <span class="d_keyword">void</span> foo();
}

<span class="d_keyword">final</span> <span class="d_keyword">class</span> FC {
  <span class="d_keyword">void</span> foo();
}

<span class="d_keyword">void</span> main() {
  writeln(<span class="d_keyword">__traits</span>(isFinalFunction, C.bar));	  <span class="d_comment">// false
</span>  writeln(<span class="d_keyword">__traits</span>(isFinalFunction, S.bar));	  <span class="d_comment">// false
</span>  writeln(<span class="d_keyword">__traits</span>(isFinalFunction, C.foo));	  <span class="d_comment">// true
</span>  writeln(<span class="d_keyword">__traits</span>(isFinalFunction, FC.foo));  <span class="d_comment">// true
</span>}
</span></pre>

<h2><a name="isStaticFunction"><i>isStaticFunction</i></a></h2>

	<p>Takes one argument. If that argument is a static function,
	meaning it has no context pointer,
	<b>true</b> is returned, otherwise <b>false</b>.
	</p>


<h2><a name="isRef"><i>isRef</i></a>, <a name="isOut"><i>isOut</i></a>, <a name="isLazy"><i>isLazy</i></a></h2>

	<p>Takes one argument. If that argument is a declaration,
	<b>true</b> is returned if it is <span class="d_keyword">ref</span>, <span class="d_keyword">out</span>,
	or <span class="d_keyword">lazy</span>, otherwise <b>false</b>.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">void</span> fooref(<span class="d_keyword">ref</span> <span class="d_keyword">int</span> x) {
  <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isRef, x));
  <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isOut, x));
  <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isLazy, x));
}

<span class="d_keyword">void</span> fooout(<span class="d_keyword">out</span> <span class="d_keyword">int</span> x) {
  <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isRef, x));
  <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isOut, x));
  <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isLazy, x));
}

<span class="d_keyword">void</span> foolazy(<span class="d_keyword">lazy</span> <span class="d_keyword">int</span> x) {
  <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isRef, x));
  <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(!<span class="d_keyword">__traits</span>(isOut, x));
  <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(<span class="d_keyword">__traits</span>(isLazy, x));
}
</span></pre>

<h2><a name="hasMember"><i>hasMember</i></a></h2>

	<p>The first argument is a type that has members, or
	is an expression of a type that has members.
	The second argument is a string.
	If the string is a valid property of the type,
	<b>true</b> is returned, otherwise <b>false</b>.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S {
  <span class="d_keyword">int</span> m;
}

<span class="d_keyword">void</span> main() {
  S s;

  writeln(<span class="d_keyword">__traits</span>(hasMember, S, <span class="d_string">"m"</span>)); <span class="d_comment">// true
</span>  writeln(<span class="d_keyword">__traits</span>(hasMember, s, <span class="d_string">"m"</span>)); <span class="d_comment">// true
</span>  writeln(<span class="d_keyword">__traits</span>(hasMember, S, <span class="d_string">"y"</span>)); <span class="d_comment">// false
</span>  writeln(<span class="d_keyword">__traits</span>(hasMember, <span class="d_keyword">int</span>, <span class="d_string">"sizeof"</span>)); <span class="d_comment">// true
</span>}
</span></pre>

<h2><a name="identifier"><i>identifier</i></a></h2>

	<p>Takes one argument, a symbol. Returns the identifier
	for that symbol as a string literal.
	</p>

<h2><a name="getAttributes"><i>getAttributes</i></a></h2>
    <p>        Takes one argument, a symbol. Returns a tuple of all attached user defined attributes.
        If no UDA's exist it will return an empty tuple.
    </p>

    <p>        For more information, see: <a href="attribute.html#uda">User Defined Attributes</a>
    </p>

<pre class="d_code"><span class="notranslate">@(3) <span class="d_keyword">int</span> a;
@(<span class="d_string">"string"</span>, 7) <span class="d_keyword">int</span> b;

<span class="d_keyword">enum</span> Foo;
@Foo <span class="d_keyword">int</span> c;

<span class="d_keyword">pragma</span>(msg, <span class="d_keyword">__traits</span>(getAttributes, a));
<span class="d_keyword">pragma</span>(msg, <span class="d_keyword">__traits</span>(getAttributes, b));
<span class="d_keyword">pragma</span>(msg, <span class="d_keyword">__traits</span>(getAttributes, c));
</span></pre>

    <p>        Prints:
    </p>

<pre class="console"><span class="notranslate">tuple(3)
tuple("string", 7)
tuple((Foo))
</span></pre>


<h2><a name="getMember"><i>getMember</i></a></h2>

	<p>Takes two arguments, the second must be a string.
	The result is an expression formed from the first
	argument, followed by a &lsquo;.&rsquo;, followed by the second
	argument as an identifier.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S {
  <span class="d_keyword">int</span> mx;
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> my;
}

<span class="d_keyword">void</span> main() {
  S s;

  <span class="d_keyword">__traits</span>(getMember, s, <span class="d_string">"mx"</span>) = 1;  <span class="d_comment">// same as s.mx=1;
</span>  writeln(<span class="d_keyword">__traits</span>(getMember, s, <span class="d_string">"m"</span> ~ <span class="d_string">"x"</span>)); <span class="d_comment">// 1
</span>
  <span class="d_keyword">__traits</span>(getMember, S, <span class="d_string">"mx"</span>) = 1;  <span class="d_comment">// error, no this for S.mx
</span>  <span class="d_keyword">__traits</span>(getMember, S, <span class="d_string">"my"</span>) = 2;  <span class="d_comment">// ok
</span>}
</span></pre>

<h2><a name="getOverloads"><i>getOverloads</i></a></h2>

	<p>The first argument is an aggregate (e.g. struct/class/module).
	The second argument is a string that matches the name of
	one of the functions in that aggregate.
	The result is a tuple of all the overloads of that function.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D {
  <span class="d_keyword">this</span>() { }
  ~<span class="d_keyword">this</span>() { }
  <span class="d_keyword">void</span> foo() { }
  <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 2; }
}

<span class="d_keyword">void</span> main() {
  D d = <span class="d_keyword">new</span> D();

  <span class="d_keyword">foreach</span> (t; <span class="d_keyword">__traits</span>(getOverloads, D, <span class="d_string">"foo"</span>))
    writeln(<span class="d_keyword">typeid</span>(<span class="d_keyword">typeof</span>(t)));

  <span class="d_keyword">alias</span> <span class="d_keyword">typeof</span>(<span class="d_keyword">__traits</span>(getOverloads, D, <span class="d_string">"foo"</span>)) b;
  <span class="d_keyword">foreach</span> (t; b)
    writeln(<span class="d_keyword">typeid</span>(t));

  <span class="d_keyword">auto</span> i = <span class="d_keyword">__traits</span>(getOverloads, d, <span class="d_string">"foo"</span>)[1](1);
  writeln(i);
}
</span></pre>

	<p>Prints:</p>

<pre class="console"><span class="notranslate">void()
int()
void()
int()
2
</span></pre>

<h2><a name="getProtection"><i>getProtection</i></a></h2>

	<p>The argument is a symbol.
	The result is a string giving its protection level: "public", "private", "protected", "export", or "package".
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D {
  <span class="d_keyword">export</span> <span class="d_keyword">void</span> foo() { }
  <span class="d_keyword">public</span> <span class="d_keyword">int</span> bar;
}

<span class="d_keyword">void</span> main() {
  D d = <span class="d_keyword">new</span> D();

  <span class="d_keyword">auto</span> i = <span class="d_keyword">__traits</span>(getProtection, d.foo);
  writeln(i);

  <span class="d_keyword">auto</span> j = <span class="d_keyword">__traits</span>(getProtection, d.bar);
  writeln(j);
}
</span></pre>

	<p>Prints:</p>

<pre class="console"><span class="notranslate">export
public
</span></pre>


<h2><a name="getVirtualFunctions"><i>getVirtualFunctions</i></a></h2>

	<p>The same as <a href="#getVirtualMethods"><i>getVirtualMethods</i></a>, except that
	final functions that do not override anything are included.
	</p>

<h2><a name="getVirtualMethods"><i>getVirtualMethods</i></a></h2>

	<p>The first argument is a class type or an expression of
	class type.
	The second argument is a string that matches the name of
	one of the functions of that class.
	The result is a tuple of the virtual overloads of that function.
	It does not include final functions that do not override anything.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D {
  <span class="d_keyword">this</span>() { }
  ~<span class="d_keyword">this</span>() { }
  <span class="d_keyword">void</span> foo() { }
  <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 2; }
}

<span class="d_keyword">void</span> main() {
  D d = <span class="d_keyword">new</span> D();

  <span class="d_keyword">foreach</span> (t; <span class="d_keyword">__traits</span>(getVirtualMethods, D, <span class="d_string">"foo"</span>))
    writeln(<span class="d_keyword">typeid</span>(<span class="d_keyword">typeof</span>(t)));

  <span class="d_keyword">alias</span> <span class="d_keyword">typeof</span>(<span class="d_keyword">__traits</span>(getVirtualMethods, D, <span class="d_string">"foo"</span>)) b;
  <span class="d_keyword">foreach</span> (t; b)
    writeln(<span class="d_keyword">typeid</span>(t));

  <span class="d_keyword">auto</span> i = <span class="d_keyword">__traits</span>(getVirtualMethods, d, <span class="d_string">"foo"</span>)[1](1);
  writeln(i);
}
</span></pre>

	<p>Prints:</p>

<pre class="console"><span class="notranslate">void()
int()
void()
int()
2
</span></pre>

<h2><a name="parent"><i>parent</i></a></h2>

	<p>Takes a single argument which must evaluate to a symbol.
	The result is the symbol that is the parent of it.
	</p>

<h2><a name="classInstanceSize"><i>classInstanceSize</i></a></h2>

	<p>Takes a single argument, which must evaluate to either
	a class type or an expression of class type.
	The result
	is of type <span class="notranslate"><span class="d_inlinecode donthyphenate">size_t</span></span>, and the value is the number of
	bytes in the runtime instance of the class type.
	It is based on the static type of a class, not the
	polymorphic type.
	</p>

<h2><a name="getVirtualIndex"><i>getVirtualIndex</i></a></h2>

  <p>Takes a single argument which must evaluate to a function.
  The result is a <span class="notranslate"><span class="d_inlinecode donthyphenate">ptrdiff_t</span></span> containing the index
  of that function within the vtable of the parent type. 
  If the function passed in is final and does not override
  a virtual function, <b>-1</b> is returned instead.
  </p>

<h2><a name="allMembers"><i>allMembers</i></a></h2>

	<p>Takes a single argument, which must evaluate to either
	a type or an expression of type.
	A tuple of string literals is returned, each of which
	is the name of a member of that type combined with all
	of the members of the base classes (if the type is a class).
	No name is repeated.
	Builtin properties are not included.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D {
  <span class="d_keyword">this</span>() { }
  ~<span class="d_keyword">this</span>() { }
  <span class="d_keyword">void</span> foo() { }
  <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 0; }
}

<span class="d_keyword">void</span> main() {
  <span class="d_keyword">auto</span> b = [ <span class="d_keyword">__traits</span>(allMembers, D) ];
  writeln(b);
  <span class="d_comment">// ["__ctor", "__dtor", "foo", "toString", "toHash", "opCmp", "opEquals", "Monitor", "factory"]
</span>}
</span></pre>

	<p>The order in which the strings appear in the result
	is not defined.</p>

<h2><a name="derivedMembers"><i>derivedMembers</i></a></h2>

	<p>Takes a single argument, which must evaluate to either
	a type or an expression of type.
	A tuple of string literals is returned, each of which
	is the name of a member of that type.
	No name is repeated.
	Base class member names are not included.
	Builtin properties are not included.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">class</span> D {
  <span class="d_keyword">this</span>() { }
  ~<span class="d_keyword">this</span>() { }
  <span class="d_keyword">void</span> foo() { }
  <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span>) { <span class="d_keyword">return</span> 0; }
}

<span class="d_keyword">void</span> main() {
  <span class="d_keyword">auto</span> a = [<span class="d_keyword">__traits</span>(derivedMembers, D)];
  writeln(a);    <span class="d_comment">// ["__ctor", "__dtor", "foo"]
</span>}
</span></pre>

	<p>The order in which the strings appear in the result
	is not defined.</p>

<h2><a name="isSame"><i>isSame</i></a></h2>

	<p>Takes two arguments and returns bool <b>true</b> if they
	are the same symbol, <b>false</b> if not.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S { }

<span class="d_keyword">int</span> foo();
<span class="d_keyword">int</span> bar();

<span class="d_keyword">void</span> main() {
  writeln(<span class="d_keyword">__traits</span>(isSame, foo, foo)); <span class="d_comment">// true
</span>  writeln(<span class="d_keyword">__traits</span>(isSame, foo, bar)); <span class="d_comment">// false
</span>  writeln(<span class="d_keyword">__traits</span>(isSame, foo, S));   <span class="d_comment">// false
</span>  writeln(<span class="d_keyword">__traits</span>(isSame, S, S));     <span class="d_comment">// true
</span>  writeln(<span class="d_keyword">__traits</span>(isSame, std, S));   <span class="d_comment">// false
</span>  writeln(<span class="d_keyword">__traits</span>(isSame, std, std)); <span class="d_comment">// true
</span>}
</span></pre>

	<p>If the two arguments are expressions made up of literals
	or enums that evaluate to the same value, true is returned.</p>

<h2><a name="compiles"><i>compiles</i></a></h2>

	<p>Returns a bool <b>true</b> if all of the arguments
	compile (are semantically correct).
	The arguments can be symbols, types, or expressions that
	are syntactically correct.
	The arguments cannot be statements or declarations.
	</p>

	<p>If there are no arguments, the result is <b>false</b>.</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S {
  <span class="d_keyword">static</span> <span class="d_keyword">int</span> s1;
  <span class="d_keyword">int</span> s2;
}

<span class="d_keyword">int</span> foo();
<span class="d_keyword">int</span> bar();

<span class="d_keyword">void</span> main() {
  writeln(<span class="d_keyword">__traits</span>(compiles));                      <span class="d_comment">// false
</span>  writeln(<span class="d_keyword">__traits</span>(compiles, foo));                 <span class="d_comment">// true
</span>  writeln(<span class="d_keyword">__traits</span>(compiles, foo + 1));             <span class="d_comment">// true
</span>  writeln(<span class="d_keyword">__traits</span>(compiles, &amp;foo + 1));            <span class="d_comment">// false
</span>  writeln(<span class="d_keyword">__traits</span>(compiles, <span class="d_keyword">typeof</span>(1)));           <span class="d_comment">// true
</span>  writeln(<span class="d_keyword">__traits</span>(compiles, S.s1));                <span class="d_comment">// true
</span>  writeln(<span class="d_keyword">__traits</span>(compiles, S.s3));                <span class="d_comment">// false
</span>  writeln(<span class="d_keyword">__traits</span>(compiles, 1,2,3,<span class="d_keyword">int</span>,<span class="d_keyword">long</span>,std));  <span class="d_comment">// true
</span>  writeln(<span class="d_keyword">__traits</span>(compiles, 3[1]));                <span class="d_comment">// false
</span>  writeln(<span class="d_keyword">__traits</span>(compiles, 1,2,3,<span class="d_keyword">int</span>,<span class="d_keyword">long</span>,3[1])); <span class="d_comment">// false
</span>}
</span></pre>

	<p>This is useful for:</p>

	<ul>	<li>Giving better error messages inside generic code than
	the sometimes hard to follow compiler ones.</li>
	<li>Doing a finer grained specialization than template
	partial specialization allows for.</li>
	</ul>


<h2><a name="specialkeywords">Special Keywords</a></h2>

    <p><span class="notranslate"><span class="d_inlinecode donthyphenate">__FILE__</span></span> and <span class="notranslate"><span class="d_inlinecode donthyphenate">__LINE__</span></span> expand to the source
    file name and line number at the point of instantiation.</p>

    <p><span class="notranslate"><span class="d_inlinecode donthyphenate">__MODULE__</span></span> expands to the module name at the point of
    instantiation.</p>

    <p><span class="notranslate"><span class="d_inlinecode donthyphenate">__FUNCTION__</span></span> expands to the fully qualified name of the
    function at the point of instantiation.</p>

    <p><span class="notranslate"><span class="d_inlinecode donthyphenate">__PRETTY_FUNCTION__</span></span> is similar to <span class="notranslate"><span class="d_inlinecode donthyphenate">__FUNCTION__</span></span>,
    but also expands the function return type, its parameter types,
    and its attributes.</p>

    <p>Example usage:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">module</span> test;
<span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">void</span> test(string file = <span class="d_keyword">__FILE__</span>, size_t line = <span class="d_keyword">__LINE__</span>, string mod = <span class="d_keyword">__MODULE__</span>,
          string func = <span class="d_keyword">__FUNCTION__</span>, string pretty = <span class="d_keyword">__PRETTY_FUNCTION__</span>)
{
    writefln(<span class="d_string">"file: '%s', line: '%s', module: '%s',\nfunction: '%s', pretty function: '%s'"</span>,
             file, line, mod, func, pretty);
}

<span class="d_keyword">int</span> main(string[] args)
{
    test();
    <span class="d_keyword">return</span> 0;
}
</span></pre>

	<p>This will output:</p>

<pre class="console"><span class="notranslate">file: 'test.d', line: '13', module: 'test',
function: 'test.main', pretty function: 'int test.main(string[] args)'
</span></pre>


  
<div id="google_ad">
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>

</div><!--/content-->





<div id="footernav">
<a href="http://forum.dlang.org/" title="User Forums">Forums</a> |
<a href="http://wiki.dlang.org/DocComments/Traits" title="Read/write comments and feedback">Comments</a> |
<a href="http://digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="download.html" title="Download D">Downloads</a> |
<a href="/">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2013 by Digital Mars &reg;, All Rights Reserved
 |
Page generated by <a href="ddoc.html">Ddoc</a> on Sun Sep 22 15:36:54 2013


</div>

</body>
</html>

