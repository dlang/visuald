
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
	Copyright (c) 1999-2013 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Writing Win32 DLLs - D Programming Language</title>
<link rel="stylesheet" href="css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="css/style.css" />
<link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="/js/codemirror.js"></script>
<script src="/js/run-main-website.js" type="text/javascript"></script>
<script src="/js/d.js"></script>
<script src="/js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function bodyLoad()
{
	var links = document.getElementById("navigation").getElementsByTagName("a");
	for (var i = 0; i < links.length; i++)
	{
		var url = "/" + links[i].getAttribute("href");
		if (window.location.href.match(url + "\x24") == url)
		{
			var cls = links[i].getAttribute("class");
			links[i].setAttribute("class", cls ? cls + " active" : "active");
			break;
		}
	}
}
</script>
</head>

<body onLoad='bodyLoad()'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="/images/search-left.gif" width="11" height="22" /><input id="q" name="q" /><input type="image" id="search-submit" name="submit" src="/images/search-button.gif" />
			<input type="hidden" id="domains" name="domains" value="dlang.org" />
			<input type="hidden" id="sourceid" name="sourceid" value="google-search" />
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a id="d-language" href="/">
		<img id="logo" width="125" height="95" border="0" alt="D Logo" src="/images/dlogo.png">
		D Programming Language</a>
	</div>
</div>

<!--Generated by Ddoc from dll.dd-->



<div id="navigation">
  

<div class="navblock">
<h2><a href="index.html" title="D Programming Language">D </a></h2>
<ul>	<li><a href="overview.html" title="D language overview">Overview</a></li>

	<li><a href="comparison.html" title="D feature list">Features</a></li>

	<li><a href="download.html" title="Download a D compiler">Downloads &amp; Tools</a></li>

	<li><a href="changelog.html" title="History of changes to D">Change Log</a></li>
	<li><a href="bugstats.php" title="D issue and bug tracking system">Bug Tracker</a></li>
	<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>

	<li><a href="appendices.html">Appendices</a></li>
	<li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgments</a></li>
	<li><a href="sitemap.html" title="Documents on this site, indexed alphabetically">Sitemap</a></li>
	<li><a href="http://digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
</ul>
    </div>


<div class="navblock">
<h2>Documentation</h2>
<ul>    <li><a href="http://www.amazon.com/exec/obidos/ASIN/0321635361/classicempire">Book</a>
</li>
	<li><a href="http://www.informit.com/articles/article.aspx?p=1381876">&nbsp;<font size=-1><span style="visibility: hidden">3</span>1.&nbsp;Tutorial</font></a></li>
	<li><a href="http://www.informit.com/articles/article.aspx?p=1609144">&nbsp;<font size=-1>13.&nbsp;Concurrency</font></a></li>

	<li><a href="language-reference.html">Language Reference</a></li>
	<li><a href="phobos/index.html">Library Reference</a></li>
	<li><a href="visuald/StartPage.html">Visual D</a></li>
	<li><a href="howtos.html" title="Helps for using D">How-tos</a>

    <div class="navblock">
<ul>		<li><a href="windows.html" title="D implementation for 32 bit Windows systems">D for Win32</a></li>
		<li><a href="dll.html" title="Writing 32 bit Windows DLLs in D">Win32 DLLs in D</a></li>
		<li><a href="COM.html" title="Windows COM Programming">COM Programming</a></li>
		<li><a href="32-64-portability.html" title="Porting 32 Bit Code to 64 Bits">Porting to 64 Bits</a></li>
		<li><a href="htomodule.html" title="converting C .h header files to D modules">C .h to D Modules</a></li>
		<li><a href="http://digitalmars.com/techtips/index.html" title="Programming tips">Tech Tips</a></li>
</ul>
</div>
</li>

	<li><a href="articles.html">Articles</a></li>
</ul>
    </div>


<div class="navblock">
<h2>Community</h2>
<ul>	<li><a href="http://forum.dlang.org/" title="User forums">Forums</a></li>
	<li><a href="http://github.com/D-Programming-Language" title="D on github">GitHub</a></li>
	<li><a href="http://wiki.dlang.org" title="Wiki for the D Programming Language">Wiki</a></li>
	<li><a href="http://wiki.dlang.org/Review_Queue" title="Queue of current and upcoming standard library additions">Review Queue</a></li>
	<li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
	<li><a href="http://digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
	
</ul>
    </div>


  
<div id="translate" class="tool">Translate this page:
	<div id="google_translate_element"></div><script type="text/javascript">
	function googleTranslateElementInit() {
	  new google.translate.TranslateElement({
	    pageLanguage: 'en',
	    autoDisplay: false,
	    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
	  }, 'google_translate_element');
	}
	</script>
<script type="text/javascript" src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</div>

</div><!--/navigation-->
<div id="content" class='hyphenate'>
  
<div id="tools">
	<!--span id="lastupdate">Last update Wed Oct 02 13:49:25 2013

</span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/dlang.org/edit/master/dll.dd" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/DLLs" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>

  <h1>Writing Win32 DLLs</h1>
  
	<p>DLLs (Dynamic Link Libraries) are one of the foundations
	of system programming for Windows. The D programming
	language enables the creation of several different types of
	DLLs.
	</p>

	<p>For background information on what DLLs are and how they work
	Chapter 11 of Jeffrey Richter's book
	<a href="http://www.amazon.com/exec/obidos/ASIN/1572315482/classicempire">
	Advanced Windows</a> is indispensible.
	</p>

	<p>This guide will show how to create DLLs of various types with D.</p>

	<ul>        <li><a href="#compiling">Compiling a DLL</a></li>
	<li><a href="#Cinterface">DLLs with a C interface</a></li>
	<li><a href="#com">DLLs that are COM servers</a></li>
	<li><a href="#Dcode">D code calling D code in DLLs</a></li>
	</ul>

<h2><a name="compiling">Compiling a DLL</a></h2>

        <p>Use the <a href="dmd-windows.html#switch-shared"><b>-shared</b></a> switch to tell the compiler
        that the generated code is to be
        put into a DLL. Code compiled for an EXE file will use the optimization assumption
        that <span class="notranslate"><span class="d_inlinecode donthyphenate">_tls_index==0</span></span>. Such code in a DLL will crash.
        </p>


<h2><a name="Cinterface">DLLs with a C Interface</a></h2>

	<p>A DLL presenting a C interface can connect to any other code
	in a language that supports calling C functions in a DLL.
	</p>

	<p>DLLs can be created in D in roughly the same way as in C.
	A <span class="notranslate"><span class="d_inlinecode donthyphenate">DllMain()</span></span>
	is required, looking like:
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.c.windows.windows;
<span class="d_keyword">import</span> core.sys.windows.dll;

<span class="d_keyword">__gshared</span> HINSTANCE g_hInst;

<span class="d_keyword">extern</span> (Windows)
BOOL DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    <span class="d_keyword">switch</span> (ulReason)
    {
	<span class="d_keyword">case</span> DLL_PROCESS_ATTACH:
	    g_hInst = hInstance;
	    dll_process_attach( hInstance, <span class="d_keyword">true</span> );
	    <span class="d_keyword">break</span>;

	<span class="d_keyword">case</span> DLL_PROCESS_DETACH:
	    dll_process_detach( hInstance, <span class="d_keyword">true</span> );
	    <span class="d_keyword">break</span>;

	<span class="d_keyword">case</span> DLL_THREAD_ATTACH:
	    dll_thread_attach( <span class="d_keyword">true</span>, <span class="d_keyword">true</span> );
	    <span class="d_keyword">break</span>;

	<span class="d_keyword">case</span> DLL_THREAD_DETACH:
	    dll_thread_detach( <span class="d_keyword">true</span>, <span class="d_keyword">true</span> );
	    <span class="d_keyword">break</span>;
    }
    <span class="d_keyword">return</span> <span class="d_keyword">true</span>;
}

</span></pre>

	<p>Notes:</p>
	<ul>	<li>DllMain simply forwards to the appropriate helper functions. These setup
	     the runtime, create thread objects for interaction with the garbage collector
	     and initialize thread local storage data.</li>
	<li>The DLL does not share its runtime or memory with other DLLs.</li>
	<li>The first boolean argument to the dll-helper functions specify whether all threads
	     should be controlled by the garbage collector. You might need more control over
	     this behaviour if there are threads in the process that must not be suspended.
	     In this case pass false to disable the automatic handling of all threads.</li>
	<li>The presence of <span class="notranslate"><span class="d_inlinecode donthyphenate">DllMain()</span></span> is recognized by the compiler
		causing it to emit a reference to
		<a href="http://www.digitalmars.com/ctg/acrtused.html">__acrtused_dll</a>
		and the <tt>phobos.lib</tt> runtime library.</li>
	</ul>

	Link with a .def
	(<a href="http://www.digitalmars.com/ctg/ctgDefFiles.html">Module Definition File</a>)
	along the lines of:

<pre class="moddeffile"><span class="notranslate">LIBRARY         MYDLL
DESCRIPTION     'My DLL written in D'

EXETYPE		NT
CODE            PRELOAD DISCARDABLE
DATA            WRITE

EXPORTS
		DllGetClassObject       @2
		DllCanUnloadNow         @3
		DllRegisterServer       @4
		DllUnregisterServer     @5
</span></pre>

	<p>The functions in the EXPORTS list are for illustration.
	Replace them with the actual exported functions from MYDLL.
	Alternatively, use
	<a href="http://www.digitalmars.com/ctg/implib.html">implib</a>.
	Here's an example of a simple DLL with a function print()
	which prints a string:
	</p>

	<h4>mydll.d:</h4>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">module</span> mydll;
<span class="d_keyword">import</span> std.c.stdio;
<span class="d_keyword">export</span> <span class="d_keyword">void</span> dllprint() { printf(<span class="d_string">"hello dll world\n"</span>); }
</span></pre>

	<p>Note: We use <span class="notranslate"><span class="d_inlinecode donthyphenate">printf</span></span>s in these examples
	instead of <span class="notranslate"><span class="d_inlinecode donthyphenate">writefln</span></span>
	to make the examples as
	simple as possible.</p>

	<h4>mydll.def:</h4>

<pre class="moddeffile"><span class="notranslate">LIBRARY "mydll.dll"
EXETYPE NT
SUBSYSTEM WINDOWS
CODE SHARED EXECUTE
DATA WRITE
</span></pre>

	<p>Put the code above that contains <span class="notranslate"><span class="d_inlinecode donthyphenate">DllMain()</span></span> into a file
	<tt>dll.d</tt>.
	Compile and link the dll with the following command:
	</p>

<pre class="console"><span class="notranslate">C:&gt;dmd -ofmydll.dll -L/IMPLIB mydll.d dll.d mydll.def
C:&gt;
</span></pre>

	<p>which will create mydll.dll and mydll.lib.
	Now for a program, test.d, which will use the dll:
	</p>

	<h4>test.d:</h4>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> mydll;

<span class="d_keyword">int</span> main()
{
   mydll.dllprint();
   <span class="d_keyword">return</span> 0;
}
</span></pre>

	<p>Create an interface file mydll.di that doesn't have the function bodies:</p>

	<h4>mydll.di:</h4>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">export</span> <span class="d_keyword">void</span> dllprint();
</span></pre>

	Compile and link with the command:

<pre class="console"><span class="notranslate">C:&gt;dmd test.d mydll.lib
C:&gt;
</span></pre>

	and run:
<pre class="console"><span class="notranslate">C:&gt;test
hello dll world
C:&gt;
</span></pre>



<h3>Memory Allocation</h3>

	<p>D DLLs use garbage collected memory management. The question is what
	happens when pointers to allocated data cross DLL boundaries?
	If the DLL presents a C interface, one would assume the reason
	for that is to connect with code written in other languages.
	Those other languages will not know anything about D's memory
	management. Thus, the C interface will have to shield the
	DLL's callers from needing to know anything about it.
	</p>

	<p>There are many approaches to solving this problem:</p>

	<ul>
	<li>Do not return pointers to D gc allocated memory to the caller of
	the DLL. Instead, have the caller allocate a buffer, and have the DLL
	fill in that buffer.</li>

	<li>Retain a pointer to the data within the D DLL so the GC will not free
	it. Establish a protocol where the caller informs the D DLL when it is
	safe to free the data.</li>

	<li>Notify the GC about external references to a memory block by
	calling GC.addRange.</li>

	<li>Use operating system primitives like VirtualAlloc() to allocate
	memory to be transferred between DLLs.</li>

	<li>Use std.c.stdlib.malloc() (or another non-gc allocator) when
	allocating data to be returned to the caller. Export a function
	that will be used by the caller to free the data.</li>

	</ul>

<h2><a name="com">COM Programming</a></h2>

	<p>Many Windows API interfaces are in terms of COM (Common Object Model)
	objects (also called OLE or ActiveX objects). A COM object is an object
	who's first field is a pointer to a vtbl[], and the first 3 entries
	in that vtbl[] are for QueryInterface(), AddRef(), and Release().</p>

	<p>For understanding COM, Kraig Brockshmidt's
	<a href="http://www.amazon.com/exec/obidos/ASIN/1556158432/classicempire">Inside OLE</a>
	is an indispensible resource.</p>

	<p>COM objects are analogous to D interfaces. Any COM object can be
	expressed as a D interface, and every D object with an interface X
	can be exposed as a COM object X.
	This means that D is compatible with COM objects implemented
	in other languages.</p>

	<p>While not strictly necessary, the Phobos library provides an Object
	useful as a super class for all D COM objects, called ComObject.
	ComObject provides a default implementation for
	QueryInterface(), AddRef(), and Release().</p>

	<p>Windows COM objects use the Windows calling convention, which is not
	the default for D, so COM functions need to have the attribute
	extern (Windows).</p>

	<p>So, to write a COM object:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.c.windows.com;

<span class="d_keyword">class</span> MyCOMobject : ComObject
{
    <span class="d_keyword">extern</span> (Windows):
	...
}
</span></pre>

	The sample code includes an example COM client program and server DLL.

<h2><a name="Dcode">D code calling D code in DLLs</a></h2>

	<p>Having DLLs in D be able to talk to each other as if they
	were statically linked together is, of course, very desirable
	as code between applications can be shared, and different
	DLLs can be independently developed.</p>

	<p>The underlying difficulty is what to do about garbage collection (gc).
	Each EXE and DLL will have their own gc instance. While
	these gc's can coexist without stepping on each other,
	it's redundant and inefficient to have multiple gc's running.
	The idea explored here is to pick one gc and have the DLLs
	redirect their gc's to use that one. The one gc used here will be
	the one in the EXE file, although it's also possible to make a
	separate DLL just for the gc.</p>

	<p>The example will show both how to statically load a DLL, and
	to dynamically load/unload it.</p>

	<p>Starting with the code for the DLL, mydll.d:</p>
<pre class="d_code"><span class="notranslate"><span class="d_comment">/*
 * MyDll demonstration of how to write D DLLs.
 */</span>

<span class="d_keyword">import</span> core.runtime;
<span class="d_keyword">import</span> std.c.stdio;
<span class="d_keyword">import</span> std.c.stdlib;
<span class="d_keyword">import</span> std.string;
<span class="d_keyword">import</span> std.c.windows.windows;

HINSTANCE   g_hInst;

<span class="d_keyword">extern</span> (C)
{
    <span class="d_keyword">void</span>  gc_setProxy(<span class="d_keyword">void</span>* p);
    <span class="d_keyword">void</span>  gc_clrProxy();
}

<span class="d_keyword">extern</span> (Windows)
    BOOL <b>DllMain</b>(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    <span class="d_keyword">switch</span> (ulReason)
    {
        <span class="d_keyword">case</span> DLL_PROCESS_ATTACH:
	    printf(<span class="d_string">"DLL_PROCESS_ATTACH\n"</span>);
	    Runtime.initialize();
	    <span class="d_keyword">break</span>;

        <span class="d_keyword">case</span> DLL_PROCESS_DETACH:
	    printf(<span class="d_string">"DLL_PROCESS_DETACH\n"</span>);
	    Runtime.terminate();
	    <span class="d_keyword">break</span>;

        <span class="d_keyword">case</span> DLL_THREAD_ATTACH:
	    printf(<span class="d_string">"DLL_THREAD_ATTACH\n"</span>);
	    <span class="d_keyword">return</span> <span class="d_keyword">false</span>;

        <span class="d_keyword">case</span> DLL_THREAD_DETACH:
	    printf(<span class="d_string">"DLL_THREAD_DETACH\n"</span>);
	    <span class="d_keyword">return</span> <span class="d_keyword">false</span>;
    }
    g_hInst = hInstance;
    <span class="d_keyword">return</span> <span class="d_keyword">true</span>;
}

<span class="d_keyword">export</span> <span class="d_keyword">void</span> <b>MyDLL_Initialize</b>(<span class="d_keyword">void</span>* gc)
{
    printf(<span class="d_string">"MyDLL_Initialize()\n"</span>);
    gc_setProxy(gc);
}

<span class="d_keyword">export</span> <span class="d_keyword">void</span> <b>MyDLL_Terminate</b>()
{
    printf(<span class="d_string">"MyDLL_Terminate()\n"</span>);
    gc_clrProxy();
}

<b><span class="d_keyword">static</span> <span class="d_keyword">this</span></b>()
{
    printf(<span class="d_string">"static this for mydll\n"</span>);
}

<b><span class="d_keyword">static</span> ~<span class="d_keyword">this</span></b>()
{
    printf(<span class="d_string">"static ~this for mydll\n"</span>);
}

<span class="d_comment">/* --------------------------------------------------------- */</span>

<span class="d_keyword">class</span> <b>MyClass</b>
{
    <span class="d_keyword">char</span>[] <b>concat</b>(<span class="d_keyword">char</span>[] a, <span class="d_keyword">char</span>[] b)
    {
	<span class="d_keyword">return</span> a ~ <span class="d_string">" "</span> ~ b;
    }

    <span class="d_keyword">void</span> <b>free</b>(<span class="d_keyword">char</span>[] s)
    {
	<span class="d_keyword">delete</span> s;
    }
}

<span class="d_keyword">export</span> MyClass <b>getMyClass</b>()
{
    <span class="d_keyword">return</span> <span class="d_keyword">new</span> MyClass();
}
</span></pre>

	<dl>
	<dt><b>DllMain</b></dt>
	<dd><p>This is the main entry point for any D DLL. It gets called
	by the C startup code
	(for DMC++, the source is <tt>\dm\src\win32\dllstart.c</tt>).
	The <b>printf</b>'s are placed there so one can trace how it gets
	called.
	Notice that the initialization and termination code seen in
	the earlier DllMain sample code is in this version as well.
	This is because the same DLL should be usable from both C and
	D programs, so the same initialization process should work
	for both.</p></dd>

	<dt><b>MyDLL_Initialize</b></dt>
	<dd>	<p>When the DLL is dynamically linked via <b>Runtime.loadLibrary</b>()
	the runtime makes sure that any initialization steps required
	by the D program are executed after the library is loaded.  If
	the library is statically linked, this routine is not called by
	the program, so to make sure the DLL is initialized properly we
	have to do some of the work ourselves.  And because the library
	is being statically linked, we need a function specific to this
	DLL to perform the initialization.
	This function takes one argument, a handle to the
	caller's gc. We'll see how that handle is obtained later.
	To pass this handle to the runtime and override the DLL's built-in
	gc we'll call <b>gc_setProxy</b>().
	The function is <b>export</b>ed as that is how a function is made
	visible outside of a DLL.</p></dd>

	<dt><b>MyDLL_Terminate</b></dt>
	<dd><p>Correspondingly, this function terminates the DLL, and is
	called prior to unloading it.
	It has only one job: informing the runtime that the DLL will
	no longer be using the caller's gc via <b>gc_clrProxy</b>().
	This is critical, as the DLL will be unmapped from memory,
	and if the gc continues to scan its data areas it will cause
	segment faults.</p></dd>

	<dt><b>static this, static ~this</b></dt>
	<dd><p>These are examples of the module's static constructor
	and destructor,
	here with a print in each to verify that they are running
	and when.</p></dd>

	<dt><b>MyClass</b></dt>
	<dd><p>This is an example of a class that can be exported from
	and used by the caller of a DLL. The <b>concat</b> member
	function allocates some gc memory, and <b>free</b> frees gc
	memory.</p></dd>

	<dt><b>getMyClass</b></dt>
	<dd><p>An exported factory that allocates an instance of <b>MyClass</b>
	and returns a reference to it.</p></dd>

	</dl>

	To build the <tt>mydll.dll</tt> DLL:

	<ol>	<li><b><tt>dmd -c mydll -g</tt></b>
	<br>Compiles <span class="notranslate"><span class="d_inlinecode donthyphenate">mydll.d</span></span> into <tt>mydll.obj</tt>.
	<b>-g</b> turns on debug info generation.
	</li>

	<li><b><tt>dmd mydll.obj mydll.def -g -L/map</tt></b>
	<br>Links <tt>mydll.obj</tt> into a DLL named <tt>mydll.dll</tt>.
	<tt>mydll.def</tt> is the
	<a href="http://www.digitalmars.com/ctg/ctgDefFiles.html">Module Definition File</a>,
	and has the contents:

<pre class="moddeffile"><span class="notranslate">LIBRARY         MYDLL
DESCRIPTION     'MyDll demonstration DLL'
EXETYPE		NT
CODE            PRELOAD DISCARDABLE
DATA            PRELOAD MULTIPLE
</span></pre>
	<b>-g</b> turns on debug info generation, and
	<b>-L/map</b> generates a map file <tt>mydll.map</tt>.
	</li>

	<li><b><tt>implib /noi /system mydll.lib mydll.dll</tt></b>
	<br>Creates an
	<a href="http://www.digitalmars.com/ctg/implib.html">import library</a>
	<tt>mydll.lib</tt> suitable
	for linking in with an application that will be statically
	loading <tt>mydll.dll</tt>.
	</li>

	</ol>

	<p>Here's <tt>test.d</tt>, a sample application that makes use of
	<tt>mydll.dll</tt>. There are two versions, one statically binds to
	the DLL, and the other dynamically loads it.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> core.runtime;
<span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.gc;

<span class="d_keyword">import</span> mydll;

<span class="d_comment">//version=DYNAMIC_LOAD;
</span>
<span class="d_keyword">version</span> (DYNAMIC_LOAD)
{
    <span class="d_keyword">import</span> std.c.windows.windows;

    <span class="d_keyword">alias</span> MyClass <span class="d_keyword">function</span>() getMyClass_fp;

    <span class="d_keyword">int</span> main()
    {   HMODULE h;
        FARPROC fp;

        getMyClass_fp getMyClass;
        MyClass c;

        printf(<span class="d_string">"Start Dynamic Link...\n"</span>);

        h = <span class="d_keyword">cast</span>(HMODULE) Runtime.loadLibrary(<span class="d_string">"mydll.dll"</span>);
        <span class="d_keyword">if</span> (h <span class="d_keyword">is</span> <span class="d_keyword">null</span>)
        {
            printf(<span class="d_string">"error loading mydll.dll\n"</span>);
            <span class="d_keyword">return</span> 1;
        }

        fp = GetProcAddress(h, <span class="d_string">"D5mydll10getMyClassFZC5mydll7MyClass"</span>);
        <span class="d_keyword">if</span> (fp <span class="d_keyword">is</span> <span class="d_keyword">null</span>)
        {   printf(<span class="d_string">"error loading symbol getMyClass()\n"</span>);
            <span class="d_keyword">return</span> 1;
        }

        getMyClass = <span class="d_keyword">cast</span>(getMyClass_fp) fp;
        c = (*getMyClass)();
        foo(c);

        <span class="d_keyword">if</span> (!Runtime.unloadLibrary(h))
        {   printf(<span class="d_string">"error freeing mydll.dll\n"</span>);
            <span class="d_keyword">return</span> 1;
        }

        printf(<span class="d_string">"End...\n"</span>);
        <span class="d_keyword">return</span> 0;
    }
}
<span class="d_keyword">else</span>
{   <span class="d_comment">// static link the DLL
</span>    <span class="d_keyword">extern</span> (C)
    {
        <span class="d_keyword">void</span>* gc_getProxy();
    }

    <span class="d_keyword">int</span> main()
    {
	printf(<span class="d_string">"Start Static Link...\n"</span>);
	MyDLL_Initialize(gc_getProxy());
	foo(getMyClass());
	MyDLL_Terminate();
	printf(<span class="d_string">"End...\n"</span>);
	<span class="d_keyword">return</span> 0;
    }
}

<span class="d_keyword">void</span> foo(MyClass c)
{
    <span class="d_keyword">char</span>[] s;

    s = c.concat(<span class="d_string">"Hello"</span>, <span class="d_string">"world!"</span>);
    writefln(s);
    c.free(s);
    <span class="d_keyword">delete</span> c;
}
</span></pre>

	<p>Let's start with the statically linked version, which is simpler.
	It's compiled and linked with the command:
	</p>

<pre class="console"><span class="notranslate">C:&gt;dmd test mydll.lib -g
</span></pre>

	<p>Note how it is linked with <tt>mydll.lib</tt>, the import library
	for <tt>mydll.dll</tt>.
	The code is straightforward, it initializes <tt>mydll.lib</tt> with
	a call to <b>MyDLL_Initialize</b>(), passing the handle
	to <tt>test.exe</tt>'s gc.
	Then, we can use the DLL and call its functions just as if
	it were part of <tt>test.exe</tt>. In <b>foo</b>(), gc memory
	is allocated and freed both by <tt>test.exe</tt> and <tt>mydll.dll</tt>.
	When we're done using the DLL, it is terminated with
	<b>MyDLL_Terminate</b>().
	</p>

	<p>Running it looks like this:</p>

<pre class="console"><span class="notranslate">C:&gt;test
DLL_PROCESS_ATTACH
Start Static Link...
MyDLL_Initialize()
static this for mydll
Hello world!
MyDLL_Terminate()
static ~this for mydll
End...
C:&gt;
</span></pre>

	<p>The dynamically linked version is a little harder to set up.
	Compile and link it with the command:
	</p>

<pre class="console"><span class="notranslate">C:&gt;dmd test -version=DYNAMIC_LOAD -g
</span></pre>
	<p>The import library <tt>mydll.lib</tt> is not needed.
	The DLL is loaded with a call to
	<b>Runtime.loadLibrary</b>(),
	and each exported function has to be retrieved via
	a call to
	<b>GetProcAddress</b>().
	An easy way to get the decorated name to pass to <b>GetProcAddress</b>()
	is to copy and paste it from the generated <tt>mydll.map</tt> file
	under the <b>Export</b> heading.
	Once this is done, we can use the member functions of the
	DLL classes as if they were part of <tt>test.exe</tt>.
	When done, release the DLL with
	<b>Runtime.unloadLibrary</b>().
	</p>

	<p>Running it looks like this:</p>

<pre class="console"><span class="notranslate">C:&gt;test
Start Dynamic Link...
DLL_PROCESS_ATTACH
static this for mydll
Hello world!
static ~this for mydll
DLL_PROCESS_DETACH
End...
C:&gt;
</span></pre>


  
<div id="google_ad">
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>

</div><!--/content-->





<div id="footernav">
<a href="http://forum.dlang.org/" title="User Forums">Forums</a> |
<a href="http://wiki.dlang.org/DocComments/DLLs" title="Read/write comments and feedback">Comments</a> |
<a href="http://digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="download.html" title="Download D">Downloads</a> |
<a href="/">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2013 by Digital Mars &reg;, All Rights Reserved
 |
Page generated by <a href="ddoc.html">Ddoc</a> on Wed Oct 02 13:49:25 2013


</div>

</body>
</html>

