<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>object</title>
        </head><body>
        <h1>object</h1>
        <!-- Generated by Ddoc from src\object_.d -->
Forms the symbols available to all D programs. Includes Object, which is
 the root of the class <u>object</u> hierarchy.  This module is implicitly
 imported.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>
Walter Bright, Sean Kelly<br><br>

<dl><dt><big><a name="Object"></a>class <u>Object</u>;
</big></dt>
<dd>All D class objects inherit from <u>Object</u>.<br><br>

<dl><dt><big><a name="Object.toString"></a>string <u>toString</u>();
</big></dt>
<dd>Convert Object to a human readable string.<br><br>

</dd>
<dt><big><a name="Object.toHash"></a>nothrow @trusted size_t <u>toHash</u>();
</big></dt>
<dd>Compute hash function for Object.<br><br>

</dd>
<dt><big><a name="Object.opCmp"></a>int <u>opCmp</u>(Object <i>o</i>);
</big></dt>
<dd>Compare with another Object obj.
<br><br>
<b>Returns:</b><br>
<table> <tr><td>this &lt; obj</td> <td>&lt; 0</td></tr>
  <tr><td>this == obj</td> <td>0</td></tr>
  <tr><td>this &gt; obj</td> <td>&gt; 0</td></tr>
  </table><br><br>

</dd>
<dt><big><a name="Object.opEquals"></a>bool <u>opEquals</u>(Object <i>o</i>);
</big></dt>
<dd>Returns !=0 if this object does have the same contents as obj.<br><br>

</dd>
<dt><big><a name="Object.factory"></a>static Object <u>factory</u>(string <i>classname</i>);
</big></dt>
<dd>Create instance of class specified by <i>classname</i>.
 The class must either have no constructors or have
 a default constructor.
<br><br>
<b>Returns:</b><br>
<b>null</b> if failed<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="opEquals"></a>bool <u>opEquals</u>(const Object <i>lhs</i>, const Object <i>rhs</i>);
</big></dt>
<dd>Returns <b>true</b> if <i>lhs</i> and <i>rhs</i> are equal.<br><br>

</dd>
<dt><big><a name="Interface"></a>struct <u>Interface</u>;
</big></dt>
<dd>Information about an interface.
 When an object is accessed via an interface, an <u>Interface</u>* appears as the
 first entry in its vtbl.<br><br>

<dl><dt><big><a name="Interface.classinfo"></a>TypeInfo_Class <u>classinfo</u>;
</big></dt>
<dd>.<u>classinfo</u> for this interface (not for containing class)<br><br>

</dd>
<dt><big><a name="Interface.offset"></a>size_t <u>offset</u>;
</big></dt>
<dd><u>offset</u> to Interface 'this' from Object 'this'<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Classinfo"></a>alias <u>Classinfo</u> = TypeInfo_Class;
</big></dt>
<dd>Runtime type information about a class. Can be retrieved for any class type
 or instance by using the .classinfo property.
 A pointer to this appears as the first entry in the class's vtbl[].<br><br>

</dd>
<dt><big><a name="OffsetTypeInfo"></a>struct <u>OffsetTypeInfo</u>;
</big></dt>
<dd>Array of pairs giving the offset and type information for each
 member in an aggregate.<br><br>

<dl><dt><big><a name="OffsetTypeInfo.offset"></a>size_t <u>offset</u>;
</big></dt>
<dd>Offset of member from start of object<br><br>

</dd>
<dt><big><a name="OffsetTypeInfo.ti"></a>TypeInfo <u>ti</u>;
</big></dt>
<dd>TypeInfo for this member<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="rtinfoNoPointers"></a>void* <u>rtinfoNoPointers</u>;
</big></dt>
<dd>shortcuts for the precise GC, also generated by the compiler
 used instead of the actual pointer bitmap<br><br>

</dd>
<dt><big><a name="TypeInfo"></a>class <u>TypeInfo</u>;
</big></dt>
<dd>Runtime type information about a type.
 Can be retrieved for any type using a
 <a href="../expression.html#typeidexpression">TypeidExpression</a>.<br><br>

<dl><dt><big><a name="TypeInfo.getHash"></a>const nothrow @trusted size_t <u>getHash</u>(in void* <i>p</i>);
</big></dt>
<dd>Returns a hash of the instance of a type.<br><br>

</dd>
<dt><big><a name="TypeInfo.equals"></a>const bool <u>equals</u>(in void* <i>p1</i>, in void* <i>p2</i>);
</big></dt>
<dd>Compares two instances for equality.<br><br>

</dd>
<dt><big><a name="TypeInfo.compare"></a>const int <u>compare</u>(in void* <i>p1</i>, in void* <i>p2</i>);
</big></dt>
<dd>Compares two instances for &lt;, ==, or &gt;.<br><br>

</dd>
<dt><big><a name="TypeInfo.tsize"></a>const pure nothrow @property @safe size_t <u>tsize</u>();
</big></dt>
<dd>Returns size of the type.<br><br>

</dd>
<dt><big><a name="TypeInfo.swap"></a>const void <u>swap</u>(void* <i>p1</i>, void* <i>p2</i>);
</big></dt>
<dd>Swaps two instances of the type.<br><br>

</dd>
<dt><big><a name="TypeInfo.next"></a>inout pure nothrow @property inout(TypeInfo) <u>next</u>();
</big></dt>
<dd>Get TypeInfo for '<u>next</u>' type, as defined by what kind of type this is,
 <b>null</b> if none.<br><br>

</dd>
<dt><big><a name="TypeInfo.init"></a>const pure nothrow @safe const(void)[] <u>init</u>();
</big></dt>
<dd>Return default initializer.  If the type should be initialized to all zeros,
 an array with a <b>null</b> ptr and a length equal to the type size will be returned.<br><br>

</dd>
<dt><big><a name="TypeInfo.flags"></a>const pure nothrow @property @safe uint <u>flags</u>();
</big></dt>
<dd>Get <u>flags</u> for type: 1 means GC should scan for pointers<br><br>

</dd>
<dt><big><a name="TypeInfo.offTi"></a>const const(OffsetTypeInfo)[] <u>offTi</u>();
</big></dt>
<dd>Get type information on the contents of the type; <b>null</b> if not available<br><br>

</dd>
<dt><big><a name="TypeInfo.destroy"></a>const void <u>destroy</u>(void* <i>p</i>);
</big></dt>
<dd>Run the destructor on the object and all its sub-objects<br><br>

</dd>
<dt><big><a name="TypeInfo.postblit"></a>const void <u>postblit</u>(void* <i>p</i>);
</big></dt>
<dd>Run the <u>postblit</u> on the object and all its sub-objects<br><br>

</dd>
<dt><big><a name="TypeInfo.talign"></a>const pure nothrow @property @safe size_t <u>talign</u>();
</big></dt>
<dd>Return alignment of type<br><br>

</dd>
<dt><big><a name="TypeInfo.rtInfo"></a>const pure nothrow @property @safe immutable(void)* <u>rtInfo</u>();
</big></dt>
<dd>Return info used by the garbage collector to do precise collection.<br><br>

</dd>
<dt><big><a name="TypeInfo.unqual"></a>const pure nothrow @property @safe const(TypeInfo) <u>unqual</u>();
</big></dt>
<dd>Return the unqualified type (stripping const,immutable,shared)<br><br>

</dd>
<dt><big><a name="TypeInfo.info"></a>const pure nothrow @property @safe const(TypeInfo_Class) <u>info</u>();
</big></dt>
<dd>Return the type <u>info</u> of a class, <b>null</b> for everything else (used for fast dynamic cast)<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="TypeInfo_Class"></a>class <u>TypeInfo_Class</u>: object.TypeInfo;
</big></dt>
<dd>Runtime type information about a class.
 Can be retrieved from an object instance by using the
 <a href="../property.html#classinfo">.classinfo</a> property.<br><br>

<dl><dt><big><a name="TypeInfo_Class.init"></a>byte[] <u>init</u>;
</big></dt>
<dd>class static initializer
 (<u>init</u>.length gives size in bytes of class)<br><br>

</dd>
<dt><big><a name="TypeInfo_Class.name"></a>string <u>name</u>;
</big></dt>
<dd>class <u>name</u><br><br>

</dd>
<dt><big><a name="TypeInfo_Class.vtbl"></a>void*[] <u>vtbl</u>;
</big></dt>
<dd>virtual function pointer table<br><br>

</dd>
<dt><big><a name="TypeInfo_Class.interfaces"></a>Interface[] <u>interfaces</u>;
</big></dt>
<dd><u>interfaces</u> this class implements<br><br>

</dd>
<dt><big><a name="TypeInfo_Class.base"></a>TypeInfo_Class <u>base</u>;
</big></dt>
<dd><u>base</u> class<br><br>

</dd>
<dt><big><a name="TypeInfo_Class.find"></a>static const(TypeInfo_Class) <u>find</u>(in char[] <i>classname</i>);
</big></dt>
<dd>Search all modules for TypeInfo_Class corresponding to <i>classname</i>.
<br><br>
<b>Returns:</b><br>
<b>null</b> if not found<br><br>

</dd>
<dt><big><a name="TypeInfo_Class.create"></a>const Object <u>create</u>();
</big></dt>
<dd>Create instance of Object represented by 'this'.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Throwable"></a>class <u>Throwable</u>;
</big></dt>
<dd>The base class of all thrown objects.
<br><br>
All thrown objects must inherit from <u>Throwable</u>. Class , which
 derives from this class, represents the category of thrown objects that are
 safe to catch and handle. In principle, one should not catch <u>Throwable</u>
 objects that are not derived from , as they represent
 unrecoverable runtime errors. Certain runtime guarantees may fail to hold
 when these errors are thrown, making it unsafe to continue execution after
 catching them.<br><br>

<dl><dt><big><a name="Throwable.msg"></a>string <u>msg</u>;
</big></dt>
<dd>A message describing the error.<br><br>

</dd>
<dt><big><a name="Throwable.file"></a>string <u>file</u>;
<br><a name="Throwable.line"></a>size_t <u>line</u>;
</big></dt>
<dd>The file name and line number of the D source code corresponding with
 where the error was thrown from.<br><br>

</dd>
<dt><big><a name="Throwable.info"></a>TraceInfo <u>info</u>;
</big></dt>
<dd>The stack trace of where the error happened. This is an opaque object
 that can either be converted to , or iterated over with  to extract the items in the stack trace (as strings).<br><br>

</dd>
<dt><big><a name="Throwable.next"></a>Throwable <u>next</u>;
</big></dt>
<dd>A reference to the next error in the list. This is used when a new
  is thrown from inside a  block. The originally
 caught  will be chained to the new  via this
 field.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="rt_setTraceHandler"></a>void <u>rt_setTraceHandler</u>(TraceHandler <i>h</i>);
</big></dt>
<dd>Overrides the default trace hander with a user-supplied version.
<br><br>
<b>Params:</b><br>
<table><tr><td>TraceHandler <i>h</i></td>
<td>The new trace handler.  Set to <b>null</b> to use the default handler.</td></tr>
</table><br>

</dd>
<dt><big><a name="rt_getTraceHandler"></a>TraceHandler <u>rt_getTraceHandler</u>();
</big></dt>
<dd>Return the current trace handler<br><br>

</dd>
<dt><big><a name="_d_traceContext"></a>Throwable.TraceInfo <u>_d_traceContext</u>(void* <i>ptr</i> = null);
</big></dt>
<dd>This function will be called when an exception is constructed.  The
 user-supplied trace handler will be called if one has been supplied,
 otherwise no trace will be generated.
<br><br>
<b>Params:</b><br>
<table><tr><td>void* <i>ptr</i></td>
<td>A pointer to the location from which to generate the trace, or <b>null</b>
        if the trace should be generated from within the trace handler
        itself.</td></tr>
</table><br>
<b>Returns:</b><br>
An object describing the current calling context or <b>null</b> if no handler is
  supplied.<br><br>

</dd>
<dt><big><a name="Exception"></a>class <u>Exception</u>: object.Throwable;
</big></dt>
<dd>The base class of all errors that are safe to catch and handle.
<br><br>
In principle, only thrown objects derived from this class are safe to catch
 inside a  block. Thrown objects not derived from <u>Exception</u>
 represent runtime errors that should not be caught, as certain runtime
 guarantees may not hold, making it unsafe to continue program execution.<br><br>

<dl><dt><big><a name="Exception.this"></a> this(string <i>msg</i>, string <i>file</i> = __FILE__, size_t <i>line</i> = __LINE__, Throwable <i>next</i> = null);
</big></dt>
<dd>Creates a new instance of Exception. The <i>next</i> parameter is used
 internally and should be always be  when passed by user code.
 This constructor does not automatically throw the newly-created
 Exception; the  statement should be used for that purpose.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="IMonitor"></a>alias <u>IMonitor</u> = Object.Monitor;
</big></dt>
<dd><br><br>
</dd>
<dt><big><a name="destroy"></a>void <u>destroy</u>(T)(T <i>obj</i>) if (is(T == class));
</big></dt>
<dd>Destroys the given object and puts it in an invalid state. It's used to
    <u>destroy</u> an object so that any cleanup which its destructor or finalizer
    does is done and so that it no longer references any other objects. It does
    <i>not</i> initiate a GC cycle or free any GC memory.<br><br>

</dd>
<dt><big><a name="capacity"></a>pure nothrow size_t <u>capacity</u>(T)(T[] <i>arr</i>);
</big></dt>
<dd>(Property) Get the current <u>capacity</u> of a slice. The <u>capacity</u> is the size
 that the slice can grow to before the underlying array must be
 reallocated or extended.
<br><br>
If an append must reallocate a slice with no possibility of extension, then
 0 is returned. This happens when the slice references a static array, or
 if another slice references elements past the end of the current slice.

<br><br>
<b>Note:</b><br>
The <u>capacity</u> of a slice may be impacted by operations on other slices.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
    <font color=green>//Static array slice: no capacity
</font>    <font color=blue>int</font>[4] sarray = [1, 2, 3, 4];
    <font color=blue>int</font>[]  slice  = sarray[];
    <font color=blue>assert</font>(sarray.<u>capacity</u> == 0);
    <font color=green>//Appending to slice will reallocate to a new array
</font>    slice ~= 5;
    <font color=blue>assert</font>(slice.<u>capacity</u> &gt;= 5);

    <font color=green>//Dynamic array slices
</font>    <font color=blue>int</font>[] a = [1, 2, 3, 4];
    <font color=blue>int</font>[] b = a[1 .. $];
    <font color=blue>int</font>[] c = a[1 .. $ - 1];
    <font color=blue>assert</font>(a.<u>capacity</u> != 0);
    <font color=blue>assert</font>(a.<u>capacity</u> == b.<u>capacity</u> + 1); <font color=green>//both a and b share the same tail
</font>    <font color=blue>assert</font>(c.<u>capacity</u> == 0);              <font color=green>//an append to c must relocate c.
</font></pre>
<br><br>
</dd>
<dt><big><a name="reserve"></a>pure nothrow @trusted size_t <u>reserve</u>(T)(ref T[] <i>arr</i>, size_t <i>newcapacity</i>);
</big></dt>
<dd>Reserves capacity for a slice. The capacity is the size
 that the slice can grow to before the underlying array must be
 reallocated or extended.
<br><br>
The return value is the new capacity of the array (which may be larger than
 the requested capacity).<br><br>
<b>Examples:</b><br>
<pre class="d_code">
    <font color=green>//Static array slice: no capacity. Reserve relocates.
</font>    <font color=blue>int</font>[4] sarray = [1, 2, 3, 4];
    <font color=blue>int</font>[]  slice  = sarray[];
    <font color=blue>auto</font> u = slice.<u>reserve</u>(8);
    <font color=blue>assert</font>(u &gt;= 8);
    <font color=blue>assert</font>(sarray.ptr !<font color=blue>is</font> slice.ptr);
    <font color=blue>assert</font>(slice.capacity == u);

    <font color=green>//Dynamic array slices
</font>    <font color=blue>int</font>[] a = [1, 2, 3, 4];
    a.<u>reserve</u>(8); <font color=green>//prepare a for appending 4 more items
</font>    <font color=blue>auto</font> p = a.ptr;
    u = a.capacity;
    a ~= [5, 6, 7, 8];
    <font color=blue>assert</font>(p == a.ptr);      <font color=green>//a should not have been reallocated
</font>    <font color=blue>assert</font>(u == a.capacity); <font color=green>//a should not have been extended
</font></pre>
<br><br>
</dd>
<dt><big><a name="assumeSafeAppend"></a>inout(T[]) <u>assumeSafeAppend</u>(T)(auto ref inout(T[]) <i>arr</i>);
</big></dt>
<dd>Assume that it is safe to append to this array. Appends made to this array
 after calling this function may append in place, even if the array was a
 slice of a larger array to begin with.
<br><br>
Use this only when it is certain there are no elements in use beyond the
 array in the memory block.  If there are, those elements will be
 overwritten by appending to this array.
<br><br>

 Calling this function, and then using references to data located after the
 given array results in undefined behavior.

<br><br>
<b>Returns:</b><br>
The input is returned.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
    <font color=blue>int</font>[] a = [1, 2, 3, 4];

    <font color=green>// Without assumeSafeAppend. Appending relocates.
</font>    <font color=blue>int</font>[] b = a [0 .. 3];
    b ~= 5;
    <font color=blue>assert</font>(a.ptr != b.ptr);

    <font color=green>// With assumeSafeAppend. Appending overwrites.
</font>    <font color=blue>int</font>[] c = a [0 .. 3];
    c.<u>assumeSafeAppend</u>() ~= 5;
    <font color=blue>assert</font>(a.ptr == c.ptr);
</pre>
<br><br>
</dd>
<dt><big><a name="_ArrayEq"></a>bool <u>_ArrayEq</u>(T1, T2)(T1[] <i>a1</i>, T2[] <i>a2</i>);
</big></dt>
<dd>Helper function used to see if two containers of different
 types have the same contents in the same sequence.<br><br>

</dd>
<dt><big><a name="RTInfo"></a>template <u>RTInfo</u>(T)</big></dt>
<dd>Create <u>RTInfo</u> for type T<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright Digital Mars 2000 - 2011.
</small>
        </body></html>
