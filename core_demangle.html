<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>core.demangle</title>
        </head><body>
        <h1>core.demangle</h1>
        <!-- Generated by Ddoc from src\core\demangle.d -->
The <u>demangle</u> module converts mangled D symbols to a representation similar
 to what would have existed in code.
<br><br>
<b>License:</b><br>
<a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
<br><br>
<b>Authors:</b><br>
Sean Kelly<br><br>

<dl><dt><big><a name="demangle"></a>char[] <u>demangle</u>(const(char)[] <i>buf</i>, char[] <i>dst</i> = null);
</big></dt>
<dd>Demangles D mangled names.  If it is not a D mangled name, it returns its
 argument name.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(char)[] <i>buf</i></td>
<td>The string to <u>demangle</u>.</td></tr>
<tr><td>char[] <i>dst</i></td>
<td>An optional destination buffer.</td></tr>
</table><br>
<b>Returns:</b><br>
The demangled name or the original string if the name is not a mangled D
  name.<br><br>

</dd>
<dt><big><a name="demangleType"></a>char[] <u>demangleType</u>(const(char)[] <i>buf</i>, char[] <i>dst</i> = null);
</big></dt>
<dd>Demangles a D mangled type.
<br><br>
<b>Params:</b><br>
<table><tr><td>const(char)[] <i>buf</i></td>
<td>The string to demangle.</td></tr>
<tr><td>char[] <i>dst</i></td>
<td>An optional destination buffer.</td></tr>
</table><br>
<b>Returns:</b><br>
The demangled type name or the original string if the name is not a
  mangled D type.<br><br>

</dd>
<dt><big><a name="mangle"></a>pure nothrow @safe char[] <u>mangle</u>(T)(const(char)[] <i>fqn</i>, char[] <i>dst</i> = null);
</big></dt>
<dd>Mangles a D symbol.
<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>The type of the symbol.</td></tr>
<tr><td>const(char)[] fqn</td>
<td>The fully qualified name of the symbol.</td></tr>
<tr><td>char[] dst</td>
<td>An optional destination buffer.</td></tr>
</table><br>
<b>Returns:</b><br>
The mangled name for a symbols of type T and the given fully
  qualified name.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
    <font color=blue>assert</font>(<u>mangle</u>!<font color=blue>int</font>(<font color=red>"a.b"</font>) == <font color=red>"_D1a1bi"</font>);
    <font color=blue>assert</font>(<u>mangle</u>!(<font color=blue>char</font>[])(<font color=red>"test.foo"</font>) == <font color=red>"_D4test3fooAa"</font>);
    <font color=blue>assert</font>(<u>mangle</u>!(<font color=blue>int</font> <font color=blue>function</font>(<font color=blue>int</font>))(<font color=red>"a.b"</font>) == <font color=red>"_D1a1bPFiZi"</font>);
</pre>
<br><br>
</dd>
<dt><big><a name="mangleFunc"></a>pure nothrow @safe char[] <u>mangleFunc</u>(T : FT*, FT)(const(char)[] <i>fqn</i>, char[] <i>dst</i> = null) if (is(FT == function));
</big></dt>
<dd>Mangles a D function.
<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>function pointer type.</td></tr>
<tr><td>const(char)[] fqn</td>
<td>The fully qualified name of the symbol.</td></tr>
<tr><td>char[] dst</td>
<td>An optional destination buffer.</td></tr>
</table><br>
<b>Returns:</b><br>
The mangled name for a function with function pointer type T and
  the given fully qualified name.<br><br>
<b>Examples:</b><br>
<pre class="d_code">
    <font color=blue>assert</font>(<u>mangleFunc</u>!(<font color=blue>int</font> <font color=blue>function</font>(<font color=blue>int</font>))(<font color=red>"a.b"</font>) == <font color=red>"_D1a1bFiZi"</font>);
    <font color=blue>assert</font>(<u>mangleFunc</u>!(<font color=blue>int</font> <font color=blue>function</font>(Object))(<font color=red>"object.Object.opEquals"</font>) == <font color=red>"_D6object6Object8opEqualsFC6ObjectZi"</font>);
</pre>
<br><br>
</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Copyright Sean Kelly 2010 - 2010.
</small>
        </body></html>
