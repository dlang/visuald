
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en-US">

<!--
	Copyright (c) 1999-2013 by Digital Mars
	All Rights Reserved Written by Walter Bright
	http://digitalmars.com
  -->

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Operator Overloading - D Programming Language</title>
<link rel="stylesheet" href="css/codemirror.css" />
<link rel="stylesheet" type="text/css" href="css/style.css" />
<link rel="stylesheet" type="text/css" href="css/print.css" media="print" />
<link rel="shortcut icon" href="favicon.ico" />

<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript"></script>
<script src="/js/codemirror.js"></script>
<script src="/js/run-main-website.js" type="text/javascript"></script>
<script src="/js/d.js"></script>
<script src="/js/run.js" type="text/javascript"></script>

<script type="text/javascript">
function bodyLoad()
{
	var links = document.getElementById("navigation").getElementsByTagName("a");
	for (var i = 0; i < links.length; i++)
	{
		var url = "/" + links[i].getAttribute("href");
		if (window.location.href.match(url + "\x24") == url)
		{
			var cls = links[i].getAttribute("class");
			links[i].setAttribute("class", cls ? cls + " active" : "active");
			break;
		}
	}
}
</script>
</head>

<body onLoad='bodyLoad()'>

<div id="top">
	<div id="search-box">
		<form method="get" action="http://google.com/search">
			<img src="/images/search-left.gif" width="11" height="22" /><input id="q" name="q" /><input type="image" id="search-submit" name="submit" src="/images/search-button.gif" />
			<input type="hidden" id="domains" name="domains" value="dlang.org" />
			<input type="hidden" id="sourceid" name="sourceid" value="google-search" />
			<div id="search-dropdown">
				<select id="sitesearch" name="sitesearch" size="1">
					<option value="dlang.org">Entire D Site</option>
					<option value="dlang.org/phobos">Library Reference</option>
					<option value="digitalmars.com/d/archives">Newsgroup Archives</option>
				</select>
			</div>
		</form>
	</div>
	<div id="header">
		<a id="d-language" href="/">
		<img id="logo" width="125" height="95" border="0" alt="D Logo" src="/images/dlogo.png">
		D Programming Language</a>
	</div>
</div>

<!--Generated by Ddoc from operatoroverloading.dd-->



<div id="navigation">
  

<div class="navblock">
<h2><a href="index.html" title="D Programming Language">D </a></h2>
<ul>	<li><a href="overview.html" title="D language overview">Overview</a></li>

	<li><a href="comparison.html" title="D feature list">Features</a></li>

	<li><a href="download.html" title="Download a D compiler">Downloads &amp; Tools</a></li>

	<li><a href="changelog.html" title="History of changes to D">Change Log</a></li>
	<li><a href="bugstats.php" title="D issue and bug tracking system">Bug Tracker</a></li>
	<li><a href="faq.html" title="Frequently Asked Questions">FAQ</a></li>

	<li><a href="appendices.html">Appendices</a></li>
	<li><a href="acknowledgements.html" title="Thank-you to these people who have helped with D">Acknowledgments</a></li>
	<li><a href="sitemap.html" title="Documents on this site, indexed alphabetically">Sitemap</a></li>
	<li><a href="http://digitalmars.com/d/1.0/index.html" title="D Programming Language 1.0">D1 Home</a></li>
</ul>
    </div>


<div class="navblock">
<h2>Documentation</h2>
<ul>    <li><a href="http://www.amazon.com/exec/obidos/ASIN/0321635361/classicempire">Book</a>
</li>
	<li><a href="http://www.informit.com/articles/article.aspx?p=1381876">&nbsp;<font size=-1><span style="visibility: hidden">3</span>1.&nbsp;Tutorial</font></a></li>
	<li><a href="http://www.informit.com/articles/article.aspx?p=1609144">&nbsp;<font size=-1>13.&nbsp;Concurrency</font></a></li>

	<li><a href="language-reference.html">Language Reference</a>

    <div class="navblock">
<ul>	<li><a href="lex.html">Lexical</a></li>
	<li><a href="module.html">Modules</a></li>
	<li><a href="declaration.html">Declarations</a></li>
	<li><a href="type.html">Types</a></li>
	<li><a href="property.html">Properties</a></li>
	<li><a href="attribute.html">Attributes</a></li>
	<li><a href="pragma.html">Pragmas</a></li>
	<li><a href="expression.html">Expressions</a></li>
	<li><a href="statement.html">Statements</a></li>
	<li><a href="arrays.html">Arrays</a></li>
	<li><a href="hash-map.html">Associative Arrays</a></li>
	<li><a href="struct.html">Structs &amp; Unions</a></li>
	<li><a href="class.html">Classes</a></li>
	<li><a href="interface.html">Interfaces</a></li>
	<li><a href="enum.html">Enums</a></li>
	<li><a href="const3.html">Const and Immutable</a></li>
	<li><a href="function.html">Functions</a></li>
	<li><a href="operatoroverloading.html">Operator Overloading</a></li>
	<li><a href="template.html">Templates</a></li>
	<li><a href="template-mixin.html">Template Mixins</a></li>
	<li><a href="dbc.html">Contracts</a></li>
	<li><a href="version.html">Conditional Compilation</a></li>
	<li><a href="simd.html">Vector Extensions</a></li>
	<li><a href="traits.html">Traits</a></li>
	<li><a href="errors.html">Handling errors</a></li>
	<li><a href="unittest.html">Unit Tests</a></li>
	<li><a href="garbage.html">Garbage Collection</a></li>
	<li><a href="float.html">Floating Point</a></li>
	<li><a href="iasm.html">Inline Assembler</a></li>
	<li><a href="ddoc.html">Documentation Comments</a></li>
	<li><a href="interfaceToC.html">Interfacing To C</a></li>
	<li><a href="cpp_interface.html">Interfacing To C++</a></li>
	<li><a href="portability.html">Portability Guide</a></li>
	<li><a href="entity.html">Named Character Entities</a></li>
	<li><a href="memory-safe-d.html">Memory Safe D Spec</a></li>
	<li><a href="abi.html">Application Binary Interface</a></li>
    </ul>
</div>
</li>
	<li><a href="phobos/index.html">Library Reference</a></li>
	<li><a href="visuald/StartPage.html">Visual D</a></li>
	<li><a href="howtos.html" title="Helps for using D">How-tos</a></li>

	<li><a href="articles.html">Articles</a></li>
</ul>
    </div>


<div class="navblock">
<h2>Community</h2>
<ul>	<li><a href="http://forum.dlang.org/" title="User forums">Forums</a></li>
	<li><a href="http://github.com/D-Programming-Language" title="D on github">GitHub</a></li>
	<li><a href="http://wiki.dlang.org" title="Wiki for the D Programming Language">Wiki</a></li>
	<li><a href="http://wiki.dlang.org/Review_Queue" title="Queue of current and upcoming standard library additions">Review Queue</a></li>
	<li><a href="http://twitter.com/#search?q=%23d_lang" title="#d_lang on twitter.com">Twitter</a></li>
	<li><a href="http://digitalmars.com/d/dlinks.html" title="External D related links">Links</a></li>
	
</ul>
    </div>


  
<div id="translate" class="tool">Translate this page:
	<div id="google_translate_element"></div><script type="text/javascript">
	function googleTranslateElementInit() {
	  new google.translate.TranslateElement({
	    pageLanguage: 'en',
	    autoDisplay: false,
	    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
	  }, 'google_translate_element');
	}
	</script>
<script type="text/javascript" src="http://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</div>

</div><!--/navigation-->
<div id="content" class='hyphenate'>
  
<div id="tools">
	<!--span id="lastupdate">Last update Wed Oct 02 13:49:23 2013

</span-->
	<span class="tip">
		<a href="https://github.com/D-Programming-Language/dlang.org/edit/master/operatoroverloading.dd" class="button">Improve this page</a>
		<span>
			Quickly fork, edit online, and submit a pull request for this page.
			Requires a signed-in GitHub account. This works well for small changes.
			If you'd like to make larger changes you may want to consider using
			local clone.
		</span>
	</span>
	<span class="tip">
		<a href="http://wiki.dlang.org/DocComments/OperatorOverloading" class="button">Page wiki</a>
		<span>
			View or edit the community-maintained wiki page associated with this page.
		</span>
	</span>
</div>

  <h1>Operator Overloading</h1>
  
	<p>Operator overloading is accomplished by rewriting operators whose
	operands are class or struct objects into calls to specially named
	member functions. No additional syntax is used.
	</p>

	<ul>	<li><a href="#Unary">Unary Operator Overloading</a></li>
	<li><a href="#Cast">Cast Operator Overloading</a></li>
	<li><a href="#Binary">Binary Operator Overloading</a></li>
	<li><a href="#equals">Overloading <span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span> and <span class="notranslate"><span class="d_inlinecode donthyphenate">!=</span></span></a></li>
	<li><a href="#compare">Overloading <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span>,
	<span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span>, and <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span></a></li>
	<li><a href="#FunctionCall">Function Call Operator Overloading</a></li>
	<li><a href="#Assignment">Assignment Operator Overloading</a></li>
	<li><a href="#OpAssign">Op Assignment Operator Overloading</a></li>
	<li><a href="#Array">Index Operator Overloading</a></li>
	<li><a href="#Slice">Slice Operator Overloading</a></li>
	<li><a href="#Dispatch">Forwarding</a></li>
	</ul>

<h2><a name="Unary">Unary Operator Overloading</a></h2>

	<center><table border=1 cellpadding=4 cellspacing=0><caption>Overloadable Unary Operators</caption>
	<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">-</span></span><i>e</i></td><td>	<i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opUnary!("-")()</span></span>
	</td></tr>
	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">+</span></span><i>e</i></td><td>	<i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opUnary!("+")()</span></span>
	</td></tr>
	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">~</span></span><i>e</i></td><td>	<i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opUnary!("~")()</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">*</span></span><i>e</i></td><td>	<i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opUnary!("*")()</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">++</span></span><i>e</i></td><td>	<i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opUnary!("++")()</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">--</span></span><i>e</i></td><td>	<i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opUnary!("--")()</span></span>
	</td></tr>
	</table></center>

	<p>For example, in order to overload the - (negation) operator for struct S, and
	no other operator:</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S {
  <span class="d_keyword">int</span> m;

  <span class="d_keyword">int</span> opUnary(string s)() <span class="d_keyword">if</span> (s == <span class="d_string">"-"</span>) {
    <span class="d_keyword">return</span> -m;
  }
}

<span class="d_keyword">int</span> foo(S s) {
  <span class="d_keyword">return</span> -s;
}
</span></pre>

<h3>Postincrement <i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">++</span></span> and Postdecrement <i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">--</span></span> Operators</h3>

	<p>These are not directly overloadable, but instead are rewritten
	in terms of the ++<i>e</i> and --<i>e</i> prefix operators:
	</p>

	<center><table border=1 cellpadding=4 cellspacing=0><caption>Postfix Operator Rewrites</caption>
	<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
	<tr><td>	<i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">--</span></span></td><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">(auto t =</span></span> <i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">, --</span></span><i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">, t)</span></span></td></tr>
	<tr><td>	<i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">++</span></span></td><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">(auto t =</span></span> <i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">, ++</span></span><i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">, t)</span></span></td></tr>
	</table></center>

<h3>Overloading Index Unary Operators</h3>

	<center><table border=1 cellpadding=4 cellspacing=0><caption>Overloadable Index Unary Operators</caption>
	<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">-</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opIndexUnary!("-")(</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span></td></tr>
	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">+</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opIndexUnary!("+")(</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
	</td></tr>
	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">~</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opIndexUnary!("~")(</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
	</td></tr>
	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">*</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opIndexUnary!("*")(</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
	</td></tr>
	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">++</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opIndexUnary!("++")(</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
	</td></tr>
	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">--</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opIndexUnary!("--")(</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
	</td></tr>
	</table></center>

<h3>Overloading Slice Unary Operators</h3>

	<center><table border=1 cellpadding=4 cellspacing=0><caption>Overloadable Slice Unary Operators</caption>
	<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">-</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span><i>i</i>..<i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opSliceUnary!("-")(</span></span><i>i</i>, <i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">+</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span><i>i</i>..<i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opSliceUnary!("+")(</span></span><i>i</i>, <i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">~</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span><i>i</i>..<i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opSliceUnary!("~")(</span></span><i>i</i>, <i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">*</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span><i>i</i>..<i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opSliceUnary!("*")(</span></span><i>i</i>, <i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">++</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span><i>i</i>..<i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opSliceUnary!("++")(</span></span><i>i</i>, <i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">--</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[</span></span><i>i</i>..<i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opSliceUnary!("--")(</span></span><i>i</i>, <i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">-</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[ ]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opSliceUnary!("-")()</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">+</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[ ]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opSliceUnary!("+")()</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">~</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[ ]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opSliceUnary!("~")()</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">*</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[ ]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opSliceUnary!("*")()</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">++</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[ ]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opSliceUnary!("++")()</span></span>
	</td></tr>

	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">--</span></span><i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">[ ]</span></span></td><td>	<i>a</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opSliceUnary!("--")()</span></span>
	</td></tr>
	</table></center>

<h2><a name="Cast">Cast Operator Overloading</a></h2>

	<center><table border=1 cellpadding=4 cellspacing=0><caption>Cast Operators</caption>
	<tr><th class="donthyphenate"><b><i>op</i></b></th><th class="donthyphenate"><b><i>rewrite</i></b></th></tr>
	<tr><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">cast(</span></span><i>type</i> <i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span></td><td>	<i>e</i><span class="notranslate"><span class="d_inlinecode donthyphenate">.opCast!(</span></span><i>type</i><span class="notranslate"><span class="d_inlinecode donthyphenate">)()</span></span>
	</td></tr>
	</table></center>


<h3>Boolean Operations</h3>

	<p>Notably absent from the list of overloaded unary operators is the !
	logical negation operator. More obscurely absent is a unary operator
	to convert to a bool result.
	Instead, these are covered by a rewrite to:
	</p>
<pre class="d_code"><span class="notranslate">opCast!(<span class="d_keyword">bool</span>)(e)
</span></pre>

	<p>So,</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">if</span> (e)   =&gt;  <span class="d_keyword">if</span> (e.opCast!(<span class="d_keyword">bool</span>))
<span class="d_keyword">if</span> (!e)  =&gt;  <span class="d_keyword">if</span> (!e.opCast!(<span class="d_keyword">bool</span>))
</span></pre>

	<p>etc., whenever a bool result is expected. This only happens, however, for
	instances of structs. Class references are converted to bool by checking to
	see if the class reference is null or not.
	</p>

<h2><a name="Binary">Binary Operator Overloading</a></h2>

	<p>The following binary operators are overloadable:</p>

	<center><table border=1 cellpadding=4 cellspacing=0><caption>Overloadable Binary Operators</caption>
	<tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">+</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">-</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">*</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">/</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">%</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">^^</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&amp;</span></span></td></tr>
	<tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">|</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">^</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">~</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">in</span></span></td></tr>
	</table></center>

	<p>The expression:</p>
<pre class="d_code"><span class="notranslate">a <i>op</i> b
</span></pre>
	<p>is rewritten as both:</p>
<pre class="d_code"><span class="notranslate">a.opBinary!(<span class="d_string">"$(METACODE op)"</span>)(b)
b.opBinaryRight!(<span class="d_string">"$(METACODE op)"</span>)(a)
</span></pre>

	<p>and the one with the &lsquo;better&rsquo; match is selected.
	It is an error for both to equally match.
	</p>

	<p>Operator overloading for a number of operators can be done at the same time.
	For example, if only the + or - operators are supported:</p>

<pre class="d_code"><span class="notranslate">T opBinary(string op)(T rhs) {
   <span class="d_keyword">static</span> <span class="d_keyword">if</span> (op == <span class="d_string">"+"</span>) <span class="d_keyword">return</span> data + rhs.data;
   <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">if</span> (op == <span class="d_string">"-"</span>) <span class="d_keyword">return</span> data - rhs.data;
   <span class="d_keyword">else</span> <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(0, <span class="d_string">"Operator "</span>~op~<span class="d_string">" not implemented"</span>);
}
</span></pre>

	<p>To do them all en masse:</p>

<pre class="d_code"><span class="notranslate">T opBinary(string op)(T rhs) {
     <span class="d_keyword">return</span> <span class="d_keyword">mixin</span>(<span class="d_string">"data "</span>~op~<span class="d_string">" rhs.data"</span>);
}
</span></pre>


<h2><a name="equals">Overloading <span class="notranslate"><span class="d_inlinecode donthyphenate">==</span></span> and <span class="notranslate"><span class="d_inlinecode donthyphenate">!=</span></span></a></h2>

	<p>Expressions of the form <span class="notranslate"><span class="d_inlinecode donthyphenate">a != b</span></span> are rewritten as <span class="notranslate"><span class="d_inlinecode donthyphenate">!(a == b)</span></span>.</p>

	<p>Given <span class="notranslate"><span class="d_inlinecode donthyphenate">a == b</span></span> :</p>

<ol>	<li>If a and b are both class objects, then the expression is rewritten as:
<pre class="d_code"><span class="notranslate">.object.opEquals(a, b)
</span></pre>
	<p>and that function is implemented as:</p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">bool</span> opEquals(Object a, Object b) {
  <span class="d_keyword">if</span> (a <span class="d_keyword">is</span> b) <span class="d_keyword">return</span> <span class="d_keyword">true</span>;
  <span class="d_keyword">if</span> (a <span class="d_keyword">is</span> <span class="d_keyword">null</span> || b <span class="d_keyword">is</span> <span class="d_keyword">null</span>) <span class="d_keyword">return</span> <span class="d_keyword">false</span>;
  <span class="d_keyword">if</span> (<span class="d_keyword">typeid</span>(a) == <span class="d_keyword">typeid</span>(b)) <span class="d_keyword">return</span> a.opEquals(b);
  <span class="d_keyword">return</span> a.opEquals(b) &amp;&amp; b.opEquals(a);
}
</span></pre>
	</li>
	<li>Otherwise the expressions <span class="notranslate"><span class="d_inlinecode donthyphenate">a.opEquals(b)</span></span> and
	<span class="notranslate"><span class="d_inlinecode donthyphenate">b.opEquals(a)</span></span> are tried. If both resolve to the same opEquals
	function, then the expression is rewritten to be <span class="notranslate"><span class="d_inlinecode donthyphenate">a.opEquals(b)</span></span>.
	</li>
	<li>If one is a better match then the other, or one compiles and the other
	does not, the one is selected.</li>
	<li>Otherwise, an error results.</li>
</ol>

	<p>If overridding Object.opEquals() for classes, the class member function
	signature should look like:</p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C {
  <span class="d_keyword">override</span> <span class="d_keyword">bool</span> opEquals(Object o) { ... }
}
</span></pre>

	<p>If structs declare an opEquals member function for the identity comparison,
	it could have several forms, such as:</p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S {
  <span class="d_comment">// lhs should be mutable object
</span>  <span class="d_keyword">bool</span> opEquals(<span class="d_keyword">const</span> S s) { ... }        <span class="d_comment">// for r-values (e.g. temporaries)
</span>  <span class="d_keyword">bool</span> opEquals(<span class="d_keyword">ref</span> <span class="d_keyword">const</span> S s) { ... }    <span class="d_comment">// for l-values (e.g. variables)
</span>
  <span class="d_comment">// both hand side can be const object
</span>  <span class="d_keyword">bool</span> opEquals(<span class="d_keyword">const</span> S s) <span class="d_keyword">const</span> { ... }  <span class="d_comment">// for r-values (e.g. temporaries)
</span>}
</span></pre>

	<p>Alternatively, you can declare a single templated opEquals
	function with an <a href="template.html#auto-ref-parameters">auto ref</a>
	parameter:</p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S {
  <span class="d_comment">// for l-values and r-values,
</span>  <span class="d_comment">// with converting both hand side implicitly to const
</span>  <span class="d_keyword">bool</span> opEquals()(<span class="d_keyword">auto</span> <span class="d_keyword">ref</span> <span class="d_keyword">const</span> S s) <span class="d_keyword">const</span> { ... }
}
</span></pre>


<h2><a name="compare">Overloading <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span>, <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span>, and <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span></a></h2>

	<p>Comparison operations are rewritten as follows:</p>

	<center><table border=1 cellpadding=4 cellspacing=0><caption>Overloadable Unary Operators</caption>
	<tr><th class="donthyphenate"><b>comparison</b></th><th class="donthyphenate"><b>rewrite 1</b></th><th class="donthyphenate"><b>rewrite 2</b></th></tr>
	<tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">a</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">b</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">a.opCmp(b)</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span>
	<span class="notranslate"><span class="d_inlinecode donthyphenate">0</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">b.opCmp(a)</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">0</span></span></td></tr>
	<tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">a</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">= b</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">a.opCmp(b)</span></span>
	<span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">= 0</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">b.opCmp(a)</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">= 0</span></span></td></tr>
	<tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">a</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">b</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">a.opCmp(b)</span></span>
	<span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">0</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">b.opCmp(a)</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">0</span></span></td></tr>
	<tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">a</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">= b</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">a.opCmp(b)</span></span>
	<span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">= 0</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">b.opCmp(a)</span></span> <span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">= 0</span></span></td></tr>
	</table></center>

	<p>Both rewrites are tried. If only one compiles, that one is taken.
	If they both resolve to the same function, the first
	rewrite is done. If they resolve to different functions, the best matching one
	is used. If they both match the same, but are different functions, an ambiguity
	error results.
	</p>

	<p>If overriding Object.opCmp() for classes, the class member function
	signature should look like:</p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C {
  <span class="d_keyword">override</span> <span class="d_keyword">int</span> opCmp(Object o) { ... }
}
</span></pre>

	<p>If structs declare an opCmp member function, it should follow the following
	form:</p>
<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S {
  <span class="d_keyword">int</span> opCmp(<span class="d_keyword">ref</span> <span class="d_keyword">const</span> S s) <span class="d_keyword">const</span> { ... }
}
</span></pre>

<h2><a name="FunctionCall">Function Call Operator Overloading <span class="notranslate"><span class="d_inlinecode donthyphenate">f()</span></span></a></h2>

	<p>The function call operator, (), can be overloaded by
	declaring a function named <span class="notranslate"><span class="d_inlinecode donthyphenate">opCall</span></span>:
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> F {
  <span class="d_keyword">int</span> <b><i>opCall</i></b>
();
  <span class="d_keyword">int</span> <b><i>opCall</i></b>
(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, <span class="d_keyword">int</span> z);
}

<span class="d_keyword">void</span> test() {
  F f;
  <span class="d_keyword">int</span> i;

  i = f();      <span class="d_comment">// same as i = f.opCall();
</span>  i = f(3,4,5); <span class="d_comment">// same as i = f.opCall(3,4,5);
</span>}
</span></pre>

	<p>In this way a struct or class object can behave as if it
	were a function.
	</p>

	<p><span class="notranslate"><span class="d_inlinecode donthyphenate">static opCall</span></span> also works as expected for function call operator with
	type names.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> Double {
  <b><i><span class="d_keyword">static</span></i></b>
 <span class="d_keyword">int</span> <b><i>opCall</i></b>
(<span class="d_keyword">int</span> x) { <span class="d_keyword">return</span> x * 2; }
}
<span class="d_keyword">void</span> test() {
  <span class="d_keyword">int</span> i = Double(2);
  <span class="d_keyword">assert</span>(i == 4);
}
</span></pre>

	<p>Note that merely declaring <span class="notranslate"><span class="d_inlinecode donthyphenate">opCall</span></span> automatically disables
	<a href="struct.html#StructLiteral">struct literal</a> syntax.
	To avoid the limitation, you need to also declare <a href="Struct-Constructor">	constructor</a> so that it takes priority over <span class="notranslate"><span class="d_inlinecode donthyphenate">opCall</span></span> in <span class="notranslate"><span class="d_inlinecode donthyphenate">Type(...)</span></span> syntax.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> Multiplier {
  <span class="d_keyword">int</span> factor;
  <span class="d_keyword">this</span>(<span class="d_keyword">int</span> num) { factor = num; }
  <span class="d_keyword">int</span> opCall(<span class="d_keyword">int</span> value) { <span class="d_keyword">return</span> value * factor; }
}
<span class="d_keyword">void</span> test() {
  Multiplier m = Multiplier(10);  <span class="d_comment">// invoke constructor
</span>  <span class="d_keyword">int</span> result = m(5);              <span class="d_comment">// invoke opCall
</span>  <span class="d_keyword">assert</span>(result == 50);
}
</span></pre>

<h2><a name="Assignment">Assignment Operator Overloading</a></h2>

	<p>The assignment operator <span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span> can be overloaded if the
	left hand side is a struct aggregate, and <span class="notranslate"><span class="d_inlinecode donthyphenate">opAssign</span></span>
	is a member function of that aggregate.</p>

	For struct types, operator overloading for the identity assignment
	is allowed.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> S {
  <span class="d_comment">// identiy assignment, allowed.
</span>  <span class="d_keyword">void</span> <b><i>opAssign</i></b>
(S rhs);

  <span class="d_comment">// not identity assignment, also allowed.
</span>  <span class="d_keyword">void</span> <b><i>opAssign</i></b>
(<span class="d_keyword">int</span>);
}
S s;
s = S();      <span class="d_comment">// Rewritten to s.opAssign(S());
</span>s = 1;        <span class="d_comment">// Rewritten to s.opAssign(1);
</span></span></pre>

	However for class types, identity assignment is not allowed. All class
	types have reference semantics, so identity assignment by default rebinds
	the left-hand-side to the argument at the right, and this is not overridable.

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> C {
  <span class="d_comment">// If X is the same type as C or the type which is
</span>  <span class="d_comment">// implicitly convertible to C, then opAssign would
</span>  <span class="d_comment">// accept identity assignment, which is disallowed.
</span>  <span class="d_comment">// C opAssign(...);
</span>  <span class="d_comment">// C opAssign(X);
</span>  <span class="d_comment">// C opAssign(X, ...);
</span>  <span class="d_comment">// C opAssign(X ...);
</span>  <span class="d_comment">// C opAssign(X, U = defaultValue, etc.);
</span>
  <span class="d_comment">// not an identity assignment - allowed
</span>  <span class="d_keyword">void</span> <b><i>opAssign</i></b>
(<span class="d_keyword">int</span>);
}
C c = <span class="d_keyword">new</span> C();
c = <span class="d_keyword">new</span> C();  <span class="d_comment">// Rebinding referencee
</span>c = 1;        <span class="d_comment">// Rewritten to c.opAssign(1);
</span></span></pre>

<h3>Index Assignment Operator Overloading</h3>

	<p>If the left hand side of an assignment is an index operation
	on a struct or class instance,
	it can be overloaded by providing an opIndexAssign member function.
	Expressions of the form <span class="notranslate"><span class="d_inlinecode donthyphenate">a[</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">] = c</span></span> are rewritten
	as <span class="notranslate"><span class="d_inlinecode donthyphenate">a.opIndexAssign(c,</span></span> <i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> A {
  <span class="d_keyword">int</span> <b><i>opIndexAssign</i></b>
(<span class="d_keyword">int</span> value, size_t i1, size_t i2);
}

<span class="d_keyword">void</span> test() {
  A a;
  a<b><i>[</i></b>
i,3<b><i>]</i></b>
 = 7;  <span class="d_comment">// same as a.opIndexAssign(7,i,3);
</span>}
</span></pre>

<h3>Slice Assignment Operator Overloading</h3>

	<p>If the left hand side of an assignment is a slice operation
	on a struct or class instance,
	it can be overloaded by providing an opSliceAssign member function.
	Expressions of the form <span class="notranslate"><span class="d_inlinecode donthyphenate">a[</span></span><i>i</i>..<i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">] = c</span></span> are rewritten
	as <span class="notranslate"><span class="d_inlinecode donthyphenate">a.opSliceAssign(c,</span></span> <i>i</i>, <i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">)</span></span>, and
	<span class="notranslate"><span class="d_inlinecode donthyphenate">a[] = c</span></span> as <span class="notranslate"><span class="d_inlinecode donthyphenate">a.opSliceAssign(c)</span></span>.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> A {
  <span class="d_keyword">int</span> <b><i>opSliceAssign</i></b>
(<span class="d_keyword">int</span> v);  <span class="d_comment">// overloads a[] = v
</span>  <span class="d_keyword">int</span> <b><i>opSliceAssign</i></b>
(<span class="d_keyword">int</span> v, size_t x, size_t y);  <span class="d_comment">// overloads a[i .. j] = v
</span>}

<span class="d_keyword">void</span> test() {
  A a;
  <span class="d_keyword">int</span> v;

  a<b><i>[]</i></b>
 = v;  <span class="d_comment">// same as a.opSliceAssign(v);
</span>  a<b><i>[</i></b>
3..4<b><i>]</i></b>
 = v;  <span class="d_comment">// same as a.opSliceAssign(v,3,4);
</span>}
</span></pre>

<h2><a name="OpAssign">Op Assignment Operator Overloading</a></h2>

	<p>The following op assignment operators are overloadable:</p>

	<center><table border=1 cellpadding=4 cellspacing=0><caption>Overloadable Op Assignment Operators</caption>
	<tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">+=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">-=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">*=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">/=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">%</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">^^=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&amp;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span></td></tr>
	<tr><td><span class="notranslate"><span class="d_inlinecode donthyphenate">|</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">^=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&lt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span></td><td>	<span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">&gt;</span></span><span class="notranslate"><span class="d_inlinecode donthyphenate">=</span></span></td><td><span class="notranslate"><span class="d_inlinecode donthyphenate">~=</span></span></td><td>&nbsp;</td></tr>
	</table></center>

	<p>The expression:</p>
<pre class="d_code"><span class="notranslate">a <i>op</i>= b
</span></pre>

	<p>is rewritten as:</p>

<pre class="d_code"><span class="notranslate">a.opOpAssign!(<span class="d_string">"$(METACODE op)"</span>)(b)
</span></pre>

<h3>Index Op Assignment Operator Overloading</h3>

	<p>If the left hand side of an <i>op</i>= is an index expression on
	a struct or class instance and opIndexOpAssign is a member:</p>

<pre class="d_code"><span class="notranslate">a[<i><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;</i>] <i>op</i>= c
</span></pre>

	<p>it is rewritten as:</p>

<pre class="d_code"><span class="notranslate">a.opIndexOpAssign!(<span class="d_string">"$(METACODE op)"</span>)(c, <i><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;</i>)
</span></pre>

<h3>Slice Op Assignment Operator Overloading</h3>

	<p>If the left hand side of an <i>op</i>= is a slice expression on
	a struct or class instance and opSliceOpAssign is a member:</p>

<pre class="d_code"><span class="notranslate">a[<i><i>i</i>..<i>j</i></i>] <i>op</i>= c
</span></pre>

	<p>it is rewritten as:</p>

<pre class="d_code"><span class="notranslate">a.opSliceOpAssign!(<span class="d_string">"$(METACODE op)"</span>)(c, <i><i>i</i>, <i>j</i></i>)
</span></pre>

	<p>and</p>

<pre class="d_code"><span class="notranslate">a[] <i>op</i>= c
</span></pre>

	<p>it is rewritten as:</p>

<pre class="d_code"><span class="notranslate">a.opSliceOpAssign!(<span class="d_string">"$(METACODE op)"</span>)(c)
</span></pre>

<h2><a name="Array">Index Operator Overloading</a></h2>

	<p>The array index operator, <span class="notranslate"><span class="d_inlinecode donthyphenate">a[</span></span><i>b</i>&sub;, <i>b</i>&sub;, ... <i>b</i>&sub;<span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span>, can be overloaded by
	declaring a function named <span class="notranslate"><span class="d_inlinecode donthyphenate">opIndex</span></span> with one
	or more parameters.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">struct</span> A {
  <span class="d_keyword">int</span> <b><i>opIndex</i></b>
(size_t i1, size_t i2, size_t i3);
}

<span class="d_keyword">void</span> test() {
  A a;
  <span class="d_keyword">int</span> i;
  i = a[5,6,7];  <span class="d_comment">// same as i = a.opIndex(5,6,7);
</span>}
</span></pre>

	<p>In this way a struct or class object can behave as if it
	were an array.
	</p>

	<p>If an index expression can be rewritten using opIndexAssign or opIndexOpAssign,
	those are preferred over opIndex.
	</p>

<h2><a name="Slice">Slice Operator Overloading</a></h2>

	<p>Overloading the slicing operator means overloading expressions
	like <span class="notranslate"><span class="d_inlinecode donthyphenate">a[]</span></span> and <span class="notranslate"><span class="d_inlinecode donthyphenate">a[</span></span><i>i</i>..<i>j</i><span class="notranslate"><span class="d_inlinecode donthyphenate">]</span></span>.
	This can be done by declaring a member function named <span class="notranslate"><span class="d_inlinecode donthyphenate">opSlice</span></span>.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">class</span> A {
  <span class="d_keyword">int</span> <b><i>opSlice</i></b>
();  <span class="d_comment">// overloads a[]
</span>  <span class="d_keyword">int</span> <b><i>opSlice</i></b>
(size_t x, size_t y); <span class="d_comment">// overloads a[i .. j]
</span>}

<span class="d_keyword">void</span> test() {
  A a = <span class="d_keyword">new</span> A();
  <span class="d_keyword">int</span> i;
  <span class="d_keyword">int</span> v;

  i = a<b><i>[]</i></b>
;         <span class="d_comment">// same as i = a.opSlice();
</span>  i = a<b><i>[</i></b>
3..4<b><i>]</i></b>
;  <span class="d_comment">// same as i = a.opSlice(3,4);
</span>}
</span></pre>

	<p>If a slice expression can be rewritten using opSliceAssign or opSliceOpAssign,
	those are preferred over opSlice.
	</p>

<h2><a name="Dispatch">Forwarding</a></h2>

	<p>Member names not found in a class or struct can be forwarded
	to a template function named <span class="notranslate"><span class="d_inlinecode donthyphenate">opDispatch</span></span> for resolution.
	</p>

<pre class="d_code"><span class="notranslate"><span class="d_keyword">import</span> std.stdio;

<span class="d_keyword">struct</span> S {
  <span class="d_keyword">void</span> opDispatch(string s, T)(T i)
  {
    writefln(<span class="d_string">"S.opDispatch('%s', %s)"</span>, s, i);
  }
}

<span class="d_keyword">class</span> C {
  <span class="d_keyword">void</span> opDispatch(string s)(<span class="d_keyword">int</span> i) {
    writefln(<span class="d_string">"C.opDispatch('%s', %s)"</span>, s, i);
  }
}

<span class="d_keyword">struct</span> D {
  <span class="d_keyword">template</span> opDispatch(string s) {
    <span class="d_keyword">enum</span> <span class="d_keyword">int</span> opDispatch = 8;
  }
}

<span class="d_keyword">void</span> main() {
  S s;
  s.opDispatch!(<span class="d_string">"hello"</span>)(7);
  s.foo(7);

  <span class="d_keyword">auto</span> c = <span class="d_keyword">new</span> C();
  c.foo(8);

  D d;
  writefln(<span class="d_string">"d.foo = %s"</span>, d.foo);
  <span class="d_keyword">assert</span>(d.foo == 8);
}
</span></pre>

  
<div id="google_ad">
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>

</div><!--/content-->





<div id="footernav">
<a href="http://forum.dlang.org/" title="User Forums">Forums</a> |
<a href="http://wiki.dlang.org/DocComments/OperatorOverloading" title="Read/write comments and feedback">Comments</a> |
<a href="http://digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a> |
<a href="download.html" title="Download D">Downloads</a> |
<a href="/">Home</a>
</div>
<div id="copyright">

Copyright &copy; 1999-2013 by Digital Mars &reg;, All Rights Reserved
 |
Page generated by <a href="ddoc.html">Ddoc</a> on Wed Oct 02 13:49:23 2013


</div>

</body>
</html>

